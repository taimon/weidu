% Note added due to LGPL terms.
%
% This file was edited by Valerio Bigiani, AKA The Bigg, starting from
% 6 November 2005. All changes for this file are listed in
% diffs/doc.base.tex.diff file, as the output of a diff -Bw -c -N command.
%
% It was originally taken from Westley Weimer's WeiDU 185.

\documentclass{article}

\usepackage{hevea}
\usepackage{color}
\usepackage{index}
\usepackage{url}
\makeindex

\def\ttref#1{\ahrefloc{#1}{\tt #1}}
\def\DEFINE#1{{\tt \bf #1}\label{#1}\index{#1}}
\def\DEFSYN#1{{\tt \bf #1}\index{#1}}
\def\t#1{{\tt #1}}
\def\CMD#1{{\tt {C:$\backslash$Program Files$\backslash$Black Isle$\backslash$BGII - SoA$\backslash$>} \color{red} \t{#1} }}
\def\Slist{{\color{red} list }}
\def\Ob{{\color{red} [ }}
\def\Oe{{\color{red} ] }}

% This is to make hevea happy (indexing)
\def\textexcl{!}
\def\textpipe{|}

\title{WeiDU Documentation}
\author{Valerio Bigiani, AKA The Bigg\\
\mailto{thebigg@spellholdstudios.net}\\
edited according to the GPL from the original version by \\
Westley Weimer\\
 \mailto{weimer@cs.berkley.edu}}

\begin{document}

\maketitle
\tableofcontents

% Note: '!' becomes '_' in the final output. So COPY!REGEXP becomes
% COPY_REGEXP. This is to deal with some hideousness in the latex->html
% converter. 

% \DEFINE{foo} and \ttref{foo} are used for indexing and cross-references. 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{About WeiDU}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

The main home page for WeiDU is:
\ahrefurl{\url{http://weidu.org/}}.
I encourage you to download the latest version. 

WeiDU is designed to make it easier to write and distribute modifications
to Infinity Engine games. It can load and modify Infinity Engine resources
according to instructions you provide. WeiDU is ideal for packaging
modifications that include dialogue or that want to be compatible with
other modifications. 

I'll be honest with you up front: WeiDU is initially harder to use than
some of its alternatives. However, most users report that (1) the
alternatives are insufficient because they lack features that only WeiDU
provides and (2) WeiDU grows on you over time. 

You are welcome to use these utilities to make and distribute your own
Infinity Engine mods. This utility is covered by the GNU General Public
License, but you are also allowed to distribute an unmodified binary copy
of \t{WeiDU.EXE} (without the source code) with your mod if you like.

I decided to write my own Infinity Engine \ttref{DLG} and \ttref{TLK}
utilities because I was unable to get the TeamBG DLG Editor and Mass
Converter to work properly. Either they wouldn't parse the strings or they
would mangle the text or they would randomly crash ... it was bad all
around. Also, they were all GUIs. As a unix weenie I'm in love with command
line utilities and as a PL doctoral student I love making little languages
and compilers.  WeiDU was originally a family of small programs with
unimaginative names like DC, DD and TP. The more appealing term ``WeiDU''
(which rhymes with ``IDU'', Eye-Dee-You) was coined by Jason Compton and
Ghreyfain, noted BGII mod authors. 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Don't Panic!}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Step-By-Step Beginner's Guide to WeiDU:

\begin{enumerate}

\item Don't Panic. Many of you are children of the GUI era. But programs
that run from the command line can be your friend, and in the long run are
often much faster and, yes, easier to use.

\item The Best Way To Learn How To Write Code In WeiDU's \ttref{D} Format
Is To {\em Read} Code Written In WeiDU's \ttref{D} Format. Start by decompiling
existing in-game \ttref{DLG}s that you understand and read through them.
Compare how they appear in WeiDU to how they appear in other BG2 editing
tools you may be more comfortable with, such as Near Infinity or Infinity
Explorer.

\item The Best Way To Learn How To Write Code In WeiDU's \ttref{D} Format
Is To {\em Read} Code Written In WeiDU's \ttref{D} Format, Part 2. A growing
number of BG2 add-on packs are being created using WeiDU. A list is
available at
\ahrefurl{\url{http://www.pocketplane.net/modlist/}}.
These
can help you understand how WeiDU's advanced features, such as dialogue
appending, script and \ttref{2DA} patching, and item/spell/creature
patching work in a ``real-world'' setting.  Make it a point to download some
of them and understand HOW they work.

\item Take a look at some of the examples in this document. 
There is a lovely WeiDU tutorial (written by
Japheth) available at
\ahrefurl{\url{http://forums.pocketplane.net/index.php?topic=55.0}}.  
If you
are feeling overwhelmed, start there first. It also covers installation.
Ghreyfain also has a ``how to create an NPC with WeiDU'' tutorial at
\ahrefurl{\url{http://forums.pocketplane.net/index.php?topic=52.0}}. 

\item There is a WeiDU discussion board at
\ahrefurl{\url{http://forums.pocketplane.net/index.php?board=50.0}}.  The
discussion board is the best place to have your WeiDU (and mod-making)
questions answered. 

\item Finally, if you are using a Mac and you want to play around with
WeiDU, check out \ahrefurl{\url{http://weidu.org/Mac.html}} for more
information on obtaining a copy of WeiDU that works under OS X. 

\end{enumerate}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{\ttref{D} and \DEFINE{DLG} File Concepts}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

This section is a gentle introduction to how Infinity Engine \ttref{DLG}
files are structured. First, let's use WeiDU to create
\t{SCSARLES.}\ttref{D} and take a look at the dialogue of Sir Sarles. 

You may install \t{WeiDU.exe} anywhere on your system. However, I recommend
that you put it in your Baldur's Gate 2 installation directory.  However,
WeiDU will use the Windows Registry to attempt to locate your BG2 game
files. 

To run the effect described, open up a DOS prompt window and change
directories to get to your BGII directory. Then just type in the
{\color{red} \tt text in red} at the DOS Prompt. 

\CMD{weidu SCSARLES.DLG} 

This will create a text file called \t{SCSARLES.D} in the current
directory.  Open it up with Notepad or Microsoft Word or something. It's
just a text file that describes the game dialogue.

It will look something like: 
\begin{rawhtml}
<pre width="80"><font color="#219121">// creator  : c:\bgate\weidu\weidu.exe
</font><font color="#219121">// argument : SCSARLES.DLG
</font><font color="#219121">// game     : C:\Program Files\Black Isle\BGII - SoA
</font><font color="#219121">// source   : C:\Program Files\Black Isle\BGII - SoA\data\Dialog.bif
</font><font color="#219121">// dialog   : C:\Program Files\Black Isle\BGII - SoA\DIALOG.TLK
</font><font color="#219121">// dialogF  : (none)
</font>
<font color="#3159D1">BEGIN</font> <font color="#868626">~SCSARLES~</font>

<font color="#3159D1">IF</font> <font color="#868626">~NumTimesTalkedTo(0)~</font> <font color="#3159D1">THEN</font> <font color="#3159D1">BEGIN</font> <font color="#0000FF">0</font> <font color="#219121">// from:
</font>  <font color="#3159D1">SAY</font> <font color="#0000FF">#28655</font> <font color="#219121">/* ~Who is it? Might I ask why you have disturbed my
    meditations? My creative muse must be gently awakened, and your
    stomping about is simply not conducive to this.~ [SARLES02] */</font>
  <font color="#3159D1">IF</font> <font color="#868626">~~</font> <font color="#3159D1">THEN</font> <font color="#3159D1">REPLY</font> <font color="#0000FF">#28656</font> <font color="#219121">/* ~My apologies. I will leave you to your
    thinking.~ */</font> <font color="#3159D1">GOTO</font> <font color="#0000FF">1</font>
  <font color="#3159D1">IF</font> <font color="#868626">~~</font> <font color="#3159D1">THEN</font> <font color="#3159D1">REPLY</font> <font color="#0000FF">#28657</font> <font color="#219121">/* ~I apologize, but I have come to request your
    talent on a commissioned artwork.~ */</font> 
      <font color="#3159D1">DO</font> <font color="#868626">~SetGlobal("TalkedToSarles","GLOBAL",1)~</font> <font color="#3159D1">GOTO</font> <font color="#0000FF">2</font>
<font color="#3159D1">END</font>

<font color="#3159D1">IF</font> <font color="#868626">~~</font> <font color="#3159D1">THEN</font> <font color="#3159D1">BEGIN</font> <font color="#0000FF">1</font> <font color="#219121">// from: 0.0
</font>  <font color="#3159D1">SAY</font> <font color="#0000FF">#28661</font> <font color="#219121">/* ~Then I shall forget you were ever here. Actually, it is an
    astoundingly easy thing to do.~ */</font>
  <font color="#3159D1">IF</font> <font color="#868626">~~</font> <font color="#3159D1">THEN</font> <font color="#3159D1">DO</font> <font color="#868626">~SetNumTimesTalkedTo(0)~</font> <font color="#3159D1">EXIT</font>
<font color="#3159D1">END</font></pre>
\end{rawhtml} Dialogues in Infinity Engine games behave like finite state machines. If
you aren't familiar with the concept of a finite state machine, see
\ahrefurl{\url{http://whatis.techtarget.com/definition/0,,sid9_gci213052,00.html}} or
\ahrefurl{\url{http://www.c3.lanl.gov/mega-math/workbk/machine/mabkgd.html}}.
Each block of the form: 
\begin{rawhtml}
<pre width="80">  <font color="#3159D1">IF</font> <font color="#868626">~Initial Condition~</font> <font color="#3159D1">THEN</font> <font color="#3159D1">BEGIN</font> state1
    <font color="#3159D1">SAY</font> <font color="#868626">~Something~</font>
    <font color="#3159D1">IF</font> <font color="#868626">~Reply Condition~</font> <font color="#3159D1">THEN</font> <font color="#3159D1">REPLY</font> <font color="#868626">~Reply Text~</font> <font color="#3159D1">GOTO</font> state2
  <font color="#3159D1">END</font></pre>
\end{rawhtml} represents a \ttref{state} (more details below). When the player starts a
conversation with an NPC, the game engine scans through all
of the \ttref{state}s in that NPC's \ttref{DLG} file in a special
\ttref{WEIGHT}ed order and picks the one with a non-empty and true "Initial
Condition". If no state has a non-empty and true "Initial Condition" then
you get that ``Bob - has nothing to say to you.'' message. Don't worry about
the weighting process for now. 

The speaker (in this case, Sir Sarles) then says whatever appears after
\ttref{SAY}.  The \ttref{REPLY} lines represent responses the PC can say
back. If the "Reply Condition" is true, the player is given the option of
saying the "Reply Text" and moving to another state in the dialogue (where
Sarles will probably say something else). 

Remember: \ttref{SAY} is for what the NPC says, \ttref{REPLY} is for what
the player says back. If you think carefully, you'll notice that all
dialogue in Infinity Engine games is structed in this manner. 

Conditions use the same syntax as triggers do in Infinity Engine
\ttref{BCS} scripting. You will need to learn Infinity Engine scripting
before too long. \ttref{String}s are delineated by tildes or \%\%
or "" (your choice, but WeiDU uses the tilde by default).  After
\ttref{SAY} or \ttref{REPLY} or \ttref{JOURNAL} you may give two
\ttref{String}s
instead of one. The first is used with \t{DIALOG.}\ttref{TLK}, the second
is used with \t{DIALOGF.}\ttref{TLK} (foreign language version for when the
main character is female). If you do not give two \ttref{String}s, the one
\ttref{String} you gave is used for both. 

You may also use raw numbers prefaced with a number sign (like \t{\#1234})
to specify a strref inside \t{DIALOG.}\ttref{TLK} directly. This is useful
when modifying existing dialogues (say, the Fate Spirit in ToB) so that you
if a foreign user installs your dialogue they will retain all of the
foreign versions of the strings you didn't change or add. Normally
the string reference numbers are put right after the \ttref{SAY} keyword
and the string text is put in comments.  The \t{--text} command-line option
causes string text to be emitted with the string number in comments. 

You may also indicate that a sound file (WAV/WAVC) should be associated
with a given \ttref{String} by including its up-to-8-letter resource name in
\t{[brackets]} after the string, as in:
\begin{rawhtml}
<pre width="80">  <font color="#3159D1">SAY</font> <font color="#868626">~Hello~</font> [HELLO]
</pre>
\end{rawhtml}
Comments are C/C++ style: everything from // to the end of the line is a
comment, as is /* everything in these star-slash things */. Comments are
ignored by WeiDU. They are there for your benefit. Example: 
\begin{rawhtml}
<pre width="80">  <font color="#3159D1">SAY</font> <font color="#868626">~Hello~</font> [HELLO]   <font color="#219121">// this is a comment        ... way out to here!
</font>  <font color="#3159D1">IF</font> <font color="#219121">/* this is also a comment */</font> <font color="#868626">~~</font> <font color="#3159D1">THEN</font> <font color="#3159D1">EXIT</font>
</pre>
\end{rawhtml}
Replies can also contain actions (using the \ttref{DO} keyword) which
behave just like Infinity Engine \ttref{BCS} script actions. They can also
add Journal entries, end the dialogue or transfer to another speaker. 

Examples: 
\begin{rawhtml}
<pre width="80">  <font color="#3159D1">IF</font> <font color="#868626">~~</font> <font color="#3159D1">THEN</font> <font color="#3159D1">BEGIN</font> <font color="#0000FF">2</font> <font color="#219121">// from: 0.1
</font></pre>
\end{rawhtml}
This line marks the beginning of \ttref{state} 2 in a dialogue. The comment
tells you that it can be reached by the first reply \ttref{transition} from
state 0. 
\begin{rawhtml}
<pre width="80">  <font color="#3159D1">IF</font> <font color="#868626">~~</font> <font color="#3159D1">THEN</font> <font color="#3159D1">REPLY</font> <font color="#868626">~My apologies. I will leave you to your thinking.~</font> <font color="#219121">// </font><font color="#0000FF">#28656</font>
      <font color="#3159D1">GOTO</font> <font color="#0000FF">1</font>
</pre>
\end{rawhtml}
This \ttref{REPLY} can always be chosen and involves the spoken text "My
apologies...". That text is string reference number 28656. If the PC
chooses that reply, it transitions to state 1.

Finally, a \ttref{transition} may also take the form:
\begin{rawhtml}
<pre width="80">  <font color="#3159D1">COPY_TRANS</font> filename label
</pre>
\end{rawhtml}
During processing, \ttref{COPY!TRANS} will be replaced by all of the
transitions from state "label" of file "filename". The copying takes place
before all other \ttref{D} actions.  

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{{\tt D} Dialogue File Format} \label{D}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

The \ttref{D} file format is a way of describing Infinity Engine dialogues
and modifications to Infinity Engine Dialogues in a portable,
easy-to-understand format. It supports foreign language translations and
allows you to describe extensions to existing game dialogues without
forcing you to describe their content. This allows you to write mods that
work with mods written by others. 

The \ttref{D} file format is presented here in an extended context-free
grammar notation. If you are unfamiliar with CFGs, take a look
\ahrefurl{\url{http://www.wikipedia.com/wiki/Context-free_grammar}},
\ahrefurl{\url{http://cs.wpi.edu/~kal/PLT/PLT2.1.2.html}}
or 
\ahrefurl{\url{http://www.cs.rochester.edu/users/faculty/nelson/courses/csc_173/grammars/cfg.html}}. 
You don't really need to understand a CFG formally, though. 

To get a real idea of how they work, use WeiDU to create JAHEIRA.D for
yourself and look at it in a text editor. You can also browse the \t{examples}
and \t{test} directories that come with WeiDU.

All of the syntax keywords are given in a {\tt UPPERCASE COURIER}.
All other keywords are symbolic. Notes:
\begin{itemize}
\item bar \Slist means "0 or more copies of bar".
\item \Ob foo \Oe means "an optional foo" or "0 or 1 copies of foo".
\item foo bar ...  means "you may repeat foo bar as often as you like here". 
\end{itemize}

\begin{tabular}{cp{10in}|p{10in}}

\DEFINE{D File} & & 
  A \ttref{D file} is a text file that contains a number of \ttref{D
  Actions}. \ttref{D File}s tell WeiDU how to create and modify Infinity
  Engine \ttref{DLG} files.  \\

  is & \ttref{D Action} \Slist & 
  A \ttref{D File} is a list of \ttref{D Action}s. Typically the first and
  only one is \ttref{BEGIN}, which defines the content of a new dialogue.
  Other \ttref{D Action}s can be used to modify existing dialogues. \\

\\

\DEFINE{D Action} & & 
  A \ttref{D Action} tells WeiDU how to create or modify Infinity Engine
  \ttref{DLG} files. \\

  is & \DEFINE{BEGIN} filename \Ob \DEFINE{nonPausing} \Oe \ttref{state} \Slist & 
    \ttref{BEGIN} tells WeiDU that you are creating a new DLG file from
    scratch. Any existing DLG file with the same name will be overwriten. 
    The new DLG file contains exactly the \ttref{state}s in the list. 
    If you set \ttref{nonPausing} to a non-zero integer, the game will not
    ``stop time'' while the conversation takes place. By default time stops
    during conversations.  \\

  or   & \DEFINE{APPEND} \Ob \t{IF!FILE!EXISTS} \Oe filename \ttref{state} \Slist {\tt END} &
    This tells WeiDU to place the given \ttref{state}s at the end of the
    already-existing dialogue \t{filename.}\ttref{DLG}. If there is IF!FILE!EXISTS
    and the file doesn't exists, this action is skipped. \\

  or   & \DEFINE{APPEND!EARLY} \Ob \t{IF!FILE!EXISTS} \Oe filename \ttref{state} \Slist {\tt END} &
    Works like \ttref{APPEND}, but the \ttref{state}s are added early on in
    the compilation timeline (just after \ttref{BEGIN} is processed). Thus
    they can be the targets for \ttref{INTERJECT!COPY!TRANS} and friends.
    \\ 

  or & \DEFINE{CHAIN}
    \Ob {\tt IF} \Ob {\tt WEIGHT} {\tt \#}weight \Oe {\tt
    stateTriggerString}  {\tt THEN} \Oe \Ob \t{IF!FILE!EXISTS} \Oe
    entryFilename entryLabel \ttref{chainText} \Slist
    \ttref{chainEpilogue} &
  This instructs WeiDU to make a long conversation in which the PC can say
  nothing. This is useful when you want the NPCs to talk among themselves
  for a long time. It and its friends, \ttref{INTERJECT} and
  \ttref{INTERJECT!COPY!TRANS} can incredible time-savers when you're
  writing non-trivial dialogue. See the examples for ideas. \ttref{CHAIN}
  will only append to existing dialogues. You cannot use \ttref{CHAIN} to
  create a new DLG. If the entryFilename file is missing and there is IF!FILE!EXISTS,
  the whole CHAIN is not compiled.
  \\

  or & \DEFINE{INTERJECT} entryFilename entryLabel {\tt globalVariable}
    \ttref{chainText} \Slist 
    \ttref{chainEpilogue} & 
  Behaves like \ttref{CHAIN} except that all of the \ttref{chainText} is
  additionally guarded by the \ttref{transition} predicate {\tt Global("globalVariable","GLOBAL",0)} and accompanied by the action {\tt SetGlobal("globalVariable","GLOBAL",1)}. If you pick {\tt globalVariable } to be unique, this will ensure that the \ttref{chainText} is only ever seen once per game. This is useful for making interjections. \\

  or & \DEFSYN{INTERJECT!COPY!TRANS} entryFilename entryLabel {\tt
  globalVariable} \ttref{chainText} \Slist &
  This behaves just like \ttref{INTERJECT} except that the exitFilename and
  exitLabel are not present. Instead, whenever the dialogue would pass out
  of the \ttref{chainText} it follows a copy of the \ttref{transition}s
  that were at the \ttref{state} with \ttref{stateLabel} originally. This
  is convenient for making quick interjections from NPCs that do not actually
  change the true flow of the conversation. See the \ttref{transition}
  \ttref{COPY!TRANS} and the \ttref{INTERJECT!COPY!TRANS} tutorial
  for more information about this idea.  \\

  or & \DEFSYN{INTERJECT!COPY!TRANS2} entryFilename entryLabel {\tt
  globalVariable} \ttref{chainText} \Slist &
  This works just like \ttref{INTERJECT!COPY!TRANS}, except that any
  actions taken in the transitions of the state specified by entryFilename
  and entryLabel are preserved and kept with the speaker associated with
  entryFilename (rather than being mistakenly performed by your new
  speaker). See the \ttref{INTERJECT!COPY!TRANS2} tutorial.
  \\

  or & \DEFINE{INTERJECT!COPY!TRANS3} entryFilename entryLabel {\tt
  globalVariable} \ttref{chainText} \Slist &
  This works just like \ttref{INTERJECT!COPY!TRANS}, except that all
  states in chainText get a link in the entry state, rather than only the
  first one. Expecting documentation.
  \\

  or & \DEFINE{INTERJECT!COPY!TRANS4} entryFilename entryLabel {\tt
  globalVariable} \ttref{chainText} \Slist &
  This is either \ttref{INTERJECT!COPY!TRANS3} with \ttref{INTERJECT!COPY!TRANS2}-style
  action handling, or \ttref{INTERJECT!COPY!TRANS2} with the extended
  \ttref{INTERJECT!COPY!TRANS3} state creation rules, depending at how you
  look at it.
  \\

  or   &
  \DEFINE{EXTEND!TOP}
    filename \ttref{stateLabel} \Slist \Ob {\tt \#positionNumber} \Oe
      \ttref{transition} \Slist \t{END} &
  This instructs WeiDU to add the \ttref{transition}s in list to the top of
  the \ttref{transition} list for the specified states in \t{filename.}\ttref{DLG}
  (which must already exist). 

  If a \t{positionNumber} is given, WeiDU to insert the \ttref{transition}s
  just between already-existing transitions \t{\#positionNumber} and
  \t{\#positionNumber+1} in the given states for the given file. The first
  \ttref{transition} is number 1.  \\

  or & \DEFINE{EXTEND!BOTTOM} filename \ttref{stateNumber} \Slist \Ob {\tt
  \#positionNumber} \Oe \ttref{transition} \Slist \t{END} &
  Behaves just like \ttref{EXTEND!TOP} but adds the transitions to the
  bottom of the list instead.  \\

  or & \DEFINE{ADD!STATE!TRIGGER} filename \ttref{stateNumber} 
    \ttref{stateTriggerString} \Ob \ttref{stateNumber} \Slist \Oe &
  This instructs WeiDU to add the \ttref{stateTriggerString} to all
  of the \ttref{state}s with the given \ttref{stateNumber}s in 
  the file \t{filename.}\ttref{DLG} (which must already exist). This is handy for
  adding extra conditions to an existing dialogue \ttref{state}. \\

  or & \DEFINE{ADD!TRANS!TRIGGER} filename \ttref{stateNumber} 
    \ttref{transTriggerString} \Ob \ttref{moreStateNumbers} \Slist \Oe 
    \Ob \t{DO} \ttref{transNumber} \Slist \Oe
    &
  This instructs WeiDU to add the \ttref{transTriggerString} to all
  of the \ttref{transition}s in all of the \ttref{state}s with the given
  \ttref{stateNumber}s in the file \t{filename.}\ttref{DLG} (which must already
  exist). This is often used in conjunction with \ttref{EXTEND!BOTTOM} to
  make a new branch in an existing \ttref{state}. Use
  \ttref{ADD!TRANS!TRIGGER} to add the negation of some predicate to all of
  the existing \ttref{transition}s, then use \ttref{EXTEND!BOTTOM} to add a
  \ttref{transition} with that predicate to that \ttref{state}. 
  If a list of \ttref{transNumber}s is specified, only those transitions 
  will have \ttref{transTriggerString} added to them. If such a list is not
  specified, every transition in every specified state will be modified.
  Note that the ``first'' transition is number 0. 
  \\

  or & \DEFINE{ADD!TRANS!ACTION} filename 
    \t{BEGIN} \ttref{stateNumber} \Slist \t{END} 
    \t{BEGIN} \ttref{transNumber} \Slist \t{END}
    \ttref{transActionString} &
  This instructs WeiDU to add the \ttref{transActionString} to all
  of the actions in all the \ttref{transition}s in all of the \ttref{state}s specified by the
  \t{stateNumber} list and the \t{transNumber} list. You may use
  state labels in the \t{stateNumber} list. If the \t{transNumber} list
  is empty, the text added to all transitions on all listed states.
  Note that the \t{BEGIN} and \t{END} keywords must be present, even if you
  specify an empty list of \t{transNumber}s.
  The ``first'' transition is number 0. Any out-of-bounds \t{transNumbers}
  are silently ignored. The \t{transActionString} is prepended to any
  existing action text on a per-\ttref{transition}, per-\ttref{state}
  basis.

  \\

  or & \DEFINE{REPLACE!TRANS!ACTION} filename
    \t{BEGIN} \ttref{stateNumber} \Slist \t{END}
    \t{BEGIN} \ttref{transNumber} \Slist \t{END}
    oldText newText &
  This instructs WeiDU to replace all instances of oldText in newText to all
  of the actions in all the \ttref{transition}s in all of the \ttref{state}s specified by the
  \t{stateNumber} list and the \t{transNumber} list. You may use
  state labels in the \t{stateNumber} list. If the \t{transNumber} list
  is empty, the text added to all transitions on all listed states.
  Note that the \t{BEGIN} and \t{END} keywords must be present, even if you
  specify an empty list of \t{transNumber}s.
  The ``first'' transition is number 0. Any out-of-bounds \t{transNumbers}
  are silently ignored.

  \\
  or & \DEFINE{REPLACE!TRANS!TRIGGER} filename
    \t{BEGIN} \ttref{stateNumber} \Slist \t{END}
    \t{BEGIN} \ttref{transNumber} \Slist \t{END}
    oldText newText &
  This instructs WeiDU to replace all instances of oldText in newText to all
  of the triggers in all of the \ttref{transition}s in all of the \ttref{state}s specified by the
  \t{stateNumber} list and the \t{transNumber} list. You may use
  state labels in the \t{stateNumber} list. If the \t{transNumber} list
  is empty, the text added to all transitions on all listed states.
  Note that the \t{BEGIN} and \t{END} keywords must be present, even if you
  specify an empty list of \t{transNumber}s.
  The ``first'' transition is number 0. Any out-of-bounds \t{transNumbers}
  are silently ignored.

  \\

  or & \DEFSYN{ALTER!TRANS} filename
    \t{BEGIN} \ttref{stateNumber} \Slist \t{END}
    \t{BEGIN} \ttref{transNumber} \Slist \t{END}
    \t{BEGIN} changeWhat changeInto \Slist \t{END} &
  Fine altering of a single transition. See the \ttref{ALTER!TRANS} tutorial.

  \\

  or & \DEFINE{REPLACE} filename \ttref{state} \Slist \t{END} &
  This instructs WeiDU to load \t{filename.}\ttref{DLG} and replace some of its 
  \ttref{state}s with the new ones described in the \ttref{state} list.
  All of the \ttref{state}s should have numeric stateLabels (e.g., "5" or
  "67"). A new \ttref{state} with label \t{X} will replace the old
  \ttref{state} number \t{X}.  \\

  or & \DEFINE{SET!WEIGHT} filename \ttref{stateLabel} \tt{\#stateWeight} &
  This instructcs WeiDU to destructively change the \ttref{WEIGHT} of the
  given \ttref{state} in \t{filename.}\ttref{DLG} (which must exist). This should only
  be used to patch or workaround existing dialogues. Never use
  \ttref{SET!WEIGHT} if you can help it.  \\

  or & \DEFINE{REPLACE!SAY} filename \ttref{stateLabel} \ttref{sayString} &
  This instructs WeiDU to destructively change the \ttref{sayString} of the
  given \ttref{state} in \t{filename.}\ttref{DLG} (which must exist). This should only
  be used to patch or workaround existing dialogues. Never use
  \ttref{REPLACE!SAY} if you can help it. \\

  or & \DEFINE{REPLACE!STATE!TRIGGER} filename \ttref{stateNumber} 
    \ttref{stateTriggerString} \Ob \ttref{stateNumber} \Slist \Oe &
  This instructs WeiDU to destructively set the
  \ttref{stateTriggerString} of all of the \ttref{state}s with the given
  \ttref{stateNumber}s in the file \t{filename.}\ttref{DLG} (which must already
  exist). It should be used with caution. \\

  or & \DEFINE{REPLACE!TRIGGER!TEXT} filename oldText newText &
  This instructs WeiDU to destructively replace every occurrence of oldText
  (which may be a \ttref{regexp}) in the \ttref{stateTriggerString}s and
  \ttref{transTriggerString}s of \t{filename.}\ttref{DLG} (which must exist). 
  This should only be used to patch or workaround existing dialogues. Never
  use this if you can help it. \\

  or & \DEFINE{REPLACE!TRIGGER!TEXT!REGEXP} filenameRegexp oldText newText &
  Just like \ttref{REPLACE!TRIGGER!TEXT} but the filename is a
  \ttref{regexp}. The \ttref{.DLG} is implied. Do not use this. \\

  or & \DEFINE{REPLACE!ACTION!TEXT} filename oldText newText 
    \Ob moreFilenames \Oe &
  This instructs WeiDU to destructively replace every occurrence of oldText
  (which may be a \ttref{regexp}) in the \ttref{stateActionString}s 
  of \t{filename.}\ttref{DLG} (which must exist). This should only be used
  to patch or workaround existing dialogues. Never use this if you can help
  it. \\

  or & \DEFINE{REPLACE!ACTION!TEXT!REGEXP} filenameRegexp oldText newText 
    \Ob moreFilenameRegexps \Oe &
  Just like \ttref{REPLACE!ACTION!TEXT} but the filenames are
  \ttref{regexp}s. The \ttref{.DLG} is implied, do not include it in your
  \ttref{regexp}s. Do not use this. \\

  or & \DEFINE{REPLACE!ACTION!TEXT!PROCESS} filename oldText newText
    \Ob moreFilenames \Oe &
  This instructs WeiDU to destruveily replace every occurrence of oldText
  (which may be a \ttref{regexp}) in the \ttref{stateActionString}s 
  of \t{filename.}\ttref{DLG} (which must exist) with newText. However,
  newText is first compiled as a \ttref{BAF} action list. In particular,
  this means that replacing with commands like:
  \begin{verbatim}
  ~DisplayString(Myself,@123)~
  \end{verbatim}
  ... will do what you expect.  This should only be used to patch or
  workaround existing dialogues. Never use this if you can help it. \\

  or & \DEFINE{R!A!T!P!R}
    filenameRegexp oldText newText
    \Ob moreFilenameRegexps \Oe &
  Just like \ttref{REPLACE!ACTION!TEXT!PROCESS}, but the filenames are
  \ttref{regexp}s. The \ttref{.DLG} is implied. Do not use this. R!A!T!P!R is
  shortand for REPLACE!ACTION!TEXT!PROCESS!REGEXP (to avoid undue scrollbars
  in the readme on a 1024x768 monitor). \\


\\

\DEFINE{chainEpilogue} & & Determines where the dialogue should flow at the
end of the \ttref{CHAIN}. \\
is & {\tt END} filename stateNumber & Transfer to the given state in the given dialogue file. \\
or & {\tt EXTERN} filename stateNumber & Transfer to the given state in the given dialogue file. \\
or & {\tt COPY!TRANS} filename stateNumber & At the end of the
\ttref{CHAIN} text, copy all transitions from the given state in the
given file. This is useful for interjections (see \ttref{INTERJECT}).  \\
or & {\tt EXIT} & At the end of the \ttref{CHAIN} text, exit the dialogue.\\
or & {\tt END} \ttref{transition} \Slist & Execute the given \ttref{transition}s
after the final state in the \ttref{CHAIN}. \\

\\

\DEFINE{state} & & In Infinity Engine games, this is the fundamental unit
of dialogue. \\
is & {\tt IF} \Ob \DEFINE{WEIGHT} \t{\#weightNumber} \Oe \DEFINE{stateTriggerString} \Ob {\tt THEN} \Oe
  \Ob {\tt BEGIN} \Oe \DEFINE{stateLabel} \DEFINE{SAY} \ttref{sayText} \Ob =
  \ttref{sayText} ... \Oe \ttref{transition} \Slist \t{END} & 
  When you start conversing with a creature that uses a \ttref{DLG} file, the
  Infinity Engine searches through all of the \ttref{state}s in that file
  in order of increasing \ttref{WEIGHT} and selects the first one it finds
  for which the \ttref{stateTriggerString} is both true and not empty. 
  The creature then says all of the associated \ttref{sayText}. Finally,
  the \ttref{transitions} are evaluted in bottom-up (i.e., reverse) order.
  If a \ttref{transition} is found with a \ttref{transTriggerString} that
  evaluates to True and no \ttref{replyText}, that \ttref{transition} is
  immediately executed. Otherwise, all of the \ttref{transition}s are
  presented as options to the PC. 

  \ 

  If a \ttref{stateLabel} is an integer it is called a
  \DEFINE{stateNumber}. All of the states in the \ttref{DLG} files that
  come with the original game use \ttref{stateNumber}s. Only \ttref{D}
  files use symbolic strings for \ttref{stateLabel}s. 
  
  \ 

  Including more than one bit of \ttref{sayText} here is often called
  \ttref{Multisay}. 

  \ 

  Finally, once you are familiar with the syntax you may omit the \t{THEN}
  and \t{BEGIN} keywords if you like. 
  \\

or & \DEFINE{APPENDI} filename \ttref{state} \Slist \t{END} &
  This is legacy syntax that behaves just like the \ttref{D Action}
  \ttref{APPEND} but is considered a \ttref{state}. Avoid it. \\

or & \DEFINE{CHAIN2} entryFilename entryLabel 
  \t{chain2Text} \Slist exitFilename exitLabel & 
  This is legacy syntax that behaves somewhat like the \ttref{D Action}
  \ttref{CHAIN} but is considered a \ttref{state}. In addition, 
  \t{chain2Text} is slightly different from \ttref{chainText}. Avoid
  this construction. \\

\\

\DEFINE{sayText} & & \t{sayText} and \DEFINE{replyText} are displayed to
the user as part of a dialogue. \\ 
is & \ttref{text} & \t{sayText} and \t{replyText} are both \ttref{text}. \\

\\ 

\DEFINE{transition} & & Transitions determine how dialogue flows from one
state to another. \\

is & \t{IF} \DEFINE{transTriggerString} \Ob \t{THEN} \Oe
      \ttref{transFeature} \Slist \ttref{transNext} &
    If the \ttref{transTriggerString} evaluates to true or is empty, this
    \ttref{transition} is viable. If it contains no \ttref{replyText}
    within its \ttref{transFeature} list, it is immediately taken.
    Otherwise, the \ttref{replyText} is presented as an option to the user. 
    If the transition is taken, any actions in the \ttref{transFeature}
    list are performed and the dialogue flows to the point indicated by the
    \ttref{transNext}. 
  \ttref{transition}s are evaluated in "reverse order". That is, the "bottom"
  or "last" response for a \ttref{state} is checked first. If its
  \ttref{transTriggerString}
  evaluates to true and it has no \ttref{REPLY} text, that transition is
  immediately taken. See \t{SAREV25A} \ttref{state} 1 for an example of a
  \ttref{state} with all kinds of \ttref{transition}s. \\

or & \t{+} \Ob \ttref{transTriggerString} \Oe \t{+} \ttref{replyText}
     \ttref{transFeature} \Slist \ttref{transNext} & 
  This abbreviated syntax for transitions that would contain \ttref{REPLY}
  (which is by far the most common case) allows you to save yourself 
  some time and typing. It behaves like the full form above.  \\

or & \DEFINE{COPY!TRANS} filename \ttref{stateLabel} &
    This instructs WeiDU to copy all of the \ttref{transition}s from the
    \ttref{state} with the given \ttref{stateLabel} in \t{filename.}\ttref{DLG}. This
    copying takes place before all other \ttref{D Action}s. For example,
    this is a valid \ttref{transition} list:
\begin{rawhtml}
<pre width="40"><font color="#3159D1">IF</font> <font color="#868626">~Before()~</font> <font color="#3159D1">THEN</font> <font color="#3159D1">GOTO</font> my_state
<font color="#3159D1">COPY_TRANS</font> PLAYER1 <font color="#0000FF">33</font>
<font color="#3159D1">IF</font> <font color="#868626">~After()~</font> <font color="#3159D1">THEN</font> <font color="#3159D1">EXTERN</font> SOLA <font color="#0000FF">55</font></pre>
\end{rawhtml} \\

\\

\DEFINE{transFeature} & & These are features or actions associated with
taking a transition. \\
is & \DEFINE{REPLY} \ttref{replyText} & 
  If this \ttref{transition} is taken, the PC says the \ttref{replyText}.  \\
or & \DEFINE{DO} \DEFINE{stateActionString} & 
  If this \ttref{transition} is taken, the \ttref{stateActionString} is
  executed.  \\
or & \DEFINE{JOURNAL} \ttref{text} &
  If this \ttref{transition} is taken, the \ttref{text} is added to the
  PC's journal. \\
or & \DEFINE{SOLVED!JOURNAL} \ttref{text} &
  If this \ttref{transition} is taken, the \ttref{text} is added to the
  ``solved'' section of the PC's journal. \\
or & \DEFINE{UNSOLVED!JOURNAL} \ttref{text} &
  If this \ttref{transition} is taken, the \ttref{text} is added to the
  ``unsolved'' section of the PC's journal. \\
or & \DEFINE{FLAGS} integer &
  This allows you to set the features associated with a transition directly
  using the binary format of \ttref{DLG} files. \emph{Do not use this!} \\

\\

\DEFINE{transNext} & & This determines where dialogue flows after a
transition has been taken. \\
is & \DEFINE{GOTO} \ttref{stateLabel} &
  The dialogue continues at the state with label \ttref{stateLabel} in the
  same \ttref{DLG} file as the current \ttref{state}. \\
or & \DEFINE{EXTERN} \Ob \t{IF!FILE!EXISTS} \Oe filename \ttref{stateLabel} &
  The dialogue continues at the state with label \ttref{stateLabel} in the
  file \t{filename.}\ttref{DLG}. The whole transition is not compiled if there's
  IF!FILE!EXISTS and the file filename doesn't exist. \\
or & \DEFINE{EXIT} &
  The conversation ends. \\
or & \t{+} \ttref{stateLabel} &
  This is a synonym for \ttref{GOTO}. \\

\\

\DEFINE{chainText} & & This is a rapid shorthand for chaining together many
little bits of dialogue when the PC is not saying anything. \\
is & \Ob \t{IF} \ttref{transTriggerString} \t{THEN} \Oe \ttref{sayText} 
      = \ttref{sayText} ... & \\
followed by &
      \Ob == \Ob \t{IF!FILE!EXISTS} \Oe fileName
      \Ob \t{IF} \ttref{transTriggerString} \t{THEN} \Oe \ttref{sayText}
      = \ttref{sayText} ... \Oe &
      The == (that's two consecutive equal signs) marks the beginning of a
      new speaker (indicated by fileName).  If the
      \ttref{transTriggerString} is true or if it is not present, this new
      speaker says all of its \ttref{sayText} in order. If the \t{IF!FILE!EXISTS}
      part is present, these lines are not compiled at all if the current file is
      not missing.
      \\
or followed by &
    \t{BRANCH} \ttref{transTriggerString} \t{BEGIN}
      \Ob == \Ob \t{IF!FILE!EXISTS} \Oe fileName
      \Ob \t{IF} \ttref{transTriggerString} \t{THEN} \Oe \ttref{sayText}
      = \ttref{sayText} ... \Oe
    \t{END} &
      As above, except that the first transTriggerString is appended to all
      existing dialogue units.\\
\\

\DEFINE{text} & & This represents strings that are shown to the player,
rather than strings that the game uses internally for predicates and
actions. \\
is & \ttref{String} \Ob \t{[WAVEFILE]} \Oe & The given string is used for both male and
female players. The optional \t{[WAVEFILE]} is the associated sound. \\

or & \ttref{String} \Ob \t{[WAVEFILE]} \Oe \ttref{String} \Ob \t{[WAVEFILE]} \Oe &
The first string and sound file are used if the PC is male, the second
string and sound file are used if the PC is female. This is useful mainly
for international versions of Infinity Engine games. \\

or & \t{\#integer} & The string with reference number \t{\#integer} from
\t{DIALOG.}\ttref{TLK} should be used unchanged. \\

or & \t{@integer} & The last definition of the translation string
\t{@integer} given in any \ttref{TRA} file should be used.\\

or & \t{!integer} \ttref{text} & \DEFINE{Forced String Reference}. As with
\ttref{text} in general, but rather than being assigned a new,
previously-unused \t{DIALOG.TLK} string entry (or merging with an existing
one that has the same \ttref{text}), this \ttref{text} is written over
\t{DIALOG.TLK} string entry \#\t{integer}. \emph{Do not use this feature.}
\\

\\

\DEFINE{String} & & This is how you tell WeiDU what text you want shown
to the player. For international mods or international translations, you 
may use any encoding you like (that is, you are not restricted to 7-bit
characters or Latin-1 or anything like that). \\
is & {\bf{"}}abcdef{\bf{"}} & A string can be any sequence of characters not
including a " that is enclosed in ""s. \\
or & {\bf{\verb+~+}}abcdef{\bf\verb+~+} & A string can be any sequence of
characters not including a \verb+~+ that is enclosed in
{\verb+~+\verb+~+}s. \\
or & {\bf{\%}}abcdef{\bf{\%}} & A string can be any sequence of characters not
including a \% that is enclosed in \%\%s. This is handy for Big5
translations, since " and \verb+~+ can be part of Big5-encoded characters.
\\
or & {\bf{\verb+~~~~~+}}abcdef{\bf\verb+~~~~~+} & That's five consequtive
tildes on each side. A string can be any
sequence of characters not including \verb+~~~~~+ that is enclosed in 
{\verb+~~~~~+}s. For example, 
string \#8750 is
{\color{red}\verb`~!@#$\%^&*()_+-=[]{}\|;:'",<.>/?`}
and can be given to WeiDU as
{\verb+~~~~~+}{\color{red}\verb`~!@#$\%^&*()_+-=[]{}\|;:'",<.>/?`}{\verb+~~~~~+}
 (the content of the string is shown in red for clarity). 
\\
or & \ttref{String} \t{\^{ }} \ttref{String} & String literal concatenation.
The second string is appended to the first string. No whitespace is added.
Thus \t{"hello" \^{ } "World"} is the same as \t{"helloWorld"}.

\\

\end{tabular}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Command Line Options}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

WeiDU is a command-line utility. GUIs are available, but this document only
describes command-line invocation. Use the DOS Shell ("command" or "cmd")
to run WeiDU. You control its behavior by passing arguments to it on the
command line. 

You invoke WeiDU by typing {\tt WeiDU} and then any number of options and
files, as described below. 

Note: since it may not be obvious, if an option accepts 'X' and says to be
cumulative, if you want to apply it multiple times you have to use the following
hideousness:
\begin{verbatim}
weidu --string 1 --string 2 --string 3
\end{verbatim}
This does not apply to *-rest commands like --biff-get-rest and --force-install-rest.

Moreover, *-rest commands must be the last, EG
\begin{verbatim}
weidu --biff-get-rest sw1h01.itm --out foo
\end{verbatim}
will try to extract sw1h01.itm, --out and foo from the biffs; you have to express the above as
\begin{verbatim}
weidu --out foo --biff-get-rest sw1h01.itm
\end{verbatim}

*-list commands work like the -rest variants, except that they stop parsing for the current
switch once they find an option starting with '-'. Basically, this works like you'd expect:
\begin{verbatim}
weidu --biff-get-list sw1h01.itm --out foo
\end{verbatim}


\ 

\begin{tabular}{lp{10in}|p{10in}}
\multicolumn{2}{c}{ \color{red} Compiling And Decompiling } \\
\tt{FILE.}\ttref{D}   & Compile \t{FILE} to a \ttref{DLG} (dialogue file). \\
\tt{FILE.}\ttref{DLG} & Decompile \t{FILE} to a \ttref{D} (dialogue text file). \\
\t{number}            & When decompiling a \ttref{DLG} file to a \ttref{D}
file, emit only state \t{number}. You may specify this multiple times and
only the states you specify will be emitted. \\
\t{numberA}\t{-}\t{numberB} &  When decompiling a \ttref{DLG} file to a
\ttref{D} file, emit only states between \t{numberA} and \t{numberB}
(inclusive). You may specify this multiple times and only the states you
specify will be emitted. \\
\tt{FILE.}\ttref{BAF} & Compile \t{FILE} to a \ttref{BCS} (script file).  \\
\tt{FILE.}\ttref{BCS} & Decompile \t{FILE} to a \ttref{BAF} (script text file).  \\
\DEFINE{--script-style} \t{X} & Use the given \ttref{BAF}/\ttref{BCS}
scripting style. \t{X} must be \t{BG} or \t{BG1} or \t{BG2} or \t{PST} or \t{IWD} or \t{IWD1}
or \t{IWD2}. \\
\DEFINE{--transin} \t{X} &
Use {\tt FILE} as a source of translation strings
when processing \ttref{D} and \ttref{BAF} files. \\
\tt{FILE.}\ttref{TRA} & Equivalent to \ttref{--transin} \t{FILE.TRA}. \\
\\
\multicolumn{2}{c}{ \color{red} Module Packaging Input And Control} \\
{\tt FILE.}\ttref{TP}  or
\tt{FILE.}\ttref{TP2} & Read {\tt FILE} and ask the user whether to install,
reinstall or uninstall its \ttref{TP2} \ttref{Component}s. \\
\DEFINE{--yes} & Answer all \ttref{TP2} questions with 'Yes' and do not
prompt for a key to be pressed at the end of \ttref{TP2} processing. \\
\DEFINE{--uninstall}  	& Answer all \ttref{TP2} questions with 'Uninstall'
and do not prompt for a key to be pressed at the end of \ttref{TP2}
processing. \\
\DEFINE{--reinstall}  	& Re-install all \ttref{TP2} components that are
already installed and do not promtp for a key to be pressed at the end of
\ttref{TP2} processing. \\
\DEFINE{--language}m  \t{X}   & Sets the \ttref{TP2} \ttref{Language} to the one
passed here. Has no effect if the value is bigger than the language count
(I.E. you'll get asked for the language, unless you gave --uninstall, --reinstall
or --force-uninstall). \\
\DEFINE{--force-install} \t{X} & installs component number X, skips the others (cumulative). \\
\DEFINE{--force-uninstall} \t{X} & uninstalls component number X, skips the others (cumulative).
If there is no --force-install, you don't get asked for the language. \\
\DEFINE{--force-install-rest} \t{X Y...} & installs component number X Y...,
skips the others (cumulative). \\
\DEFINE{--force-uninstall-rest} \t{X Y...} & uninstalls component number X Y...,
skips the others (cumulative). \\
\DEFINE{--force-install-list} \t{X Y...} & installs component number X Y...,
skips the others (cumulative). \\
\DEFINE{--force-uninstall-list} \t{X Y...} & uninstalls component number X Y...,
skips the others (cumulative). \\
\DEFINE{--skip-at-view} & AT!* ~VIEW this~ actions (and the extra chromosome versions like
~NOTEPAD this~) aren't processed, while still processing batch files and similia. \\
\DEFINE{--ask-every}    & Behave as if \ttref{ASK!EVERY!COMPONENT} were
present for all \ttref{TP2} components. \\
\DEFINE{--continue}     & Continue \ttref{TP2} processing despite
\ttref{TP2 Action} errors. \\
\DEFINE{--args} \t{X}       & X will be stored in the tp2 variable \verb+%argv[n]%+, where
n is 0 for the first argument, 1 for the second, etc. 

If the installation is non-interactive, said variables will be loaded from the last interactive
session. \\
\DEFINE{--args-rest} \t{X Y...} & X Y Z will be stored in the tp2 variables \verb+%argv[n]%+,
where n is 0 for the first argument, 1 for the second, etc.

If the installation is non-interactive, said variables will be loaded from the last interactive
session. \\
\DEFINE{--args-list} \t{X Y...} & X Y Z will be stored in the tp2 variables \verb+%argv[n]%+,
where n is 0 for the first argument, 1 for the second, etc.

If the installation is non-interactive, said variables will be loaded from the last interactive
session. \\
\DEFINE{--debug-assign} & Print out all values assigned to \ttref{TP2}
variables (even implicit ones created by \t{WeiDU}). \\
\DEFINE{--debug-value} & Print out all \ttref{value}s encountered in
\ttref{TP2} processing and the results they evaluate to. Among other
things, this is useful for catching parenthesis errors in your
\ttref{value}s. \\
\DEFINE{--clear-memory} & calls \ttref{CLEAR!MEMORY} after every \ttref{TP2} action.
\\
\multicolumn{2}{c}{ \color{red} Automatic Updating Options } \\
\DEFINE{--update-all} & Auto-update all \t{WeiDU} setup files (e.g.,
\t{Setup-MyMod.exe}) in the current directory. \\ 
\DEFINE{--noautoupdate} & If you are running \t{WeiDU} as
\t{Setup-MyMod.exe}, do not attempt to update yourself or any other mod. \\
\DEFINE{--noselfupdatemsg} & If you are running \t{WeiDU} as
\t{Setup-MyMod.exe} and it automatically updates itself, do not display a
message or ask the user to press return. \\
\\
\multicolumn{2}{c}{ \color{red} Infinity Engine Game Location Options } \\
{\tt \DEFINE{--game} X	} & Set main game directory to {\tt X}. WeiDU looks for
{\tt CHITIN.}\ttref{KEY} and {\tt DIALOG.}\ttref{TLK} and the \t{override}
directory in the main game directory (but see \ttref{--tlkin} and
\ttref{--search}). WeiDU will look in the current directory and use the
registry to find your game. If this fails, you will need to run WeiDU using
the \ttref{--game} switch to define the full path to the BG2 directory.
WeiDU will also search for BG1, IWD and PST. \\ \DEFINE{--nogame}  & Do not
load any default game files. Unless you also specified \ttref{--tlkin}, no
\t{DIALOG.TLK} will be loaded. Unless you also specified \ttref{--search},
no \t{override} directory will be used. \\
\DEFINE{--search} \t{X}	& Look in {\tt X} for input files (cumulative).
\t{X} is treated as an \t{override} directory and is given priority over 
the default \t{override} directory. \\
\\
\multicolumn{2}{c}{ \color{red} Game Text (\ttref{TLK}) File Input} \\
\DEFINE{--tlkin} \t{X}	& Use {\tt X} as {\tt DIALOG.}\ttref{TLK} (instead
of looking for \t{DIALOG.TLK} in the game directory). \\
\DEFINE{--ftlkin} \t{X} & Use {\tt X} as {\tt DIALOGF.}\ttref{TLK} (instead
of looking for \t{DIALOGF.TLK} in the game directory). \\
\tt{FILE.}\ttref{TLK} & Equivalent to \ttref{--tlkin} \t{X}. \\
\DEFINE{--tlkmerge} \t{X}	& Merge strings from {\tt X} over the strings from any other loaded {\tt \t{DIALOG.}\ttref{TLK}.} \\
\\
\multicolumn{2}{c}{ \color{red} General Output Options} \\
\DEFINE{--out} \t{X} &	Emit most output files generated by command-line
options (e.g., \ttref{D}, \ttref{DLG}, kits, \ttref{--biff-get},
\ttref{BAF}, \ttref{BCS}, \ttref{--automate}, \ttref{--traify-tlk},
\ttref{--extract-kits}, \ttref{--list-biff}, \ttref{--cmp-from},
\ttref{--dcmp-from}, etc.) to file {\tt X}. If \t{X} is a directory,
certain commands (e.g., \ttref{D}, \ttref{DLG}, \ttref{--biff-get}, etc.)
will place their output there.  Does not affect \ttref{TP2} processing. \\
\DEFINE{--append} \t{X} & Like \ttref{--out}, but if \t{X} is an existing
file then the result will be appended to it instead of overwriting it. \\
\DEFINE{--backup} \t{X} &	Backup files to directory {\tt X} before overwriting. Does not affect \ttref{TP2} processing. \\
\DEFINE{--tlkout} \t{X} &	If any strings were added to or changed in the loaded \t{DIALOG.TLK}, emit \t{X} as an updated version that reflects those changes. Many operations (e.g., compiling \t{D} files, \ttref{--tlkmerge}, \ttref{STRING!SET}) can add to or modify \t{DIALOG.TLK}. \\
\DEFINE{--ftlkout} \t{X} & If any strings were added to or changed in the
loaded \t{DIALOGF.TLK}, emit \t{X} as an updated version that reflects
those changes. \\
\\
\multicolumn{2}{c}{ \color{red} Dialogue Text File (\ttref{D}) Options} \\
\DEFINE{--noheader} &	Do not emit \ttref{D} header comments. \\
\DEFINE{--nofrom} &	Do not emit \ttref{D} {\tt // from:} comments. \\
\DEFINE{--full-from} &  Generate complete {\tt // from:} comments with a
slower two-pass process. \\
\DEFINE{--nocom} & Do not emit ANY \ttref{D} or \ttref{BAF} comments. \\
\DEFINE{--text} & Emit string text with string references in comments. \\
\DEFINE{--transitive} & Follow \ttref{EXTERN} links when making \ttref{D}
files. See the tutorial on \ttref{--transitive}. \\
\DEFINE{--toplevel} & Emit only top-level dialogue states -- that is,
states with non-empty triggers. \\ 
\\
\multicolumn{2}{c}{ \color{red} Translation Options} \\
\DEFINE{--traify} \t{X} & Convert \t{X} (which should be a \ttref{D} or \ttref{TP2} or \ttref{BAF}) so that it uses translation references instead of literal strings. Use \ttref{--out} \t{Y} to specify a name for the transformed version of \t{X} and its new \ttref{TRA} file. \\
\t{--traify\#} \t{X} &	Use with \ttref{--traify} and \ttref{--traify-tlk}. Start the newly-created \ttref{TRA} file at translation string {\tt @X} instead of {\tt @0}. \\
\DEFINE{--traify-old-tra} \t{X} & Assumes file X to contain strings already in .tra format.
Use this over \t{--traify\#} for merging new strings in an already traified \ttref{D} or \ttref{TP2} or \ttref{BAF} file.
\\
\DEFINE{--untraify-d} \t{X} & convert .D file X to use hardcoded strings... \\
\DEFINE{--untraify-tra} \t{X} & ...from TRA file X. Please note that the outcoming file
  could not work properly (if baf code embedded in a d file contains @ references, or if a string contains
  the\verb+~+ character). \\
\DEFINE{--trans} & Emit coupled \ttref{D} and \ttref{TRA} files when
  decompiling a \ttref{DLG}.  \\
\DEFINE{--transref} &	Emit string reference numbers in \ttref{TRA} files
when using \ttref{--trans}. \\
\DEFINE{--traify-tlk} & Emit a \ttref{TRA} file for the loaded \ttref{TLK} file (see \ttref{--tlkin}, \ttref{--out}, \ttref{--min} and \t{--traify\#}). \\
\DEFINE{--make-tlk} \t{X} & Create a \ttref{TLK} file from \ttref{TRA} file X (cumulative, see \ttref{--tlkout}). \\
\DEFINE{--testtrans} &	Test all specified \ttref{TRA} translation files to
see if any of them use text that is already in the loaded
\ttref{DIALOG.TLK}. If they do you can save translation effort by using
string references instead. \\
\DEFINE{--forceify} \t{X} & Convert the given \ttref{D} file to use forced
strrefs (see \ttref{--out}, \ttref{SAY}, \ttref{Forced String Reference}). \\
\\
\multicolumn{2}{c}{ \color{red} Game Text Repository (\ttref{TLK}) Options} \\
\DEFINE{--string} \t{X}&	Display string reference {\tt \#X} (cumulative). If you also specify \ttref{--min} or \ttref{--max}, all string references between \ttref{--min} (or 0) and \ttref{--max} (or infinity) will be displayed. \\
\DEFINE{--strfind} \t{X}&	Display strings that contain {\tt X} (cumulative, \ttref{regexp} allowed). \\
\DEFINE{--strapp} \t{X}&	Append string \t{X} to \t{DIALOG.}\ttref{TLK} (cumulative). \\
\\
\multicolumn{2}{c}{ \color{red} Game Archive (\ttref{BIFF}) Options} \\
\DEFINE{--list-biffs}&	Enumerate all \ttref{BIFF} files in \t{CHITIN.}\ttref{KEY}. \\
\DEFINE{--list-files}&	Enumerate all resource files in \t{CHITIN.}\ttref{KEY} \\
\DEFINE{--biff} \t{X} & Enumerate contents of \ttref{BIFF} file \t{X} (cumulative). \\
\DEFINE{--biff-get} \t{X}&	Extract resource \t{X} from game \ttref{BIFF}s (cumulative, \ttref{regexp} allowed). \\
\DEFINE{--biff-get-rest} \t{X} \t{Y} ... & Every argument given on the
command line after \ttref{--biff-get-rest} is treated as if it were
preceeded by \ttref{--biff-get}. Use this command to extract multiple
different files (or \ttref{regexp}s) at once. \\
\DEFINE{--biff-get-list} \t{X} \t{Y} ... & Every argument given on the
command line after \ttref{--biff-get-rest} is treated as if it were
preceeded by \ttref{--biff-get}, with the -list exception. Use this command to extract multiple
different files (or \ttref{regexp}s) at once. \\
\DEFINE{--biff-str} \t{X}&	Search all game \ttref{BIFF}s for files
containing \t{X} (\ttref{regexp} allowed). \\
\DEFINE{--biff-value} \t{X} &   Search all game \ttref{BIFFs} for files
containing value \t{X} at offset \t{ADDR}. Must be used with
\ttref{--biff-value-at}. \\
\DEFINE{--biff-value-at} \t{ADDR} & Gives the offset address for a
\ttref{--biff-value} search. \\
\DEFINE{--biff-type} \t{X}&	Limit \ttref{--biff-str} or
\ttref{--biff-value} searches to
resources of type \t{X} (cumulative). \\
\DEFINE{--biff-name} \t{X}&	When a \ttref{--biff-str} or
\ttref{--biff-value} search finds a
matching file, assume it has a strref name at offset \t{X} and print that
name out as well. \\
\DEFINE{--make-biff} \t{X} & Create \t{data/X.bif} from all files in
folder \t{X} and destructively update \t{CHITIN.KEY}. \emph{Do not use this
feature.} \emph{Do not even think of using this feature without backing up
\t{CHITIN.KEY}.} \\
\DEFINE{--remove-biff} \t{X} & Remove references to \ttref{BIFF} \t{X} and
all of its resources from \t{CHITIN.KEY}. \emph{Do not use this feature.} \\
\\
\multicolumn{2}{c}{ {\color{red} Comparison Options} (see \ttref{--out})} \\
\DEFINE{--cmp-from} \t{X}&	Emit \ttref{WRITE!BYTE}s to turn this file ... \\
\DEFINE{--cmp-to}   \t{X}&	... into this one. \\
\DEFINE{--dcmp-from}\t{X}&	Emit \ttref{REPLACE}s to turn this \ttref{DLG} file ... \\
\DEFINE{--dcmp-to}  \t{X}&	... into this one. \\
\DEFINE{--tcmp-from}\t{X}&	Compare this \ttref{TRA} file (or directory of \ttref{TRA }files)... \\
\DEFINE{--tcmp-to}  \t{X}&	... with this one (or this directory). \\
\DEFINE{--tlkcmp-from}\t{X}&	Emit \ttref{STRING!SET}s to convert this \ttref{TLK} file ... \\
\DEFINE{--tlkcmp-to}\t{X}&	... into this one. \\
\DEFINE{--tlkcmp-use-strings} & When using \ttref{--tlkcmp-from}, emit
commands of the form \t{STRING!SET "Hello" @1} instead of \t{STRING!SET \#1
@1}. \\
\DEFINE{--bcmp-from}  \t{X}&      Emit \ttref{APPLY!BCS!PATCH} to turn this
\ttref{BCS} file ... \\
\DEFINE{--bcmp-to}    \t{X}&      ... into this one. \\
\DEFINE{--bcmp-orig}  \t{X}&      Original file \t{X} to apply ... \\
\DEFINE{--bcmp-patch} \t{X}&      ... this patch to. \\
\\
\multicolumn{2}{c}{ \color{red} Range Options} \\
\DEFINE{--min} \t{X} & Lower range for some commands. See
\ttref{--traify-tlk}, \ttref{--tlkcmp-from} and \ttref{--string}.  \\
\DEFINE{--max} \t{X} & Upper range for some commands. \\
\\
\multicolumn{2}{c}{ \color{red} Automatic Module Packaging Options} \\
\DEFINE{--automate} \t{X}&   Automatically create a \ttref{TP2} file for resources in folder \t{X}. See \ttref{--out}. \\
\DEFINE{--automate-min} \t{X}& Only \ttref{--automate} string references above \t{X}. If not specified, it is assumed as 62169 (that is, the number of strings in unmodded SoA). \\
\DEFINE{--extract-kits} \t{X} & Extract all kits starting with kit \#\t{X}
and create \ttref{TP2} actions to install those kits as part of a module.  \\
\\
\multicolumn{2}{c}{ \color{red} Resouce Exploration Options } \\
\DEFINE{--list-eff} \t{X}&	List effects in resource \t{X}. See
\ttref{--out}. \\
{\tt F.}\ttref{ITM} or 
{\tt F.}\ttref{EFF} or 
\tt{F.}\ttref{SPL} & Equivalent to \ttref{--list-eff} \t{F.EXT}. \\
\\
\multicolumn{2}{c}{ \color{red} Logging Options } \\
\DEFINE{--log} \t{X}&	Log output and details to \t{X}. \\
\DEFINE{--autolog} & 	Log output and details to \t{WSETUP.DEBUG}. \\
\DEFINE{--logapp} & 	Append to log file instead of overwriting it. \\
\end{tabular}

Finally, note that WeiDU will \emph{not} add duplicate strings to
\t{DIALOG.}\ttref{TLK}. If you instruct WeiDU to make use of the string
``Imoen'' (via \ttref{SAY} or \t{--strapp} or whatever) it will re-use any
existing definition of ``Imoen'' instead. Two strings are equivalent in
this sense only if they have the same text and the same associated sounds
(normally strings have no associated sounds).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Example Uses}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{itemize}

\item Decompiling a \ttref{DLG} to a \ttref{D} 

\CMD{weidu bodhi.dlg}
\begin{verbatim}
  [C:\Program Files\Black Isle\BGII - SoA\chitin.key] 182 BIFFs, 41793 resources
  [C:\Program Files\Black Isle\BGII - SoA\DIALOG.TLK] 84458 string entries
  [C:\Program Files\Black Isle\BGII - SoA\data\Dialog.bif] 2729 file entries
  [BODHI.DLG] loaded
  [.\BODHI.D] created from [BODHI.DLG]
\end{verbatim}

  This loads \t{BODHI.}\ttref{DLG} from the standard search path (i.e., the
  current directory, your override directory, then the game \ttref{BIFF}s) and
  creates \t{BODHI.}\ttref{D} from it. 


\item Decompiling a \ttref{DLG} file with translations

\CMD{weidu bodhi.dlg --trans}
\begin{verbatim}
        ...
  [.\BODHI.TRA] created as translation file
  [.\BODHI.D] created from [BODHI.DLG]
\end{verbatim}

  This creates \t{BODHI.}\ttref{D} as above and also the translation file
  \t{BODHI.}\ttref{TRA} (listing all of the strings in \t{BODHI.}\ttref{D}
  in an easy-to-traslate or spell-check format). \t{BODHI.}\ttref{D} will
  be created with special references to those strings. 

  This is particularly useful if you are converting existing modifications
  you may have created with another tool, such as IDU, into WeiDU format.
  It allows you to both create the WeiDU \ttref{D} code and the
  translation-friendly string labels at the same time.

\item  Decompiling a \ttref{DLG} files with options

  \CMD{ weidu --nofrom bodhi.dlg --out foozle.d --text}
  \begin{verbatim}
        ...
  [.\foozle.d] created from [BODHI.DLG]
  \end{verbatim}

  This creates \t{foozle.d} (instead of \t{BODHI.D}) and does not put any
  \t{"// from:"} comments in \t{foozle.d}. It will include \ttref{state}s
  with \ttref{SAY}s of the form 
\begin{rawhtml}
<pre width="80"> <font color="#3159D1">SAY</font> <font color="#868626">~Hello~</font> <font color="#219121">/* #1 */</font> </pre>
\end{rawhtml} 
instead of 
\begin{rawhtml}
<pre width="80"> <font color="#3159D1">SAY</font> <font color="#0000FF">#1</font> <font color="#219121">/* ~Hello~ */</font> </pre>
\end{rawhtml}

\item  Decompiling multiple \ttref{DLG} files

  \CMD{ weidu bodhi.dlg jaheira.dlg --out test}
  \begin{verbatim}
        ...
  [test\JAHEIRA.D] created from [JAHEIRA.DLG]
  [test\BODHI.D] created from [BODHI.DLG]
  \end{verbatim}

  This loads \t{BODHI.DLG} and \t{JAHEIRA.DLG} and creates \t{BODHI.D} and
  \t{JAHEIRA.D}. The optional
  \t{--out test} argument instructs WeiDU to put the resulting \ttref{D}
  files in the \t{test} directory. 

\item  Compiling a \ttref{D} file

  \CMD{ weidu bodhi.d}
  \begin{verbatim}
        ...
  [bodhi.d] parsed
  [BODHI.DLG] saved       135 states, 259 trans, 16 strig, 66 ttrig, 54 actions
  \end{verbatim}

  This loads and parses bodhi.d and then executed all instructions in it.
  This \t{bodhi.d} file just defines \t{BODHI.DLG}, which is created. If
  \t{bodhi.d} contains strings that do not occur in \t{DIALOG.}\ttref{TLK},
  \t{BODHI.DLG} will be created with invalid string references. 

\item  Compiling a \ttref{D} file that includes new text

  \CMD{ weidu bodhi.d --tlkout new-\t{DIALOG.}\ttref{TLK}}
  \begin{verbatim}
        ...
  [bodhi.d] parsed
  [BODHI.DLG] saved       135 states, 259 trans, 16 strig, 66 ttrig, 54 actions
  [new-DIALOG.TLK] created, 84459 string entries
  \end{verbatim}

  This loads and parses \t{bodhi.d} and then executed all instructions in it.
  This \t{bodhi.d} file just defines \t{BODHI.DLG}, which is created. If
  there are any new strings a new version of \t{\t{DIALOG.}\ttref{TLK}} is written to
  \t{new-\t{DIALOG.}\ttref{TLK}}.

\item  Compiling multiple \ttref{D} files

  \CMD{ weidu ppworker.d bodhi.d --out test}
  \begin{verbatim}
        ...
  [bodhi.d] parsed
  [ppworker.d] parsed
  [BODHI.DLG] saved       135 states, 259 trans, 16 strig, 66 ttrig, 54 actions
  [PPWORKER.DLG] saved    33 states, 81 trans, 4 strig, 12 ttrig, 10 actions
  \end{verbatim}

  This creates \t{test/BODHI.DLG} and \t{test/PPWORKER.DLG} based on the
  instructions in \t{bodhi.d} and \t{ppworker.d}. 
  If these \ttref{D} files include new text, use \t{--tlkout} to make a new
  \t{\t{DIALOG.}\ttref{TLK}}. 

\item  Compiling a \ttref{D} file that defines many \ttref{DLG} files

  \CMD{ weidu examples/sola/solae1.d}
    \\ OR \\
  \CMD{ weidu examples$\backslash$sola$\backslash$solae1.d}
  \begin{verbatim}
        ...
  [examples/sola/solae1.d] parsed
  [SOLA.DLG] loaded
  [SOLA.DLG] saved        336 states, 401 trans, 64 strig, 18 ttrig, 125 actions
  [SOLAE1.DLG] saved      36 states, 49 trans, 1 strig, 11 ttrig, 1 actions
  [SOLAE2.DLG] saved      3 states, 3 trans, 0 strig, 0 ttrig, 0 actions
  [SOLAE3.DLG] saved      2 states, 2 trans, 0 strig, 0 ttrig, 0 actions
  [SOLAE4.DLG] saved      3 states, 3 trans, 1 strig, 0 ttrig, 0 actions
  [SOLAE5.DLG] saved      2 states, 2 trans, 0 strig, 0 ttrig, 0 actions
  [SOLAE6.DLG] saved      4 states, 5 trans, 0 strig, 2 ttrig, 0 actions
  \end{verbatim}

  It just so happens that \t{solae1.d} \ttref{APPEND}s text to 
  \t{SOLA.DLG} and
  creates \t{SOLAE1.DLG}, \t{SOLAE1.DLG}, 
  \t{SOLAE3.DLG}, ..., \t{SOLAE6.DLG}. You could
  have put them all in the override directory with \t{--out override}. You
  may use the forward slash (/) or the backslash ($\backslash$) for
  directories. Use \t{--tlkout} to make a new \t{\t{DIALOG.}\ttref{TLK}} if these
  contain new text. 

\item  Compiling a \ttref{D} file that uses a \ttref{TRA} file

  \CMD{ weidu examples/sola/solafoe.d --transin examples/sola/solafoe.tra}
  \\ OR \\
  \CMD{ weidu examples/sola/solafoe.d examples/sola/solafoe.tra}
  \begin{verbatim}
        ...
  [examples/sola/solafoe.tra] parsed (15 translation strings)
  [examples/sola/solafoe.d] parsed
  [SOLA.DLG] loaded
  [SOLA.DLG] saved        336 states, 401 trans, 65 strig, 18 ttrig, 124 actions
  [SOLAFOE.DLG] saved     11 states, 14 trans, 1 strig, 2 ttrig, 1 actions
  \end{verbatim}

  It happens that \t{solafoe.d} uses 15 strings from a translation file,
  \ttref{APPEND}s to \t{SOLA.DLG} and creates 
  \t{SOLAFOE.DLG}. You may use \t{--transin} to
  specify a translation file or (if it ends in \ttref{TRA}) just throw it
  on the command line. If you include multiple \ttref{TRA} files, the last
  one to define a particular string index wins for that string. They need
  not all cover the same set. Use \t{--tlkout} if there is new text involved. 
  
\item  Displaying String References

  \CMD{ weidu --string 123 --strfind understudy --strfind acid.*rows}
  \begin{verbatim}
        ...
  [C:\Program Files\Black Isle\BGII - SoA\chitin.key] 182 BIFFs, 41793 resources
  [C:\Program Files\Black Isle\BGII - SoA\DIALOG.TLK] 84458 string entries
  String #123 is ~Haer' Dalis, all of you, stop them!~
  String #6763 is ~Acid Arrows~
  String #11662 is ~Biff The Understudy~
        ...
        \end{verbatim}

  This displays string \#123 and all strings that contain the string
  "understudy" and all strings that match the regular expression
  (\ttref{regexp}) "acid.*rows". Note that case does not matter. 

\item  Updating \t{\t{DIALOG.}\ttref{TLK}} Manually

  \CMD{ weidu --strapp ANewString --tlkout happy.tlk}
  \begin{verbatim}
  [C:\Program Files\Black Isle\BGII - SoA\DIALOG.TLK] 84458 string entries
  [.\happy.tlk] created, 84459 string entries
  \end{verbatim}

  Not much to say here. String reference \#84459 in \t{happy.tlk} is now
  ``{\tt ANewString}''. 

\item  Listing \ttref{BIFF} Contents

  \CMD{ weidu --biff data/dialog.bif}
  \begin{verbatim}
        ...
  [data\Dialog.bif] contains    ABELA.DLG at index 0
  [data\Dialog.bif] contains    ACHEN.DLG at index 1
        ...
        \end{verbatim}

  This shows all of the resources (e.g., \t{ACHEN.DLG} is a resource) that
  are contained in \t{data/Dialog.bif}. 

\item  Extracting \ttref{BIFF} Contents

  \CMD{ weidu --biff-get dragred.cre }
  \begin{verbatim}
  [C:\Program Files\Black Isle\BGII - SoA\chitin.key] 182 BIFFs, 41793 resources
  [C:\Program Files\Black Isle\BGII - SoA\DIALOG.TLK] 84458 string entries
  [C:\Program Files\Black Isle\BGII - SoA\data\Creature.bif] 3194 file entries
  [.\dragred.cre] 1776 bytes, created from [C:\Program Files\Black Isle\BGII - SoA\data\Creature.bif]
  \end{verbatim}

  This grabs Firkraag's dragon-form \ttref{CRE} creature file from the game
  \ttref{BIFF}s and saves it in the current directory.

\item  Extracting \ttref{BIFF} Contents with Regular Expressions

  \CMD{weidu --biff-get sper.*itm}
  \begin{verbatim}
  [.\chitin.key] loaded, 590551 bytes
  [.\chitin.key] 182 BIFFs, 41793 resources
  [.\DIALOG.TLK] loaded, 10154904 bytes
  [.\DIALOG.TLK] 77666 string entries
  [.\data\Items.bif] loaded, 659688 bytes
  [.\data\Items.bif] 1990 file entries
  [.\SPER01.ITM] 266 bytes, created from [.\data\Items.bif]
  [.\SPER02.ITM] 314 bytes, created from [.\data\Items.bif]
  [.\SPER03.ITM] 362 bytes, created from [.\data\Items.bif]
  [.\SPER04.ITM] 322 bytes, created from [.\data\Items.bif]
  [.\SPER05.ITM] 266 bytes, created from [.\data\Items.bif]
  [.\SPER06.ITM] 266 bytes, created from [.\data\Items.bif]
  [.\SPER07.ITM] 554 bytes, created from [.\data\Items.bif]
  [.\SPER08.ITM] 314 bytes, created from [.\data\Items.bif]
  [.\SPER09.ITM] 314 bytes, created from [.\data\Items.bif]
  [.\SPER10.ITM] 362 bytes, created from [.\data\Items.bif]
  [.\data\25Items.bif] loaded, 222370 bytes
  [.\data\25Items.bif] 479 file entries
  [.\SPER11.ITM] 314 bytes, created from [.\data\25Items.bif]
  [.\SPER12.ITM] 1610 bytes, created from [.\data\25Items.bif]
  [.\SPERMEL.ITM] 890 bytes, created from [.\data\25Items.bif]
  \end{verbatim}

  This one assumes that the game is in the current directory and asks for
  every spear item in the game. Note that \t{--biff-get} uses regular
  expressions (\ttref{regexp}), not DOS-style wildcards. Note also that
  \t{--biff-get} does not look in the override directory. Finally, if
  you are using a Mac (or otherwise running unix) you'll want to put the
  regular expression in double quotes, like so: 
  \CMD{weidu --biff-get "sper.*itm"}

\item  Searching \ttref{BIFF} Contents

  \CMD{ weidu --biff-type CRE --biff-str SPWI911}
  \begin{verbatim}
        ...
  LICH01.CRE in [data\Creature.bif] matches
  HLKANG.CRE in [data\Creature.bif] matches
        ...
        \end{verbatim}

  This finds all \ttref{CRE} files that contain the string "SPWI911", which is
  equivalent to finding all enemy mages that know the spell Meteor Swarm
  (which has resource name "SPWI911"). You could also try something like:

  \CMD{ weidu --biff-type BCS --biff-str Terminsel}
  \begin{verbatim}
        ...
  AR0300.BCS in [data\Scripts.bif] matches
  AR0308.BCS in [data\Scripts.bif] matches
  JAHEIRA.BCS in [data\Scripts.bif] matches
        ...
        \end{verbatim}

  to find all of the game scripts that include a variable that includes the
  substring "Terminsel". As you would expect, Jaheira shows up. Note that
  these searches are moderately time-consuming (e.g., searching all scripts
  takes about 20 seconds). 

\item  Converting one \ttref{TLK} file to another

  \CMD{ weidu --tlkcmp-from DIALOG.TLK --tlkcmp-to dialog-asc.tlk }
  \begin{verbatim}
    ...
  [DIALOG.TLK] loaded, 8692747 bytes
  [DIALOG.TLK] 74107 string entries
  [dialog-asc.tlk] loaded, 10211578 bytes
  [dialog-asc.tlk] 82805 string entries
  WARNING: DIALOG.TLK has 74107 entries, dialog-asc.tlk has 82805 entries
          STRING_SET 70866 ~Babau~ []
          STRING_SET 70867 ~Babau~ []
          \end{verbatim}

This compares all strings in common between two \t{\t{DIALOG.}\ttref{TLK}} files and
generates a list of \ttref{STRING!SET} \ttref{TP2} entries to convert the
\ttref{TLK} file named in \t{--tlkcomp-from} into the \ttref{TLK} file named in
\t{--tlkcomp-to}.  In this case, WeiDU indicates there are two differences in
the strings shared between a standard ToB \ttref{TLK} file and an Ascension
Classic \ttref{TLK} file: strings 70866 and 70867 were changed to "Babau".
Also note that the Ascension Classic \ttref{TLK} file has more entries (82805
compared to 74107). 

If you have made a large number of manual changes to a \ttref{TLK} file
(such as grammar/spelling corrections, or other dialogue tweaks), this is a
handy way to generate install-ready scripting to apply those changes to an
end user's version of BG2.

Note that the use of \t{--out} will be helpful for a long list. 

  \CMD{ weidu --tlkcmp-from DIALOG.TLK --tlkcmp-to dialog-asc.tlk --out mylist.txt }

This will make a new \t{file mylist.txt} file that contains the
\ttref{STRING!SET} parts of the output, which can then be put into a
\ttref{TP2} file. 

\item  Automating File Descriptions

\CMD{weidu --automate MyMod/SomeFolder --append MyMod.tp2}

WeiDU's \t{--automate} feature can save you oodles of time, so you probably
will want to learn how to use it.  It's rather simple when you get the hang
of it (but everything is right?).

Suppose you have just created some items, some spells and some creatures
and some areas for you mod and you want to distribute them to others using
WeiDU.  You could manually write out string patching code by hand for each
resource. Or you can get WeiDU to do it automatically.  

WeiDU will scan every item, spell and creature inside the given folder (in
this example, the folder is \t{MyMod/SomeFolder}) and emit \ttref{TP2}
commands to \ttref{COPY} those resources from that folder into the
\t{override} folder. In addition, each resource's current strings (like
item descriptions and monster names) will be loaded from your \ttref{TLK}
file and used to patch that resource as it is copied.  

For example, the output of \t{--automate} on a folder that contains a
potion of extra healing looks like this:

\begin{verbatim}
COPY ~MyMod/SomeFolder/potn52.itm~  ~override/potn52.itm~         
  SAY NAME ~Potion~ 
  SAY NAME2 ~Potion of Extra Healing~ 
  SAY UNIDENTIFIED_DESC ~Potions are typically found in ceramic, crystal, glass,
    or metal flasks or vials.  Flasks or other containers generally contain 
    enough fluid to provide one person with one complete dose to achieve the 
    effects of the potion.~ 
  SAY DESC ~When wholly consumed, this potion restores 27 hit points to the 
    person. The effect is instantaneous and the potion is destroyed in the 
    process.~ 
  SAY 0xde ~Gulp!~ [GULP] 
\end{verbatim}

And there you have it, apparently there is a substitute for hard work.

\item  Converting Between \ttref{TLK} and \ttref{TRA} Files

Some translators who are using WeiDU to translate non-WeiDU mods find it
handy to be able to convert between \ttref{TLK} and \ttref{TRA} files. 

First, let's create a \ttref{TRA} file: 

  \CMD{ weidu --traify-tlk --min 2000 --max 2002 }
  \begin{verbatim}
        ...
  @2000  = ~Indeed! It's been quite tasty so far. Listen, we're not here to
  devour everything. In fact, we'd like to help a little girl named
  Jaella.~
  @2001  = ~No, we haven't. We will devour you if you don't tell us what we
  need to know.~
  @2002  = ~Let us stop this charade. I'm only here to ask you a few
  questions.~
        ...
        \end{verbatim}

You may also extract only those strings matching a \ttref{regexp}: 

  \CMD{ weidu --traify-tlk --strfind lawyer }
  \begin{verbatim}
        ...
  @36568 = ~Honor-bound and honor-branded, then, is it?  Very well, lawyer,
  you have set me free and for that I thank you.~
        ...
  \end{verbatim}

Finally, you may redirect the output to a file using {\tt --out} and
read from a different \ttref{TLK} file by adding it on the command line.

Once you have a \ttref{TRA} file with a few entries you can create a
\ttref{TLK} file from it: 

  \CMD{ weidu --make-tlk my.tra --tlkout new.tlk }
  \begin{verbatim}
  [c:\src\weidu\weidu.exe] WeiDU version 109
  [C:\Program Files\Black Isle\BGII - SoA/chitin.key] 182 BIFFs, 41793
  resources
  [C:\Program Files\Black Isle\BGII - SoA/dialog.tlk] 82405 string entries
  [my.tra] parsed
  [my.tra] has 100 translation strings
  New TLK will have 200 entries
  [new.tlk] created, 200 string entries
  \end{verbatim}

String {\tt @1} in your \ttref{TRA} file will become string reference {\tt
\#1} in the \ttref{TLK} file. If your \ttref{TRA} file has ``holes'' the new
\ttref{TLK} file will have blank entries. You may specify {\tt --make-tlk}
multiple times: the last \ttref{TRA} file to define a translation string
determine that string reference. 

\item Creating a \ttref{BIFF} File

This tutorial was thoughtfully provided by Japheth. 

Using \DEFSYN{--make-biff} is dead easy.  Here's a quick and dirty example:

Assuming WeiDU is in your BGII directory, grab a bunch of files from your
override folder and stick them into a folder inside your BGII directory.
We'll call the folder \t{mybiff} for this example.

Once the files are inside the folder, this is all you would have to do to
make WeiDU create a biff of the files:

  \CMD{ weidu --make-biff mybiff } 
  \begin{verbatim}
  [c:\src\weidu\weidu.exe] WeiDU version 122
  [./chitin.key] 182 BIFFs, 41793 resources
  [./dialog.tlk] 82479 string entries
  [data\mybiff.bif] will contain 20 resources totalling 211096 bytes
  [data\mybiff.bif] incorporating [mybiff/udsola02.cre]
          ...
  [data\mybiff.bif] incorporating [mybiff/sola10.cre]
  KEY saved (183 biffs, 41813 resources)
  \end{verbatim}

WeiDU will add the files into the \ttref{BIFF} \t{mybiff.bif} and stick
that file in your \t{data} directory.  It will also update the 
\t{CHITIN.}\ttref{KEY}.

Before using this feature, make sure you backup your
\t{CHITIN.}\ttref{KEY}.

\item Removing a \ttref{BIFF} File

You can use \DEFSYN{--remove-biff} to remove a \ttref{BIFF} file from
\t{CHITIN.}\ttref{KEY} and destructively replace it with a new, smaller
\t{CHITIN.}\ttref{KEY}. 
Before using this feature, make sure you backup your
\t{CHITIN.}\ttref{KEY}.
Do not use this feature. 

  \CMD{ weidu --make-biff mybiff data$\backslash$25ArMisc.bif } 
  \begin{verbatim}
  [c:\src\weidu\weidu.exe] WeiDU version 157
  [./chitin.key] 182 BIFFs, 41793 resources
  [./dialog.tlk] 83772 string entries
  Removing references to 16 resources in [data\25ArMisc.bif]
  KEY saved (181 biffs, 41777 resources)
  \end{verbatim}

Note that the specified \ttref{BIFF} is not deleted from your computer's
file system, it is merely removed from \t{CHITIN.}\ttref{KEY}. When
specifying the \ttref{BIFF} case does not matter but the folder separator,
usually ``$\backslash$'' or ``\t{:}'', does. Use \t{--list-biffs} to get
the official list of possible \ttref{BIFF}s to remove. Do not use this
feature. 

\item Viewing Banter Offline with \DEFSYN{--transitive}

\CMD{ weidu --nocom --text --transitive banomen.dlg }

The \t{--transitive} flag tells WeiDU to follow \ttref{EXTERN}
references when emitting \ttref{D} files. So the resulting \t{BANOMEN.D}
file has lines like this:

\begin{verbatim}
IF WEIGHT #31 ~InParty("Edwin")
See("Edwin")
Gender("Edwin",FEMALE)
!StateCheck("Edwin",STATE_SLEEPING)
Global("BAnomen1","LOCALS",0)~ THEN BEGIN 10
  SAY ~Hey, Edwina!  I shall be your champion at the next tournament that
  we come to if only you give me a piece of your robe, uh, that is, dress
  to adorn my shield.~ [ANOMEN49] 
  IF ~~ THEN DO ~SetGlobal("BAnomen1","LOCALS",1)~ EXTERN ~BEDWIN~ 104
END

IF ~~ THEN BEGIN BEDWIN 104
  SAY ~(My condition draws fools like flies to honey).  Silence, you idiot!
  You've a death wish that is larger than your swollen head.~ [EDWINW39]
  IF ~~ THEN GOTO 11
END

IF ~~ THEN BEGIN 11
  SAY ~Fair Edwina, I am truly bereft by your non-acceptance.  It is tragic
  when a knight has no fair maiden to moon over.  Heh he he...~
  IF ~~ THEN EXIT
END
\end{verbatim}

Note that both lines from both Edwin and Anomen are presented. The
resulting ``D'' file is not valid in that it cannot be fed back to WeiDU
directly, but it should make it easier for you to read all of the jokes
offline. 

Note that WeiDU may well go into an infinite loop when you use
\t{--transitive}. Sorry about that. 

\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{WeiDU Tutorials}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

This section includes tutorials on specific parts of WeiDU. Many of them
were contributed by users like you. 

\subsection{\t{Multisay}}
\label{Multisay}
This tutorial was thoughtfully provided by Jason Compton. 

Although a single \ttref{SAY} line can be of any length, for style purposes
(particularly in BG2) it is considered good form to break up very large
lines into smaller chunks.

One can easily create a series of simple \ttref{SAY} blocks, one doing
\ttref{GOTO} to the next, but if there are no special conditions being
checked or actions being taken, you can very easily string several lines
together.

Let's say you have a scenery NPC teaching a lesson about the Bill of Rights
to the US Constitution.
\begin{rawhtml}
<pre width="80"><font color="#3159D1">BEGIN</font> TEACHER

<font color="#3159D1">IF</font> <font color="#868626">~NumTimesTalkedTo(0)~</font> <font color="#3159D1">THEN</font> <font color="#3159D1">BEGIN</font> constitution_1
  <font color="#3159D1">SAY</font> <font color="#868626">~On September 25, 1789, the First Congress of the United States
    therefore proposed to the state legislatures 12 amendments to the
    Constitution that met arguments most frequently advanced against it. The
    first two proposed amendments, which concerned the number of constituents
    for each Representative and the compensation of Congressmen, were not
    ratified. Articles 3 to 12, however, ratified by three- fourths of the
    state legislatures, constitute the first 10 amendments of the
    Constitution, known as the Bill of Rights.~</font>
  <font color="#3159D1">IF</font> <font color="#868626">~~</font> <font color="#3159D1">THEN</font> <font color="#3159D1">EXIT</font>
<font color="#3159D1">END</font> </pre>
\end{rawhtml}
This is a perfectly valid block of dialogue, but it is extremely long, and
would likely scroll out of the text window for players with lower
resolution.

Rather than break each sentence up into a new explicit \ttref{state}, we
can use \ttref{Multisay} and save a lot of typing. \ttref{Multisay} is
invoked with the \t{=} (equals) sign, which tells WeiDU that, "the current
speaker should say another line here."

Here's how that \ttref{D} \ttref{state} would look with \ttref{Multisay}:
\begin{rawhtml}
<pre width="80"><font color="#3159D1">IF</font> <font color="#868626">~NumTimesTalkedTo(0)~</font> <font color="#3159D1">THEN</font> <font color="#3159D1">BEGIN</font> constitution_1
  <font color="#3159D1">SAY</font> <font color="#868626">~On September 25, 1789, the First Congress of the United States
  therefore proposed to the state legislatures 12 amendments to the
  Constitution that met arguments most frequently advanced against it.~</font>
      =
  <font color="#868626">~The first two proposed amendments, which concerned the number of
  constituents for each Representative and the compensation of Congressmen,
  were not ratified.~</font>
      =
  <font color="#868626">~Articles 3 to 12, however, ratified by three-fourths of the state
  legislatures, constitute the first 10 amendments of the Constitution,
  known as the Bill of Rights.~</font>
  <font color="#3159D1">IF</font> <font color="#868626">~~</font> <font color="#3159D1">THEN</font> <font color="#3159D1">EXIT</font>
<font color="#3159D1">END</font>
</pre>
\end{rawhtml}
This will create three dialogue \ttref{state}s, separated by simple "click
to continue" transitions.

And that's \ttref{Multisay} in a nutshell. Note that (as always with WeiDU)
the line break and spacing before and after the \t{=} are totally optional,
and used here only for illustration. 
\begin{rawhtml}
<pre width="80"><font color="#3159D1">SAY</font> <font color="#868626">~One~</font> = <font color="#868626">~Two~</font> = <font color="#868626">~Three~</font> </pre>
\end{rawhtml}
is perfectly valid as well.

You may \ttref{Multisay} inside almsot any \ttref{state}, so you may use it
within an \ttref{APPEND} \ttref{D Action}. This is valid:
\begin{rawhtml}
<pre><font color="#3159D1">APPEND</font> J#KLSYJ
  <font color="#3159D1">IF</font> <font color="#868626">~~</font> <font color="#3159D1">THEN</font> <font color="#3159D1">BEGIN</font> Renal1_1
    <font color="#3159D1">SAY</font> <font color="#868626">~All right, CHARNAME. I can accept that... you are right, there
    are bigger issues to consider.~</font> 
      = 
    <font color="#868626">~But I hope you do understand why I said something, why it would be
    upsetting to have someone so close to me, in a role like that.~</font>
    <font color="#3159D1">IF</font> <font color="#868626">~~</font> <font color="#3159D1">THEN</font> <font color="#3159D1">EXIT</font>
  <font color="#3159D1">END</font>                            <font color="#219121">// end of state Renal1_1
</font><font color="#3159D1">END</font>                             <font color="#219121">// end of APPEND J#KLSYJ
</font></pre>
\end{rawhtml}
However, you {\em cannot} use Multisay inside \ttref{REPLACE}, because the
nature of \ttref{REPLACE} is to change (that is, replace) a {\em single}
\ttref{state}, while \ttref{Multisay}'s nature is to create 
multiple \ttref{state}s. 

\subsection{\ttref{CHAIN}}
This tutorial was thoughtfully provided by Jason Compton. 

\ttref{CHAIN} is an extension of the Multisay concept, simply with multiple
participants. If you have two NPCs bantering back and forth for a prolonged
period of time, and you do not need to do any special condition checks or
actions as they babble, it can get very tedious to set up a separate
\t{IF}/\t{THEN}/\t{BEGIN}/\ttref{SAY} block for each line.

Imagine a conversation like this:

\begin{itemize}
\item Kelsey: Imoen, what do you like on your pizza?
\item Imoen: Oregano.
\item Imoen: Oh, and maybe with a little basil mixed in.
\item Kelsey: Well, yeah, but anything else?
\item Imoen: Sauce is good.
\item Kelsey: (laughs) You're not being very helpful, Imoen.
\item Imoen: Crust. I like crust on my pizza. Cooked crust is better.
\item Kelsey: Do you want me to make you this pizza or not?
\item Kelsey: It WAS your idea.
\item Imoen: I can't decide. Never mind, I'm just gonna have yogurt.
\item Kelsey: (sigh)
\end{itemize}

If you wanted to add this witty little banter to your game, you could do it
with 11 \ttref{APPEND} blocks for each line, or save a little time doubling
up the back-to-back Imoen and Kelsey lines with \ttref{Multisay} inside
their \ttref{APPEND}s, so you'd only need 9. In fact, you could get away
with 2 \ttref{APPEND} blocks (remember that the states don't have to appear
in the order they are spoken, so you could mention all of Kelsey's lines
first and then all of Immy's as long as the labels thread up the
conversation correctly), one with 5 \ttref{state} declarations and one 4. But
there's an {\em even better} way, and that's to use \ttref{CHAIN}. It works
very much like \ttref{Multisay}. You use \t{=} to indicate that the current
speaker should speak again, and \t{==} (that's two consecutive equal signs)
to indicate that a new speaker should take over.

Note that as of WeiDU 82, \ttref{CHAIN} can now define \ttref{state} triggers,
perform \ttref{DO} actions, and end with an \ttref{EXIT} or
\ttref{COPY!TRANS}. This means that for most simple NPC/NPC banters, where
the PC does not have an opportunity to speak, you no longer need to use
anything else. 

Watch and see how this dialogue works using a \ttref{CHAIN}.
\begin{rawhtml}
<pre width="80"><font color="#3159D1">CHAIN</font>
  <font color="#3159D1">IF</font> <font color="#868626">~Global("KelseyImoenPizza","LOCALS",0)
      InParty("Imoen2")
      See("Imoen2")
      !StateCheck("Imoen2",STATE_SLEEPING)~</font> <font color="#3159D1">THEN</font> BJKLSY pizzachain
  <font color="#868626">~Imoen, what do you like on your pizza?~</font>
<font color="#3159D1">DO</font> <font color="#868626">~SetGlobal("KelseyImoenPizza","LOCALS",1)~</font>
  == IMOEN2J
  <font color="#868626">~Oregano.~</font>
  =
  <font color="#868626">~Oh, and maybe with a little basil mixed in.~</font>
  == BJKLSY
  <font color="#868626">~Well, yeah, but anything else?~</font>
  == IMOEN2J
  <font color="#868626">~Sauce is good.~</font>
  == BJKLSY
  <font color="#868626">~(laughs) You're not being very helpful, Imoen.~</font>
  == IMOEN2J
  <font color="#868626">~Crust. I like crust on my pizza. Cooked crust is better.~</font>
  == BJKLSY
  <font color="#868626">~Do you want me to make you this pizza or not?~</font>
  =
  <font color="#868626">~It WAS your idea.~</font>
  == IMOEN2J
  <font color="#868626">~I can't decide. Never mind, I'm just gonna have yogurt.~</font>
  == BJKLSY
  <font color="#868626">~(sigh)~</font>
<font color="#3159D1">EXIT</font> </pre>
\end{rawhtml}
Note how this dialogue works.

We use the \ttref{CHAIN} statement to define the state trigger (the
starting conditions that must be true) and assign it to BJKLSY.DLG. The
"pizzachain" label is mostly just for internal reference. Kelsey delivers
the first line, then we use \t{==} \t{IMOEN2J} to allow her to answer,
"Oregano." Then, we can use the single = to indicate that the current
speaker (Imoen) has two consecutive lines.

Then it's Kelsey's turn to speak, so we use \t{== BJKLSY} to tell WeiDU to
tell WeiDU to switch to the {\em other} speaker (which is Kelsey, since we
specified \t{BJKLSY}.  They banter back and forth for a while, and then
when it is Kelsey's turn to have back-to-back lines \t{Do you want me to
make you this pizza or not?} and \t{It WAS your idea.}, we separate with a
single \t{=} to indicate that the current speaker (Kelsey) has two
consecutive lines.

After Kelsey's final, exasperated sigh, we use the \ttref{EXIT} command to
terminate the \ttref{CHAIN}, and exit the dialogue.

And that's all you need to know to use \ttref{CHAIN}. It saves a {\em
tremendous} amount of time over setting up individual \ttref{APPEND}
blocks, even \ttref{Multisay} blocks, for each NPC.

Advanced \ttref{CHAIN}ing:

You may include \ttref{DO} actions and conditionals inside
\ttref{chainText}, as in: 
\begin{rawhtml}
<pre width="80"><font color="#3159D1">CHAIN</font>
  <font color="#3159D1">IF</font> <font color="#868626">~Global("KelseyImoenPizza","LOCALS",0)
      InParty("Imoen2")
      See("Imoen2")
      !StateCheck("Imoen2",STATE_SLEEPING)~</font> <font color="#3159D1">THEN</font> BJKLSY pizzachain
  <font color="#868626">~Imoen, what do you like on your pizza?~</font>
<font color="#3159D1">DO</font> <font color="#868626">~SetGlobal("KelseyImoenPizza","LOCALS",1)~</font>
  == IMOEN2J
    <font color="#868626">~Oregano.~</font>
    =
    <font color="#868626">~Oh, and maybe with a little basil mixed in.~</font>

  == BJKLSY
    <font color="#868626">~Well, yeah, but anything else?~</font>

  == IMOEN2J
    <font color="#868626">~Sauce is good.~</font>

    == BJKLSY   <font color="#3159D1">IF</font> <font color="#868626">~PartyHasItem("pepperoni")~</font> <font color="#3159D1">THEN</font>
      <font color="#868626">~Look, we HAVE pepperoni. Why don't I just use that? I'll eat it,
      anyway. If you don't like it, have yogurt instead.~</font>

    == IMOEN2J  <font color="#3159D1">IF</font> <font color="#868626">~!PartyHasItem("pepperoni")~</font> <font color="#3159D1">THEN</font>
      <font color="#868626">~Crust. I like crust on my pizza. Cooked crust is better.~</font>
    == BJKLSY <font color="#3159D1">IF</font> <font color="#868626">~!PartyHasItem("pepperoni")~</font> <font color="#3159D1">THEN</font>
      <font color="#868626">~Do you want me to make you this pizza or not?~</font>
      =
      <font color="#868626">~It WAS your idea.~</font>

    == IMOEN2J  <font color="#3159D1">IF</font> <font color="#868626">~!PartyHasItem("pepperoni")~</font> <font color="#3159D1">THEN</font>
      <font color="#868626">~I can't decide. Never mind, I'm just gonna have yogurt.~</font>
    == BJKLSY <font color="#3159D1">IF</font> <font color="#868626">~!PartyHasItem("pepperoni")~</font> <font color="#3159D1">THEN</font>
      <font color="#868626">~(sigh)~</font>
<font color="#3159D1">EXIT</font></pre>
\end{rawhtml}
In this case, the dialogue changes if the party has the pepperoni item. If
it does, Kelsey says the \t{we HAVE pepperoni} and then \t{(sigh)} and then
the dialogue ends. If not, the dialogue works as before. The
\ttref{chainText} lines with \t{IF}s in them are only spoken if their
conditionals are true. 

\subsection{\ttref{COPY!TRANS}}

This tutorial was thoughtfully provided by Jason Compton. 

There are some complex branching dialogues in Infinity Engine games that
you, as a mod creator, may wish to add to. Consider Baldur's Gate 2 and the
"Arrival In Hell" dialogue. There is a brief internal dialogue as the
protagonist comes to terms with the fact that he/she is now in Hell, and
then all of the companions coded by Bioware have a chance to speak.
(\t{PLAYER1.DLG} state 25. It will help the rest of this explanation if you
go use WeiDU to decompile \t{PLAYER1.DLG} into \t{PLAYER1.d}, and/or open
up \t{PLAYER1.DLG} in Near Infinity and look at state 25.)

After the PC's internal voice says \t{You doubt they will be pleased with
their present circumstance, when you don't even know why you are here
yourself.}, every Bioware NPC has the opportunity to speak. If you are
creating a new NPC and want it to have that full, rich Bioware flavor, you
may wish to let your character speak here as well. For that, a simple
\ttref{EXTEND!BOTTOM} will do the job.

Here's the example of how Weimer does this with Solaufein:
\begin{rawhtml}
<pre width="80"><font color="#3159D1">EXTEND_BOTTOM</font> PLAYER1 <font color="#0000FF">25</font>
  <font color="#3159D1">IF</font> <font color="#868626">~IsValidForPartyDialogue("Sola")
      Global("SolaWelcomeHell","GLOBAL",0)~</font> <font color="#3159D1">THEN</font>
    <font color="#3159D1">DO</font> <font color="#868626">~SetGlobal("SolaWelcomeHell","GLOBAL",1)~</font> <font color="#3159D1">EXTERN</font> SOLA inHell1
<font color="#3159D1">END</font></pre>
\end{rawhtml}
This puts a new transition at the bottom of \t{PLAYER1 25} that tells the
game to branch to Solaufein's observation about your arrival in Hell, if he
is present (\t{IsValid}) and if we have not already seen his comment once
before (the check for \t{SolaWelcomeHell}=0, then setting it to 1. This
ensures that this path can only happen once, which is important for a
reason I will explain later.) \t{SOLA inHell1}, which we will define later,
contains Solaufein's comment.

Once Solaufein makes his comment, it would be very thoughtful of us to
allow the other Bioware NPCs to have their say as well, as Bioware intended
and as the experienced players out there expect. You {\em could} simply use the
decompiled \t{PLAYER1.D} and copy and paste the transition list out. But
there are some good reasons not to do that. On a trivial level, it's a big
waste of space in your \ttref{D} file.

The most important reason is this: If {\em another} mod NPC has come along
and done their {\em own} \ttref{EXTEND!BOTTOM}, you would have no way of
knowing that. By putting the Bioware stock transition list in, you would
ensure that {\em only} your mod NPC got to have their say. The rest would be
silent. So if you were the developer of Solaufein, and Solaufein were
installed after Kelsey and Tashia in a game, Kelsey and Tashia would be
skipped, because {\em you} only copied the Bioware transition list. That's a
heavy responsibility.

That's why \ttref{COPY!TRANS} exists. \ttref{COPY!TRANS} pulls the entire
transition list from a specified state and makes it the transition list for
{\em your} new state.

To illustrate, look at \t{SOLA inHell1} :
\begin{rawhtml}
<pre><font color="#3159D1">APPEND</font> SOLA
  <font color="#3159D1">IF</font> <font color="#868626">~~</font> <font color="#3159D1">THEN</font> <font color="#3159D1">BEGIN</font> inHell1
    <font color="#3159D1">SAY</font> @<font color="#0000FF">2</font> = @<font color="#0000FF">3</font>         <font color="#219121">// use strings @2 and @3 from translation file
</font>    <font color="#3159D1">COPY_TRANS</font> PLAYER1 <font color="#0000FF">25</font>
  <font color="#3159D1">END</font>
<font color="#3159D1">END</font> </pre>
\end{rawhtml}
Instead of copying and pasting that huge list of \t{IF "" THEN EXTERN}
transitions from the \t{PLAYER1.D}, we let WeiDU do it for us.
\ttref{COPY!TRANS} \t{PLAYER1 25} tells WeiDU to grab the current list of
\ttref{transition}s from \t{PLAYER1} \ttref{state} 25, and use it as the
\ttref{transition} list for \t{SOLA inHell1}. This ensures that Solaufein
will be able to properly branch out to Imoen, Aerie, Minsc, and the rest of
the gang, {\em as well as} grabbing the transitions that may have been
added by other NPCs such as Kelsey, Valen, or Tashia.

\ttref{COPY!TRANS} can form all of your new \ttref{state}'s
\ttref{transition} list, or only part of it.  This would be valid, for
example:
\begin{rawhtml}
<pre width="80"><font color="#3159D1">IF</font> <font color="#868626">~~</font> <font color="#3159D1">THEN</font> <font color="#3159D1">BEGIN</font> commentary
  <font color="#3159D1">SAY</font> <font color="#868626">~Hey, I think I might like to run the transition list from TOLGER
    75... or I might want to do something else, if I'm in chapter six!~</font>
  <font color="#3159D1">COPY_TRANS</font> TOLGER <font color="#0000FF">75</font>
  <font color="#3159D1">IF</font> <font color="#868626">~Global("Chapter","GLOBAL",6)~</font> <font color="#3159D1">THEN</font> <font color="#3159D1">GOTO</font> chapter6commentary
<font color="#3159D1">END</font></pre>
\end{rawhtml}
This would make the \ttref{GOTO} \t{commentary2} transition show up at the
bottom of the transition stack (below the list copied from \t{TOLGER 75}).
Remember that transition triggers are read {\em bottom to top}, so it would
be the first transition evaluated. If you want it to be evaluated {\em
after} the list of transitions in the \ttref{COPY!TRANS}, put it above.
Note, however, that Bioware usually structures its transition lists so that
the topmost trigger will always be true (in fact, sometimes it {\em is}
\t{"True()"}) so it is somewhat unlikely you would ever want to put a new
transition trigger {\em above} the \ttref{COPY!TRANS}.

Now, that explanation for why the \t{SolaWelcomeHell} variable check is
important: if a user accidentally installs the same mod more than once, and
it employs \ttref{COPY!TRANS}, the list the second time around will {\em
include} our new trigger:
\begin{rawhtml}
<pre><font color="#3159D1">IF</font> <font color="#868626">~IsValidForPartyDialogue("Sola")
      Global("SolaWelcomeHell","GLOBAL",0)~</font> <font color="#3159D1">THEN</font>
    <font color="#3159D1">DO</font> <font color="#868626">~SetGlobal("SolaWelcomeHell","GLOBAL",1)~</font> <font color="#3159D1">EXTERN</font> SOLA inHell1
</pre>
\end{rawhtml}
If there was no flag being set to ensure that the \ttref{transition} could
only run once, the user would get stuck in a loop. This can and has
happened with mods in the wild. The end result would be Solaufein or Kelsey
or whomever constantly offering their commentary, over and over again.

Important note: The WeiDU \ttref{D} compiler runs \ttref{COPY!TRANS} {\em
before} other actions that you might take to affect a transition list
within the same \ttref{D} file (like \ttref{EXTEND!TOP} and
\ttref{EXTEND!BOTTOM}).  This is a good thing.

\subsection{\ttref{INTERJECT}}
This tutorial was thoughtfully provided by Jason Compton. 

Interjections, the little comments party members make, are a great way to
spice up a new NPC or a new quest you create. It shows that the characters
are paying attention to their game world, and that they have an opinion
about what goes on around them.

Through interjections, an NPC can advise a course of action, complain about
a decision, force your hand... fun things.

The traditional way to do an interjection is to find a state of a dialogue
where another NPC might comment, and use \ttref{EXTEND!BOTTOM} and 
\ttref{APPEND} in conjunction.

Here's an old-school example:
\begin{rawhtml}
<pre width="80"><font color="#3159D1">EXTEND_BOTTOM</font> SAHPR4 <font color="#0000FF">7</font>
     <font color="#3159D1">IF</font> <font color="#868626">~IsValidForPartyDialog("J#Kelsey")~</font> <font color="#3159D1">THEN</font> <font color="#3159D1">EXTERN</font> J#KLSYJ KelseySAHPR4
<font color="#3159D1">END</font>

<font color="#3159D1">APPEND</font> J#KLSYJ
  <font color="#3159D1">IF</font> <font color="#868626">~~</font> <font color="#3159D1">THEN</font> <font color="#3159D1">BEGIN</font> KelseySAHPR4
    <font color="#3159D1">SAY</font> <font color="#868626">~Urk. Who was the lucky donor?~</font>
    <font color="#3159D1">IF</font> <font color="#868626">~~</font> <font color="#3159D1">THEN</font> <font color="#3159D1">EXTERN</font> SAHPR2 <font color="#0000FF">10</font>
  <font color="#3159D1">END</font>
<font color="#3159D1">END</font></pre>
\end{rawhtml}
This works, but it's also more work than it needs to be since the
introduction of \ttref{INTERJECT}. (Incidentally, for you WeiDU historians out
there, there are two main reasons advanced functions have been added to
WeiDU since the first versions of Solaufein and the original \ttref{CHAIN}
command: Either Weimer needed them for his own modding goals, or a mod
project, usually Kelsey, requested it. \ttref{INTERJECT} came about when
Westley finally decided that Solaufein and Valen should comment about
quests. On the other hand, \ttref{COPY!TRANS} and 
\ttref{INTERJECT!COPY!TRANS} were my idea.)

\ttref{INTERJECT} simplifies this process considerably. To run an 
\ttref{INTERJECT}, you
need to know the source state (the line after which you want one or more
NPCs to interject), and the destination state (where you want the dialogue
tree to go after the interjection.) Typically, but not necessarily, the
destination state will be wherever the dialogue was {\em originally}
planning to go, but if the NPC takes the conversation in a new direction,
that may change. We'll stick with the simpler cases for illustration.

\ttref{INTERJECT} is a specialized form of \ttref{CHAIN}.
So if you're familiar with \ttref{CHAIN}, this will look familiar.

Consider the dryads in the Irenicus start dungeon. Perhaps Minsc should say
something to them. \t{IDRYAD1.DLG} state 1 offers a good opportunity.
\begin{rawhtml}
<pre><font color="#3159D1">IF</font> <font color="#868626">~~</font> <font color="#3159D1">THEN</font> <font color="#3159D1">BEGIN</font> <font color="#0000FF">1</font> <font color="#219121">// from:
</font>  <font color="#3159D1">SAY</font> <font color="#0000FF">#11080</font> <font color="#219121">/* ~We are his possessions.~ */</font>
  <font color="#3159D1">IF</font> <font color="#868626">~~</font> <font color="#3159D1">THEN</font> <font color="#3159D1">EXTERN</font> <font color="#868626">~IDRYAD2~</font> <font color="#0000FF">1</font>
<font color="#3159D1">END</font></pre>
\end{rawhtml}
Minsc is outraged. Here's how he can express it. The idea is that we want
Minsc to comment, but for the dialogue to continue just as it would have if
he was not there.
\begin{rawhtml}
<pre><font color="#3159D1">INTERJECT</font> IDRYAD1 <font color="#0000FF">1</font> MinscDryad
  == MINSCJ <font color="#3159D1">IF</font> <font color="#868626">~IsValidForPartyDialog("Minsc")~</font> <font color="#3159D1">THEN</font>
    <font color="#868626">~Boo is outraged that the strange wizard would own these lovely ladies!
    Can Minsc and Boo help you nice girls?~</font>
<font color="#3159D1">END</font> IDRYAD2 <font color="#0000FF">1</font></pre>
\end{rawhtml}
Here's what's going on here.

Invoking \ttref{INTERJECT} requires three arguments: the dialogue name and
state we're interjecting into, plus a unique global variable name. This
variable will be set from 0 to 1 after the \ttref{INTERJECT} runs, to
ensure that it can only happen once.  (This is important in case players
accidentally install your mod twice, as it could create a looping problem
similar to the one described in \ttref{COPY!TRANS}.)

So \ttref{INTERJECT} \t{IDRYAD1 1 MinscDryad} tells WeiDU "Put this
dialogue after \t{IDRYAD1} \ttref{state} \t{1}. This dialogue will run if
\t{MinscDryad} is 0. After it runs, we will set \t{MinscDryad} to 1."

Then we need to define who is speaking. == (that's two consecutive equal
signs) is \ttref{CHAIN}-style notation for a new speaker, and \t{MINSCJ} is
the proper dialogue to use for Minsc's "joined-party" commentary. If Minsc
is in the party and valid for dialogue, he will say his line. After that,
we transition to \t{IDRYAD2} state \t{1} (\t{END IDRYAD2 1}), which is
where the dialogue was heading in the first place. We can make this more
complicated and let the dryad reply to his interruption before proceeding.
\begin{rawhtml}
<pre><font color="#3159D1">INTERJECT</font> IDRYAD1 <font color="#0000FF">1</font> MinscDryad
  == MINSCJ     <font color="#3159D1">IF</font> <font color="#868626">~IsValidForPartyDialog("Minsc")~</font> <font color="#3159D1">THEN</font>
    <font color="#868626">~Boo is outraged that the strange wizard would own these lovely ladies!
    Can Minsc and Boo help you nice girls?~</font>
  == IDRYAD1    <font color="#3159D1">IF</font> <font color="#868626">~IsValidForPartyDialog("Minsc")~</font> <font color="#3159D1">THEN</font>
    <font color="#868626">~Large mortal, we are having a dramatic scene. Please do not
    interrupt.~</font>
<font color="#3159D1">END</font> IDRYAD2 <font color="#0000FF">1</font></pre>
\end{rawhtml}
Note that we repeat the 
\begin{rawhtml}
<pre><font color="#3159D1">IF</font> <font color="#868626">~IsValidForPartyDialog("Minsc")~</font> <font color="#3159D1">THEN</font></pre>
\end{rawhtml}
check for \t{IDRYAD1}. That is to ensure that she only says that line if
Minsc is there, and by extension has already made his little comment. So
now, Minsc interrupts, Dryad \#1 scolds him, and then we proceed to the
second dryad's line.

One general piece of advice: while it's not {\em necessary} to pick a state
that has only a single transition to another state, unless you're willing
to experiment (or you're intentionally trying to remove player choices from
the equation, by making the NPC say something that forces immediate action,
for instance), don't \ttref{INTERJECT} into a state that has player options
(\ttref{REPLY}s).

\subsection{\DEFINE{INTERJECT!COPY!TRANS}}
This tutorial was thoughtfully provided by Jason Compton. 

\ttref{INTERJECT} is good for creating interjections where none already
exist.  However, many of the really good opportunities for interjections in
game dialogue already {\em have} interjections in them. If you use standard
\ttref{INTERJECT}, chances are you'll skip right over them.

Consider \t{TOLGER.DLG} \ttref{state} \t{75}. After Tolgerias lays down the
law by saying \t{This is a sensitive matter, and I cannot tell all to every
curious soul.  I must have your commitment that you agree to the task,}
four NPCs (Edwin, Jaheira, Yoshimo, Korgan) will tell you what they think
of {\em that} rotten arrangement. What's more, Bioware structured the dialogue
transitions so that they {\em all} can get their comment in, if all four of
them are in the party.

However, using a standard \ttref{INTERJECT} for a new NPC line would skip
over those four comments, which is rather impolite.
\ttref{INTERJECT!COPY!TRANS} works much like regular \ttref{INTERJECT}, but
instead of defining a state to transition to after \t{END}, WeiDU will
\ttref{COPY!TRANS} the transition list from the state you are
\ttref{INTERJECT}ing into.

This is not as confusing as it sounds. Watch as hypothetical new NPC
Aqualung responds to Tolgerias's terms:
\begin{rawhtml}
<pre width="80"><font color="#3159D1">INTERJECT_COPY_TRANS</font> TOLGER <font color="#0000FF">75</font> AquaTolger
  == AQUALUNJ   <font color="#3159D1">IF</font> <font color="#868626">~IsValidForPartyDialogue("Aqualung")~</font> <font color="#3159D1">THEN</font>
    <font color="#868626">~Hey, that's a really crummy offer! Where did those little girls go? I
    could be sitting on a park bench, I don't need this aggravation! Who
    are you, anyway?~</font>
  == TOLGER     <font color="#3159D1">IF</font> <font color="#868626">~IsValidForPartyDialogue("Aqualung")~</font> <font color="#3159D1">THEN</font>
    <font color="#868626">~You poor old sod, you see it's only me. Now, did anyone else have a
    smart remark they wanted to make?~</font>
<font color="#3159D1">END</font></pre>
\end{rawhtml}
So, if Aqualung is around, we'll hear from him and then Tolgerias will
respond to him. {\em After that}, the game will look for the presence of
Edwin, Jaheira, Yoshimo, and Korgan and we'll get {\em their} responses to
Tolgerias as well.

Hint: \ttref{INTERJECT!COPY!TRANS} is fine to use even if there were no other
interjections in the source state, i.e. if there's just a single \t{IF "" THEN
GOTO blah}. That is, as long as you plan to proceed to the original
destination. It saves you the trouble of having to look up and input the
destination.

\subsection{\DEFINE{INTERJECT!COPY!TRANS2}}
This tutorial was thoughtfully provided by Rastor. 

There seems to be a great deal of confusion among the members of the modding
community regarding the purpose and overall function of
\ttref{INTERJECT!COPY!TRANS2}.  Allow me to take a moment to dispel the rumors
that you may have heard.

\ttref{INTERJECT!COPY!TRANS2} is not intended as a replacement for
\ttref{INTERJECT!COPY!TRANS}.  \ttref{INTERJECT!COPY!TRANS} is a great function
but it has a flaw in certain special cases.  That's what
\ttref{INTERJECT!COPY!TRANS2} is intended to remedy.  This difference between
the two is best illustrated with an example.

Let us suppose that you want to add an NPC response to \t{PPSAEM2} 8.  Here is
some of what that state looks like before any mods have been applied: 

\begin{verbatim}
IF ~~ THEN BEGIN 8 // from: 7.0
  SAY #44931 /* ~Blah blah blah~ */
  IF ~!IsValidForPartyDialog("Jaheira")
!IsValidForPartyDialog("Anomen")
!IsValidForPartyDialog("Edwin")
IsValidForPartyDialog("Viconia")~ THEN DO ~SetGlobal("WackoArmy","GLOBAL",1)
OpenDoor("DOOR12")
EscapeArea()~ UNSOLVED_JOURNAL #7045 EXTERN ~VICONIJ~ 129
END
\end{verbatim}

Note that the \ttref{DO} actions include \t{EscapeArea()}. If you use
\ttref{INTERJECT!COPY!TRANS} to add an interjection here, the \ttref{DO}
actions will be performed by your interjector (usually a party member). The
result is that after encountering this dialogue in the game the party member
will leave the area (and Saemon will stay where he is!) promptly after
performing the interjection. Instead, we want to keep the \ttref{DO} action
associated with Saemon. 

\ttref{INTERJECT!COPY!TRANS2} allows modders to remedy this problem.
\ttref{INTERJECT!COPY!TRANS2} does exactly the same thing as
\ttref{INTERJECT!COPY!TRANS} except that DO actions will be kept with their
original actor and not transferred to the interjector. 

To code your interjection using \ttref{INTERJECT!COPY!TRANS2}, you would do
this:

\begin{verbatim}
INTERJECT_COPY_TRANS2 PPSAEM2 8
  ~Blah blah blah~
END
\end{verbatim}

The dialogue state that WeiDU will create from this
\ttref{INTERJECT!COPY!TRANS2} statement looks something like:

\begin{verbatim}
IF ~~ THEN BEGIN 133 // from:
  SAY #78199 /* ~Blah blah blah~ */
  IF ~!IsValidForPartyDialog("Jaheira")
!IsValidForPartyDialog("Anomen")
!IsValidForPartyDialog("Edwin")
IsValidForPartyDialog("Viconia")~ THEN UNSOLVED_JOURNAL #7045 EXTERN ~VICONIJ~ 129
END
\end{verbatim}

Note that \ttref{INTERJECT!COPY!TRANS2} is not intended as a universal
replacement for \ttref{INTERJECT!COPY!TRANS}.  This is most obvious when using
the command to interject into a state that starts a cutscene.  Here is an
example of an interjection into \t{PPIRENI2} 27.

The original, unmodded state:

\begin{verbatim}
IF ~~ THEN BEGIN 27 // from: 28.0 26.0
  SAY #44869 /* ~I bid you farewell, child of Bhaal. We shall not meet again.~
[IRENIC52] */
  IF ~~ THEN DO ~EraseJournalEntry(7252)
EraseJournalEntry(7253)
EraseJournalEntry(22952)
EraseJournalEntry(23306)
SetGlobal("AsylumPlot","GLOBAL",40)
StartCutSceneMode()
StartCutScene("Cut41j")~ SOLVED_JOURNAL #7255 EXIT
END
\end{verbatim}

Using \ttref{INTERJECT!COPY!TRANS2} to code your interjection into this state
will cause the game to crash when your interjection plays (because the special
\t{StartCutSceneMode()} action cannot occur in the middle of a dialogue,
loosely).  \ttref{INTERJECT!COPY!TRANS} will work properly, however.


\subsection{\ttref{state} \ttref{WEIGHT}s}

\ttref{stateTriggerString}s, the conditions that determine what
\ttref{state} should be used for the beginning of a dialogue, may have
\ttref{WEIGHT}s. These \ttref{WEIGHT}s are used by the Infinity Engine to
choose which state to pick if multiple state triggers evaluate to "true". [
In reality, the \ttref{WEIGHT}s are just the offsets within the state
trigger table in the \t{DLG} file, but this detail is not important unless
you are writing your own tool. ] \ttref{WEIGHT}s only make sense for
\ttref{stateTriggerString}s that are not empty. 

If multiple \ttref{stateTriggerString}s evaluate to true, the Infinity
Engine will pick the \ttref{state} with the {\em lowest} \ttref{WEIGHT}.
Usually the weighting follows the order of state declaration in the
\ttref{D} file.  That is, the first \ttref{state} mentioned has the lowest
weight (i.e., will be picked first in case of a tie) and the last state
mentioned has the highest weight (i.e., will be picked last in case of a
tie). However, you may include an explicit \ttref{WEIGHT} directive to
change things around. For example, consider this \ttref{D} file:
\begin{rawhtml}
<pre width="80"><font color="#3159D1">BEGIN</font> foozle
  <font color="#3159D1">IF</font> <font color="#868626">~True()~</font> <font color="#3159D1">THEN</font> <font color="#3159D1">BEGIN</font> a <font color="#3159D1">SAY</font> <font color="#868626">~Jason~</font> <font color="#3159D1">END</font>
  <font color="#3159D1">IF</font> <font color="#868626">~True()~</font> <font color="#3159D1">THEN</font> <font color="#3159D1">BEGIN</font> b <font color="#3159D1">SAY</font> <font color="#868626">~yada~</font> <font color="#3159D1">END</font>
  <font color="#3159D1">IF</font> <font color="#868626">~True()~</font> <font color="#3159D1">THEN</font> <font color="#3159D1">BEGIN</font> c <font color="#3159D1">SAY</font> <font color="#868626">~Compton~</font> <font color="#3159D1">END</font>
  <font color="#3159D1">IF</font> <font color="#868626">~True()~</font> <font color="#3159D1">THEN</font> <font color="#3159D1">BEGIN</font> d <font color="#3159D1">SAY</font> <font color="#868626">~kelsey~</font> <font color="#3159D1">END</font></pre>
\end{rawhtml}
If you talk to \t{foozle}, it will always say \t{Jason}. However, you may
explicitly alter the weights so that the third state is picked first, as
in: 
\begin{rawhtml}
<pre><font color="#3159D1">BEGIN</font> foozle
  <font color="#3159D1">IF</font> <font color="#3159D1">WEIGHT</font> <font color="#0000FF">#10</font> <font color="#868626">~True()~</font> <font color="#3159D1">THEN</font> <font color="#3159D1">BEGIN</font> a <font color="#3159D1">SAY</font> <font color="#868626">~Jason~</font> <font color="#3159D1">END</font>
  <font color="#3159D1">IF</font>            <font color="#868626">~True()~</font> <font color="#3159D1">THEN</font> <font color="#3159D1">BEGIN</font> b <font color="#3159D1">SAY</font> <font color="#868626">~yada~</font> <font color="#3159D1">END</font>
  <font color="#3159D1">IF</font> <font color="#3159D1">WEIGHT</font> <font color="#0000FF">#2</font>  <font color="#868626">~True()~</font> <font color="#3159D1">THEN</font> <font color="#3159D1">BEGIN</font> c <font color="#3159D1">SAY</font> <font color="#868626">~Compton~</font> <font color="#3159D1">END</font>
  <font color="#3159D1">IF</font>            <font color="#868626">~True()~</font> <font color="#3159D1">THEN</font> <font color="#3159D1">BEGIN</font> d <font color="#3159D1">SAY</font> <font color="#868626">~kelsey~</font> <font color="#3159D1">END</font></pre>
\end{rawhtml}
With this \ttref{D} file, foozle will always say \t{Compton}. All
\ttref{state}s with \ttref{WEIGHT} directives come before all states
without them. States without \ttref{WEIGHT} directives are ranked in order
of appearance. So the state order for \t{foozle.}\ttref{DLG} is \t{c-a-b-d}. Yes, this is
complicated. 

{\em Strong Style Suggestion}: do {\em not} use the \ttref{WEIGHT}
directive in your hand-made \ttref{D} files. Just use the implicit ordering. 

The \ttref{WEIGHT} directive was introduced to facilitate handling of
Bioware-created \ttref{DLG} files (e.g., \t{BJAHEIR.DLG}) that include
tricky weighting. Only states with non-empty triggers are given implicit
weights.  If you create a \ttref{D} file from a \ttref{DLG} that features
non-trivial weighting, WeiDU will emit comments like this: 
\begin{rawhtml}
<pre><font color="#3159D1">IF</font> <font color="#3159D1">WEIGHT</font> <font color="#0000FF">#8</font> <font color="#219121">/* Triggers after states #: 11 12 24 25 26 36 58 even though
                they appear after this state */</font>
  <font color="#868626">~True()~</font> <font color="#3159D1">THEN</font> <font color="#3159D1">BEGIN</font> <font color="#0000FF">10</font> <font color="#219121">// from:
</font>    <font color="#3159D1">SAY</font> <font color="#0000FF">#52190</font> <font color="#219121">/* ~Please do not interrupt our thoughts. We must prepare
      carefully if we are to see a weakness in the illithid web. ~ */</font>
    <font color="#3159D1">IF</font> <font color="#868626">~~</font> <font color="#3159D1">THEN</font> <font color="#3159D1">EXIT</font>
<font color="#3159D1">END</font></pre>
\end{rawhtml}
to remind you that the order is not what you think. 

All non-empty state triggers in \ttref{DLG} files are given weights
counting up from 0 to the maximum number of state triggers in the
\ttref{DLG} file.  You may use any number you like (even a negative one):
WeiDU will simply sort them. \ttref{ADD!STATE!TRIGGER}does not change the
weight associated with that trigger. \ttref{APPEND} can be used to give a
non-trivial weight to a state, as in:
\begin{rawhtml}
<pre><font color="#3159D1">APPEND</font> BJAHEIR
  <font color="#3159D1">IF</font> <font color="#3159D1">WEIGHT</font> <font color="#0000FF">#-999</font> <font color="#868626">~MyCondition()~</font> <font color="#3159D1">THEN</font> <font color="#3159D1">BEGIN</font> mystate <font color="#3159D1">SAY</font> <font color="#868626">~My Stuff~</font> <font color="#3159D1">END</font>
<font color="#3159D1">END</font></pre>
\end{rawhtml}
Since \t{BJAHEIR} will have implicit \ttref{WEIGHT}s in the range from \#0 to
about \#50, this causes \t{mystate} to have priority over all states that
already exist in \t{BJAHEIR}. Without such drastic action, 
\ttref{APPEND}ed states will
have use the implicit ordering, and will thus have the lowest priority
(because they appear at the end of the file). \ttref{Multisay} and 
\ttref{CHAIN} also
append states, but since they always append states with empty 
\ttref{stateTriggerString}s, \ttref{WEIGHT}s are not relevant. 

Consider the following example:
\begin{rawhtml}
<pre><font color="#3159D1">BEGIN</font> foozle
  <font color="#3159D1">IF</font> <font color="#3159D1">WEIGHT</font> <font color="#0000FF">#10</font> <font color="#868626">~True()~</font> <font color="#3159D1">THEN</font> <font color="#3159D1">BEGIN</font> a <font color="#3159D1">SAY</font> <font color="#868626">~Jason~</font> <font color="#3159D1">END</font>
  <font color="#3159D1">IF</font>            <font color="#868626">~~</font> <font color="#3159D1">THEN</font> <font color="#3159D1">BEGIN</font> b <font color="#3159D1">SAY</font> <font color="#868626">~yada~</font> <font color="#3159D1">END</font>
  <font color="#3159D1">IF</font> <font color="#3159D1">WEIGHT</font> <font color="#0000FF">#2</font>  <font color="#868626">~True()~</font> <font color="#3159D1">THEN</font> <font color="#3159D1">BEGIN</font> c <font color="#3159D1">SAY</font> <font color="#868626">~Compton~</font> <font color="#3159D1">END</font>
  <font color="#3159D1">IF</font>            <font color="#868626">~True()~</font> <font color="#3159D1">THEN</font> <font color="#3159D1">BEGIN</font> d <font color="#3159D1">SAY</font> <font color="#868626">~kelsey~</font> <font color="#3159D1">END</font>
  <font color="#3159D1">ADD_STATE_TRIGGER</font> foozle <font color="#0000FF">1</font> <font color="#219121">/* state b */</font> <font color="#868626">~MyCondition()~</font></pre>
\end{rawhtml}
The resulting \t{foozle} dialogue will still have the \t{c-a-b-d} weighting
order. 

Here's another example:
\begin{rawhtml}
<pre><font color="#3159D1">BEGIN</font> foozle
  <font color="#3159D1">IF</font>            <font color="#868626">~True()~</font> <font color="#3159D1">THEN</font> <font color="#3159D1">BEGIN</font> a <font color="#3159D1">SAY</font> <font color="#868626">~Jason~</font> <font color="#3159D1">END</font>
  <font color="#3159D1">IF</font>            <font color="#868626">~~</font> <font color="#3159D1">THEN</font> <font color="#3159D1">BEGIN</font> b <font color="#3159D1">SAY</font> <font color="#868626">~yada~</font> <font color="#3159D1">END</font>
  <font color="#3159D1">IF</font>            <font color="#868626">~True()~</font> <font color="#3159D1">THEN</font> <font color="#3159D1">BEGIN</font> c <font color="#3159D1">SAY</font> <font color="#868626">~Compton~</font> <font color="#3159D1">END</font>
  <font color="#3159D1">IF</font>            <font color="#868626">~True()~</font> <font color="#3159D1">THEN</font> <font color="#3159D1">BEGIN</font> d <font color="#3159D1">SAY</font> <font color="#868626">~kelsey~</font> <font color="#3159D1">END</font>
  <font color="#3159D1">ADD_STATE_TRIGGER</font> foozle <font color="#0000FF">1</font> <font color="#219121">/* state b */</font> <font color="#868626">~MyCondition()~</font></pre>
\end{rawhtml}
The resulting \t{foozle} dialogue will have the (expected) \t{a-b-c-d}
ordering.

{\em However}, consider this evil example: 
\begin{rawhtml}
<pre>  <font color="#219121">//////
</font>  <font color="#219121">// foozle.DLG contents, assume it has already been created and is
</font>  <font color="#219121">// sitting on your hard drive somewhere
</font>  <font color="#219121">// IF            ~True()~ THEN BEGIN a SAY ~Jason~ END
</font>  <font color="#219121">// IF            ~~ THEN BEGIN b SAY ~yada~ END
</font>  <font color="#219121">// IF            ~True()~ THEN BEGIN c SAY ~Compton~ END
</font>  <font color="#219121">// IF            ~True()~ THEN BEGIN d SAY ~kelsey~ END
</font>  <font color="#219121">//////
</font>
  <font color="#219121">// new D file
</font>  <font color="#3159D1">ADD_STATE_TRIGGER</font> foozle <font color="#0000FF">1</font> <font color="#219121">/* state b */</font> <font color="#868626">~MyCondition()~</font></pre>
\end{rawhtml}
This will update \t{foozle} and the resulting order will be \t{a-c-d-b}
(because when \t{foozle.}\ttref{DLG} was loaded from the disk, \t{a} \t{c}
and \t{d} were given weights but \t{b} was not (because it had an empty
trigger)).  Thus, you should avoid using \ttref{ADD!STATE!TRIGGER} on
states with empty triggers unless you know what you are doing. 

\subsection{\DEFINE{TRA} Translation Files}

If you are writing a mod and you would like to make it easier to translate
it into another language you can use "translation files" (much like BGII
itself uses \t{DIALOG.}\ttref{TLK}) to separate your dialogue structure and content.  A
translation file basically lists the string texts in order. For example,

\CMD{WeiDU --trans SCSARLES.DLG}

This creates \t{scsarles}.\ttref{D} and \t{scsarles.tra}.
\t{scsarles.}\ttref{D} now contains:
\begin{rawhtml}
<pre width="80"><font color="#3159D1">IF</font> <font color="#868626">~NumTimesTalkedTo(0)~</font> <font color="#3159D1">THEN</font> <font color="#3159D1">BEGIN</font> <font color="#0000FF">0</font> <font color="#219121">// from:
</font>  <font color="#3159D1">SAY</font> @<font color="#0000FF">1</font> <font color="#219121">/* ~Who is it? Might I ask why you have disturbed my meditations?
    My creative muse must be gently awakened, and your stomping about is
    simply not conducive to this.~ [SARLES02] #28655 */</font>
  <font color="#3159D1">IF</font> <font color="#868626">~~</font> <font color="#3159D1">THEN</font> <font color="#3159D1">REPLY</font> @<font color="#0000FF">2</font>
    <font color="#219121">/* ~My apologies. I will leave you to your thinking.~ #28656 */</font> <font color="#3159D1">GOTO</font> <font color="#0000FF">1</font>
  <font color="#3159D1">IF</font> <font color="#868626">~~</font> <font color="#3159D1">THEN</font> <font color="#3159D1">REPLY</font> @<font color="#0000FF">3</font> <font color="#219121">/* ~I apologize, but I have come to request your
  talent on a commissioned artwork.~ #28657 */</font>
    <font color="#3159D1">DO</font> <font color="#868626">~SetGlobal("TalkedToSarles","GLOBAL",1)~</font> <font color="#3159D1">GOTO</font> <font color="#0000FF">2</font>
<font color="#3159D1">END</font> </pre>
\end{rawhtml}
Note that all of the strings have been replaced by \t{@number} and the texts
have been put in comments. 

The translation file \t{scsarles.tra} contains all of those strings: 
\begin{rawhtml}
<pre><font color="#219121">// SCSARLES translation file
</font>@<font color="#0000FF">1</font>   = <font color="#868626">~Who is it? Might I ask why you have disturbed my meditations?
My creative muse must be gently awakened, and your stomping 
about is simply not conducive to this.~</font> [SARLES02]
@<font color="#0000FF">2</font>   = <font color="#868626">~My apologies. I will leave you to your thinking.~</font>
@<font color="#0000FF">3</font>   = <font color="#868626">~I apologize, but I have come to request your talent on a commissioned artwork.~</font> </pre>
\end{rawhtml}
You may then ask someone who speaks another language to write a new
translation file by translating every string in \t{scsarles.tra}. This
prevents the string text and the structure from getting out of sync
and simplifies translation; non-technical players can translate raw text
files easily. 

When compiling a \ttref{D} file that contains \t{@number} translation
references you must supply (at least) one translation file. For example,
you might say:

\CMD{WeiDU SCSARLES.D italian.tra}

You may specify multiple translation files. The last one to define a string
wins. This is useful if one language is more up to date than the others. In
this example:

\CMD{WeiDU SCSARLES.D english.tra italian.tra}

Strings will be taken from the italian translation whenever possible, but
if they are not available it will fall back on the english versions.

You may use WeiDU to check and make sure that translations are up to date.
WeiDU will automatically generate a text file listing all of the strings
that are present in one translation (usually your native one) that are
missing in another. You can then send this file to your translators so that
they know what to do. This example command compares all of the \ttref{TRA}
files in the \t{american} and \t{french} directories and creates a file
called \t{MISSING}. 

\CMD{weidu --tcmp-from american --tcmp-to french --out MISSING}

\subsection{Converting a ``hard-coded'' \ttref{D} to a \ttref{D}/\ttref{TRA} pair (Last Update: v200)}

This tutorial was thoughtfully provided by Jason Compton. 

\ttref{D} and \ttref{TP2} files allow programmers to describe text either
literally:
\begin{rawhtml}
<pre width="80"><font color="#219121">// Greeting.d
</font><font color="#3159D1">SAY</font> <font color="#868626">~Hello.~</font>
</pre>
\end{rawhtml}
or with a companion \ttref{TRA} (translation) file that supports multiple
languages:
\begin{rawhtml}
<pre width="80"><font color="#219121">// Greeting.d
</font><font color="#3159D1">SAY</font> @<font color="#0000FF">1</font>

<font color="#219121">// Greeting.tra
</font>@<font color="#0000FF">1</font> = <font color="#868626">~Hello.~</font>
</pre>
\end{rawhtml}
The idea being that one can make a French version of \t{Greeting.tra} which
contains
\begin{rawhtml}
<pre width=80><font color="#219121">// French-Greeting.tra
</font>@<font color="#0000FF">1</font> = <font color="#868626">~Bonjour.~</font>
</pre>
\end{rawhtml}
However, some WeiDU users, for reasons of convenience or simply never
anticipating the opportunity to translate, may have originally chosen the
"hard-coded" approach but now regret that decision. \t{--traify} will break
out all the text in \ttref{SAY}, \ttref{REPLY}, and \ttref{JOURNAL} entries
into translation-ready format. \t{--traify} may also be used on \ttref{TP2}
files. 

To turn the hard-coded \ttref{D} file \t{FWKI.d} into a new
\ttref{D}/\ttref{TRA} combo, use
\t{--traify} and \t{--out} to specify the input and output filenames,
respectively:

  \CMD{ weidu --traify fwki.d --out fwki-new.d}

After a brief pause, \t{fwki-new.d} and \t{fwki-new.tra} will be created.

The \t{--traify} process turns \t{fwki.d}'s
\begin{rawhtml}
<pre width="80"><font color="#3159D1">APPEND</font> J#KLSYJ
  <font color="#3159D1">IF</font> <font color="#868626">~~</font> <font color="#3159D1">THEN</font> <font color="#3159D1">BEGIN</font> KelseySAHPR4
    <font color="#3159D1">SAY</font> <font color="#868626">~Urk. Who was the lucky donor?~</font>
    <font color="#3159D1">IF</font> <font color="#868626">~~</font> <font color="#3159D1">THEN</font> <font color="#3159D1">EXTERN</font> SAHPR2 <font color="#0000FF">10</font>
  <font color="#3159D1">END</font>
<font color="#3159D1">END</font> </pre>
\end{rawhtml}
into \t{fwki-new.d}'s
\begin{rawhtml}
<pre width="80"><font color="#3159D1">APPEND</font> J#KLSYJ
  <font color="#3159D1">IF</font> <font color="#868626">~~</font> <font color="#3159D1">THEN</font> <font color="#3159D1">BEGIN</font> KelseySAHPR4
    <font color="#3159D1">SAY</font> @<font color="#0000FF">0</font>
    <font color="#3159D1">IF</font> <font color="#868626">~~</font> <font color="#3159D1">THEN</font> <font color="#3159D1">EXTERN</font> SAHPR2 <font color="#0000FF">10</font>
  <font color="#3159D1">END</font>
<font color="#3159D1">END</font> </pre>
\end{rawhtml}
and in the newly created \t{fwki-new.tra}, you will find
\begin{rawhtml}
<pre>@<font color="#0000FF">0</font>    = <font color="#868626">~Urk. Who was the lucky donor?~</font></pre>
\end{rawhtml}
and this dialogue file is now ready for translation.

{\tt --traify} works from the top of the \ttref{D} down, starting at \t{@0}. It
will NOT skip over any existing \t{@x} translation references it finds, so if
your \ttref{D} contains any translation support at all, it is best to use {\tt
--traify-old-tra} as well.

Because standard \t{--traify} starts at \t{@0} and is unaware of any any existing
\t{@x} entries in the \ttref{D}, if you have begun to convert a \ttref{D} to a
\ttref{D}/\ttref{TRA} pair by hand, you may have \t{@x} entries that clash with
\t{--traify}'s results.

In other words, if you already have a state that says
\begin{rawhtml}
<pre width="80"><font color="#3159D1">IF</font> <font color="#868626">~~</font> <font color="#3159D1">THEN</font> <font color="#3159D1">BEGIN</font> blah
  <font color="#3159D1">SAY</font> @<font color="#0000FF">0</font>
  <font color="#3159D1">IF</font> <font color="#868626">~~</font> <font color="#3159D1">THEN</font> <font color="#3159D1">EXIT</font>
<font color="#3159D1">END</font></pre>
\end{rawhtml}
\t{--traify} will not skip \t{@0} automatically, you will have two locations where
\t{@0} is used but you intended to use two different strings, and this will be
bad.

To avoid this problem, add the \t{--traify-old-tra} argument to specify the file
containing the already traified strings:

 \CMD{ weidu --traify fwki.d --traify-old-tra fwki.tra --out fwki-new}

will put the existing and new ones \t{@x} references in \t{fwki-new.tra}.

Finally, note that \t{--traify} works for \ttref{BAF} files as well.

Note: We were previously suggesting to use \t{--traify\#} here. Unless you want
for some reason to have new references starting at a given number, you should
use \ttref{--traify-old-tra} instead.

In all cases, you might also find it beneficial to put the
\ttref{--traify-comment} argument in your command line, so that you'll also have
the content of the @references in your file (which will make it easier to edit it later):

 \CMD{ weidu --traify fwki.d --traify-old-tra fwki.tra --out fwki-new --traify-comment}

In particular, using \ttref{--traify-comment} and \ttref{--traify-old-tra} together
will add the missing comments without doubling the existing ones.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{\ttref{REPLACE!ACTION!TEXT}} 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
This tutorial was thoughtfully provided by Japheth. 

\ttref{REPLACE!ACTION!TEXT} can be used with regular expressions
(\ttref{regexp}).  So, some actions such as
\t{CreateCreature("blah",[0.0],1)} won't be matched by WeiDU because when
you say \t{[0.0]} it is looking for a character set.

Here's one dialogue that I'm fixing and how to do it correctly.

\t{Arghai.dlg} has this action trigger before
\ttref{REPLACE!ACTION!TEXT}ing it.

\begin{verbatim}
CreateCreature("OGREHA",[1351.1078])}
\end{verbatim}

There's no point given, which makes WeiDU and NI angry. To fix it using
\ttref{REPLACE!ACTION!TEXT} this is what you have to do:

\begin{verbatim}
REPLACE_ACTION_TEXT arghai
~CreateCreature("OGREHA",\[1351.1078\])~
~CreateCreature("OGREHA",[1351.1078],0)~
\end{verbatim}

So, all you have to remember to do is escape the square brackets with a
backslash so WeiDU doesn't confuse them with a regular expression.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{\DEFINE{ALTER!TRANS} (Last Update: 204.)}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
This tutorial was thoughtfully provided by CamDawg.

ALTER_TRANS is a more compatibility-friendly way of changing transitions in an existing dialogue state. This is best illustrated with an example; let's use state 9 from doghma.dlg in BG2:

\begin{verbatim}
IF ~~ THEN BEGIN 9 SAY #45751
  IF ~~ THEN REPLY #45752 GOTO 2
  IF ~GlobalLT("chapter","GLOBAL",4)~ THEN REPLY #45753 GOTO 5
  IF ~~ THEN REPLY #45754 GOTO 4
  IF ~Global("RevealUmar","GLOBAL",1)
      PartyHasItem("miscbl")
      PartyHasItem("miscbm")
      PartyHasItem("miscbn")
      PartyHasItem("miscbo")~ THEN REPLY #57922 GOTO 10
  IF ~~ THEN REPLY #45755 GOTO 1
END
\end{verbatim}


The problem lies in transition 3, which should have an OR(4) before those four PartyHasItem checks. Before ALTER_TRANS, the least destructive way to fix it would be

\begin{verbatim}
ADD_TRANS_TRIGGER DOGHMA 9 ~False()~ DO 3
EXTEND_BOTTOM DOGHMA 9
IF ~Global("RevealUmar","GLOBAL",1)
OR(4)
PartyHasItem("miscbl")
PartyHasItem("miscbm")
PartyHasItem("miscbn")
PartyHasItem("miscbo")~ THEN REPLY #57922 GOTO 10
END
\end{verbatim}


This presents some compatibility issues though. If another mod has altered this transition (for example, a new action via ADD_TRANS_ACTION) then those changes are lost via this method. It also reorders the replies as they're displayed on-screen--not a big issue for transitions involving replies, but it is a big issue for non-reply transitions where they're evaluated from the bottom-up. It's also an issue for other mods that target this transition, as the False() essentially eliminates it. Enter ALTER_TRANS:

\begin{verbatim}
ALTER_TRANS DOGHMA // file name
BEGIN 9 END // state number (can be more than one)
BEGIN 3 END // transition number (can be more than one)
BEGIN // list of changes, see below for flags
  "TRIGGER" ~Global("RevealUmar","GLOBAL",1)
           OR(4)
             PartyHasItem("miscbl")
             PartyHasItem("miscbm")
             PartyHasItem("miscbn")
             PartyHasItem("miscbo")~
END
\end{verbatim}


There are eight flags you can use in the list of changes. If you do not use a particular flag, the previous value of the transition will be retained (i.e. not specifying an ACTION flag will preserve the current action of the transition).

\begin{itemize}
\item TRIGGER: The trigger condition for the transition.
 i.e \verb+"TRIGGER" ~Global("foo","GLOBAL",0)~+

\item ACTION: The action performed if the transition is selected.
  i.e. \verb+"ACTION" ~SetGlobal("foo","GLOBAL",1)~+

\item REPLY: The player's reply, if any.
  i.e. \verb+"REPLY" ~#57922~+

\item JOURNAL: Can add or change the journal entry.
  i.e. \verb+"JOURNAL" ~@100~+

\item SOLVED!JOURNAL: Same as JOURNAL, except for entries into the solved section of the journal.

\item UNSOLVED!JOURNAL: Same as JOURNAL, except for entries into the unsolved section of the journal.

\item EPILOGUE: Specifies where the transition leads to (GOTO, EXTERN, or EXIT)
  i.e. \verb+EPILOGUE" ~EXTERN BVICONI 0~+

\item FLAGS: Used to set transition flags manually, though I can't imagine why one would do this.
\end{itemize}

Let's try one last example. This is bviconi.dlg, state 103:

\begin{verbatim}
IF WEIGHT #22 ~Global("LoveTalk","LOCALS",46)~ THEN BEGIN 103 SAY #10537
  IF ~~ THEN REPLY #10538 GOTO 367
  IF ~~ THEN REPLY #10539 EXTERN ~~ 0
END
\end{verbatim}


As you can see the transition destination for the second transition is broken. In the olden days this would be fixed with

\begin{verbatim}
ADD_TRANS_TRIGGER BVICONI 103 ~False()~ DO 1
EXTEND_BOTTOM BVICONI 103
IF ~~ THEN REPLY #10539 GOTO 368
END
\end{verbatim}


With ALTER_TRANS, it beomes much easier:

\begin{verbatim}
ALTER_TRANS BVICONI BEGIN 103 END BEGIN 1 END BEGIN "EPILOGUE" ~GOTO 368~ END
\end{verbatim}

Addendum: please note that it's important to wrap the target (for example, REPLY or EPILOGUE)
in quotes, tildas, or percentage signs.

Further addendum: REPLY, JOURNAL and friends will remove the feature (rather than add an empty
journal line or whatever) if the associated string is empty.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Module Packaging: \DEFINE{TP2} Files}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\label{TP}

At some point you will be done with your mod (a collection of \t{CRE},
\t{ITM}, \ttref{D}, etc., files) and you will want to package it up so that
other users can install it (and then perhaps uninstall it later) easily.
WeiDU can handle this task for you (and you may freely distribute \t{WeiDU.exe}
with your module).

A \ttref{TP2} describes how to install components of your module. WeiDU
will read the file, ask the user questions, and then perform the
installation. Uninstallation and upgrading are also handled. 

See the file \t{examples/mymod.tp2} for a commented example of how this all
works. 

Here is the context-free grammar syntax for the \ttref{TP2} file format:

\begin{tabular}{cp{10in}|p{10in}}

\DEFINE{TP2 File} & & 
  A \ttref{TP2 File} is a text file that contains a number of 
  mod \ttref{Component}s. \ttref{TP2 File}s tell WeiDU how to install
  various parts of your mod on an end-user's computer. \\

  is & \DEFINE{BACKUP} directoryName

       \DEFINE{AUTHOR} emailAddress

       \ttref{TP2 Flag} \Slist

       \ttref{Language} \Slist

       \ttref{Component} \Slist &

       A \ttref{TP2 File} is basically a prologue and then a list of
       \ttref{Component}s. The \ttref{BACKUP} declaration tells WeiDU where
       to put backed-up versions of files that would be overwritten so that
       they can be uninstalled later. This directory will be created 
       automatically if it is missing. The \ttref{AUTHOR} directive gives an
       email address for users to send bugs to if there are problems during
       the installation. The \DEFINE{TP2!AUTHOR} \ttref{variable} is set to
       the ``emailAddress'' value. The \DEFINE{TP2!FILE!NAME} \ttref{variable}
	   is set to the name of the tp2 file. 
       \ttref{TP2 Flag}s set global options. 
       \ttref{Language}s are
       the various languages in which your mod is available. The
       Finally, the \ttref{Component}s make up the actual meat of
       your mod. Different \ttref{Component}s can be installed or
       uninstalled separately, but all of the parts within a
       \ttref{Component} are treated as a unit.  \\
\\

\DEFINE{TP2 Flag} & & A \ttref{TP2 Flag} declaration tells WeiDU to apply some
global option to your \ttref{TP2} file. \\
  is & \DEFINE{AUTO!TRA} path &
       The \ttref{AUTO!TRA} flag is used
       with the \ttref{COMPILE} \ttref{TP2 Action}. It automatically loads
       \ttref{TRA} files that match your \ttref{D} files.  \\
  or & \DEFINE{ALLOW!MISSING} file \Slist & 
       \ttref{ALLOW!MISSING} directive allows you to specify files that can
       be missing (when you try to copy them or reference them from
       \ttref{D} files). Empty versions of those files will be created on
       demand. Try to use \ttref{ACTION!IF} instead of this. \\
  or & \DEFINE{ASK!EVERY!COMPONENT} & 
       This flag instructs WeiDU to ask about installing every component in
       this \ttref{TP2} file individually, rather than asking questions
       like "Would you like to install them all?" \\
  or & \DEFINE{ALWAYS} \ttref{TP2 Action} \Slist \t{END} &
       This flag specified a \ttref{TP2 Action} that is executed at the beginning
       of each \ttref{Component}, before the component-specific \ttref{TP2 Action}.  \\
  or & \DEFINE{README} file &
       The given file is displayed to the user after choosing the language, but
       before installing any component.
  \\
  or & \DEFSYN{MODDER} String \Slist &
       Enable additional debug info. By default, these messages are verbose but do
       not halt the installation. Some options are configurable, see the \ttref{MODDER}
       in-depth description.
       \\
  or & \DEFINE{VERSION} String &
  		"String" (variables evaluated) will be appended to every component's name in the
  		weidu.log file.
			\\
  or & \DEFINE{SCRIPT!STYLE} style &
       This flag determines how WeiDU will read in \ttref{BAF} and
       \ttref{BCS} files and
       write out \ttref{BAF} and \ttref{BCS} files. Possible options for
       ``style'' include \t{BG} (the default), \t{IWD1}, \t{IWD2}, and \t{PST}. 
       See \ahrefloc{sec-scripting-styles}{the Scripting Styles tutorial}. \\
  or & \DEFINE{NO!IF!EVAL!BUG} & this action solves a long-standing bug with
    the IF!EVAL action. Since solving it is not directly possible without
    damaging backwards compatibility, you have to use this action (preferably
    in an ALWAYS statement) to solve the bug for yourself. IF!EVAL will not
    work with this action in the TP2 - use \ttref{PATCH!IF} and
    \ttref{BUT!ONLY!IF!IT!CHANGES} instead. \\

\\

\DEFINE{Language} & & 
  A \ttref{Language} declaration tells WeiDU where to find \ttref{TRA}
  files. \\

  is & \DEFINE{LANGUAGE} languageName
       languageDirectory
       defaultLanguageTRA \Slist &
       The languageName is the name of the language as it is presented to
       the user. "American English" and "Italiano" are
       examples. The languageDirectory is the name of the subdirectory in
       which you have stored the \ttref{TRA} files for that language.
       Examples include "american" and "spanish". The \ttref{variable}
       named \t{LANGUAGE} is set to languageDirectory if the user selects
       this language.. Finally, all of the \ttref{TRA} files in the
       defaultLanguageTRA list are loaded as soon as the user selects a
       language.  \\
\\

\DEFINE{Component} & & 
  A \ttref{Component} is a contiguous group of files and actions that a
  user can install, uninstall or upgrade. \\

  is & \DEFSYN{BEGIN} componentName 
    \ttref{Component Flag} \Slist 
    \ttref{TP2 Action} \Slist &
    Basically, if componentName is "Foo", the user will be asked: "Do you
    want to install Foo?". If so, all of the associated \ttref{TP2 Action}s 
    are performed. If not, they are skipped. \\

\\

\DEFINE{Component Flag} && 
  A \ttref{Component Flag} determines how WeiDU treats a component. \\

  is & \DEFINE{DEPRECATED} \ttref{String} & 
      Mark the given component as deprecated. If it is currently installed,
      it will be uninstalled and the given \ttref{String} will be
      displayed. The user will never be asked to install the given
      component -- it will be silently skipped in all listings. However, it
      will still take up a ``component number''. \\

  or & \DEFINE{REQUIRE!COMPONENT} modToUninstall modComponent
      \ttref{String} &
      Make this component so that it can only be installed if another
      component is installed. If that other component is not installed, the
      \ttref{String} will be displayed and the user will not get a chance
      to install this component. This is in some sense the opposite of the
      \ttref{UNINSTALL} \ttref{TP2 Action}. For example,
      \t{REQUIRE!COMPONENT "setup-ease.tp2" "0" "You must have infinite
      stacking installed!"} prevents a component from being installed
      unless the infinite stacking part of the Ease-of-Use mod is
      installed.  \\

  or & \DEFINE{FORBID!COMPONENT} modToUninstall modComponent
      \ttref{String} &
      Make this component so that it can only be installed if another
      component is \emph{not} installed. This does the opposite of
      \ttref{REQUIRE!COMPONENT}.  \\

  or & \DEFINE{REQUIRE!PREDICATE} \ttref{value} \ttref{String} &
      This component can only be installed if the \ttref{value}
      evaluates to true (non-zero). \\

  or & \DEFSYN{SUBCOMPONENT} \ttref{String} \Ob \ttref{value} \Oe &
      At most one component of the given subcomponent group can be
      installed at any time. All subcomponents of the same group are
      listed together for the user. See the \ttref{SUBCOMPONENT}
      tutorial. \\

  or & \DEFINE{FORCED!SUBCOMPONENT} \ttref{String} \Ob \ttref{value} \Oe &
      See the \ttref{SUBCOMPONENT} tutorial. \\
  
  or & \DEFSYN{GROUP} \ttref{String} & Used for grouping components; the user
      will be asked to display these or not. See the \ttref{GROUP} tutorial. \\

  or & \DEFINE{INSTALL!BY!DEFAULT} &
      If WeiDU would ask the user whether to install this component or not,
      and this component is not already installed, WeiDU will instead
      install it by default (without asking the user). If there is an error
      or the component is already installed, WeiDU will ask the user. The
      \ttref{--uninstall} command-line argument overrides this. See also
      \ttref{REQUIRE!COMPONENT} and \ttref{ALWAYS}.  \\

  or & \DEFINE{DESIGNATED} forcedNumber &
      Normally module components are numbered based on their order in the
      \ttref{TP2} file (starting from 0). This flag sets the current
      component number to forcedNumber. The next component (if it lacks a
      \ttref{DESIGNATED} flag) will be forcedNumber+1. You can easily shoot
      yourself in the foot by setting forcedNumber too low (e.g., so that
      multiple components have the same number). \emph{Do not use this
      flag.} \\

  or & \DEFINE{NO!LOG!RECORD} &
      Normally all module components are recorded in \t{WeiDU.log} and can
      be uninstalled later. This component flag prevents this component
      from writing a log record when it is successfully installed. As a
      result it is ``invisible'' to WeiDU, can be installed multiple times,
      and cannot be uninstalled with WeiDU. \emph{Do not use this flag.} \\
\\

\DEFINE{TP2 Action} & & 
  A \ttref{TP2 Action} tells WeiDU how to install a component. This usually
  involves copying files and writing in new string references. \\

  is & \DEFINE{COPY} \ttref{optNoBackup} 
                     \ttref{optGlob} fromFile toFile ...
       \ttref{patch} \Slist
       \ttref{when} \Slist &
       You may specify as many fromFile-toFile pairs as you like. Each
       fromFile is copied to its associated toFile. If there are any WeiDU
       variables inside explicit \t{\%}s in toFile or fromFile, they are
       replaced by their values. All of the
       \ttref{patch}es are applied. If there are any \ttref{when}
       conditions and any of them are false, the copy does not happen. 
       A typical example is \t{COPY "mymod/sword.itm"
       "override/m\#sword.itm"}.
       
       \ 
       
       \ttref{COPY} commands set the user-defined \DEFINE{SOURCE!DIRECTORY}, 
       \DEFINE{SOURCE!FILESPEC}, \DEFINE{SOURCE!FILE}, 
       \DEFINE{SOURCE!RES}, \DEFINE{SOURCE!EXT},
       \DEFINE{DEST!DIRECTORY}, \DEFINE{DEST!FILESPEC}, 
       \DEFINE{DEST!FILE},\DEFINE{DEST!RES} and \DEFINE{DEST!EXT}
       \ttref{variable}s based on fromFile and toFile as follows. If
       fromFile is \t{mymod/cre/bigboss.cre}, then 
       \ttref{SOURCE!DIRECTORY} is \t{mymod/cre}, 
       \ttref{SOURCE!FILESPEC} is \t{mymod/cre/bigboss.cre}, 
       \ttref{SOURCE!FILE} is \t{bigboss.cre},
       \ttref{SOURCE!RES} is \t{bigboss} and \ttref{SOURCE!EXT} is \t{cre}.
       The \t{DEST!} variables
       are similarly based on toFile. In addition, \DEFINE{SOURCE!SIZE} is
       set to the size (in bytes) of the source file. 

       \ 

       This is generally only useful if you have enabled globbing. Any
       user-defined \ttref{variables} in toFile are replaced with their
       values. You may also reference these \ttref{variables} in 
       \ttref{patch}es.

       \

       See the \ttref{Module Distribution} section for information about
       finding a good unique prefix for your mod-created resources. 
       \\
  or & \DEFINE{COPY!EXISTING} \ttref{optNoBackup} fromFile toFile ...
        &
       Behaves like \ttref{COPY} except that the fromFiles are drawn from
       the game \ttref{BIFF}s or \t{override} directory. This is useful for
       making changes to files that other mods may have changed as well.
       \\
  or & \DEFINE{COPY!EXISTING!REGEXP} \ttref{optNoBackup} \ttref{optGlob} fromFileRegexp toDir ...
       \ttref{patch} \Slist
       \ttref{when} \Slist &
       Behaves like \ttref{COPY!EXISTING} except that fromFileRegexp may
       contain \ttref{regexp} regular exprsesions. All matching files in
       the game \ttref{BIFF}s will be copied to the directory specified by
       toDir.

       \

       If \ttref{GLOB} is specified, matching files in \t{override} will
       also be patched and copied. If a file appears in both the
       \ttref{BIFF}s and the \t{override} folder, it will only be copied
       once. For example, if \t{HARM.ITM} is in the \ttref{BIFF}s and
       \t{HARM2.ITM} is in \t{override}, this code will copy and patch them
       both:

       \begin{verbatim}
COPY_EXISTING_REGEXP GLOB ~HARM.*.ITM~ ~override~
  SAY // ... whatever
\end{verbatim}
       \\
  or & \DEFINE{COPY!LARGE} \ttref{optNoBackup} \ttref{optGlob} fromFile toFile ...
       &
       Behaves like \ttref{COPY} except that the fromFiles can be of arbitrary
       size (the limit should be over a Gigabyte), but on the other side of 
       the coin you can't apply patches to the copying.
       \\
  or & \DEFINE{COPY!RANDOM} \t{(} file1 \Slist \t{)}
    \Ob \t{(} fileN \Slist \t{)} \Slist \Oe
       \ttref{patch} \Slist
       \ttref{when} \Slist &
      This command works like \ttref{COPY!EXISTING} but the destination
      for any given souce file in the file1-list is some other different
      file in the file1-list. Similarly, the destination for any file in
      the fileN-list is some other file in the fileN-list. This allows you
      to randomly shuffle categories of game resources. \\
  or & \DEFINE{COPY!ALL!GAM!FILES}
       \ttref{patch} \Slist
       \ttref{when} \Slist &
       Copies Default.gam from the biff and the ones in the save/ and mpsave/ saved
       games, applying the list of patches. If there are any \ttref{when} conditions
       and any of them are false, the copy does not happen. \emph{NO BACKUP is applied
       to files in the save/ and mpsave/ directories. The savegame from the biffs is
       backuped as usual.}  \\


  or & \DEFINE{COMPILE} \Ob EVALUATE!BUFFER \Oe sourceFile \Slist
       \Ob \ttref{patch} \Slist \Oe \Ob \DEFINE{USING} traFile \Slist \Oe &
      This command compiles \ttref{D} and \ttref{BAF} source files. If
      sourceFile is a directory, all \ttref{D} and \ttref{BAF} files within
      that directory are processed individually. If there is EVALUATE!BUFFER,
      all \verb+%variables%+ in the files are substituted with their values.
      
      After the special EVALUATE!BUFFER is executed, all other patches are executed.

      \

      First, this loads all of the traFiles presented. If any of their
      paths contain \t{\%s}, the \t{\%s} is replaced with the
      languageDirectory of from the  \ttref{Language} the user selected.
      If you specified \ttref{AUTO!TRA} \t{mymod/\%s} above, WeiDU will
      also attempt to load \t{mymod/languageDirectory/sourceFile.tra} for
      every sourceFile in the list. Once all of the \ttref{TRA} files are
      loaded, the \ttref{D} and \ttref{BAF} files are compiled. Any
      \ttref{DLG}s or \ttref{BCS}s they create or modify are placed in the
      \t{override} directory.  \\
  or & \DEFINE{CLEAR!MEMORY} & removes all variables from the memory, then
      reloads the automatic ones (TP2!AUTHOR, TP2!FILE!NAME, LANGUAGE, WEIDU!ARCH,
      WEIDU!OS, COMPONENT!NUMBER, all numeric constants such as NAME1, the soundsets, or
      SCRIPT!OVERRIDE). INTERACTIVE is automatically set when you call the
      next component. Don't use this feature. \\
  or & \DEFINE{CLEAR!IDS!MAP} & force WeiDU to remove all loaded IDSes in memory
      (otherwise, if you compile a script, append to an IDS and compile another script, WeiDU
      will not handle the new IDS entry). \\
  or & \DEFINE{SILENT} & makes WeiDU skip all messages; it's reenabled once a component
      is installed (or fails to), or a PRINT, PATCH!PRINT, VERBOSE or PATCH!VERBOSE is found. \\
  or & \DEFINE{VERBOSE} & undoes the latest SILENT command. \\
  or & \DEFINE{MKDIR} dirName \Slist &
      Instructs WeiDU to create all of the directories in the list. \\
  or & \DEFINE{RANDOM!SEED} someInteger &
      Sets the random number generator seed to someInteger. This allows you
      to get reproducible results when using random functions. If you
      specify a string that is not a valid integer the system initializes
      itself (e.g., by using the current time).  \\
  or & \DEFSYN{APPEND} filename newText \ttref{when} \Slist \Ob \t{KEEP!CRLF} \Oe  &
      If there are no \ttref{when} conditions or they are all true, the
      ASCII text newText is appended to the existing file filename (which
      is read from the game \ttref{BIFF}s or the \t{override} folder).
      Any variables in newText are replaced by their values.

      If \t{KEEP!CRLF} is not present, double newlines in the file
      (but not in newText) will be removed; otherwise, they're kept.

      In any event, if the file ends with CRLF only newText and an ending
      CRLF will be written; otherwise, if the file does not end with CRLF,
      it will be written before newText.
      \\
  or & \DEFINE{APPEND!OUTER} filename newText \ttref{when} \Slist \Ob \t{KEEP!CRLF} \Oe  &
      If there are no \ttref{when} conditions or they are all true, the
      ASCII text newText is appended to the existing file filename (which
      is treated as a path to a file).
      Any variables in newText are replaced by their values.

      If \t{KEEP!CRLF} is not present, double newlines in the file
      (but not in newText) will be removed; otherwise, they're kept.

      In any event, if the file ends with CRLF only newText and an ending
      CRLF will be written; otherwise, if the file does not end with CRLF,
      it will be written before newText.
      \\
  or & \DEFINE{APPEND!COL} filename newText \Ob prepend \Oe \ttref{when} \Slist &
      If there are no \ttref{when} conditions or they are all true, the
      string newText is appended column-wise to the existing file filename.
      If filename was:
      \begin{rawhtml}<br>
A B C <br>
D E F <br>
X Y Z <br>
P Q R <br>
      \end{rawhtml}
      and newText was \t{"0 1 2 3"}, the result would be:
      \begin{rawhtml}<br>
A B C 0 <br>
D E F 1 <br>
X Y Z 2 <br>
P Q R 3 <br>
      \end{rawhtml}
      You must have the same number of whitespace-separated words in
      newText as there are columns in filename. prepend empty cells are 
	  assumed to be at the beginning of newText. A cell containing exactly
	  {\verb`$`} is printed as empty. \\

  or & \DEFSYN{EXTEND!TOP} existingBCS newFile \ttref{patch} \Slist &
    Loads existingFile (which may be \ttref{BAF} or \ttref{BCS}), prepends
    all of newBCS to the top of it, applies all of the \ttref{patch}es, and
    then copies it to the \t{override} folder. User variables in
    the filenames existingFile and newFile are replaced by their values. 
    Use \ttref{EVALUATE!BUFFER} if you want to evaluate variables inside
    the body of newFile before parsing it. \\
  or & \DEFSYN{EXTEND!BOTTOM} existingBCS newFile \ttref{patch} \Slist &
    As \ttref{EXTEND!TOP}, but the newFile file is put at the bottom of the
    existingBCS file. User variables in the filenames existingFile and
    newFile are replaced by their values. \\
  or & \DEFINE{EXTEND!TOP!REGEXP} existingBCSregexp newFile \ttref{patch} \Slist &
    As \ttref{EXTEND!TOP}, but the newFile file is put at the bottom of the
    every \ttref{BCS} file that matches the \ttref{regexp}
    existingBCSregexp. \\
  or & \DEFINE{EXTEND!BOTTOM!REGEXP} existingBCSregexp newFile \ttref{patch} \Slist &
    See \ttref{EXTEND!TOP!REGEXP}.  \\
  or & \DEFINE{ACTION!IF} \ttref{value} \t{THEN BEGIN}
    \ttref{TP2 Action} \Slist \t{END}
    \Ob \t{ELSE BEGIN} \ttref{TP2 Action} \Slist \t{END} \Oe &
    If \ttref{value} evaluates to true (non-zero), the \ttref{TP2 Action}s
    in the \t{THEN}-branch are executed. Otherwise, if an \t{ELSE}-branch
    is present, its commands are executed. Otherwise nothing happens. \\
  or & \DEFINE{AT!EXIT} commandToRun &
    Whenever this \ttref{component} attemps to be installed, commandToRun
    is executed.  Variables (e.g., \t{\%LANGUAGE\%}) in the string
    commandToRun are replaced by their values. Note that the command is
    executed even if the component does not install correctly, so
    \ttref{AT!EXIT} should probably be the last command in a component. 
    \begin{itemize}
    \item 
    If commandToRun consists of a single \ttref{TP2} filename, WeiDU will
    enqueue that \ttref{TP2} file and run it when the current one is done
    (asking the user all the standard questions about languages and which
    components to install). 
    \item
    If commandToRun consists of the word \t{VIEW} followed by a file, a
    system-specific viewer will be used to present the file to the user.
    For example, on Windows systems \t{notepad} will be used to view
    \t{txt} files and a web browser will be used to view \t{html} files.
    Note: also NOTEPAD and EXPLORER work like this, but use of those are
    reserved to differently able modders.
    \item
    Otherwise, commandToRun is executed by the underlying operating system
    (and is thus system dependant). If you want to do something that
    WeiDU doesn't handle, like extracting WAVs from an MP3, make a batch
    file and run it from here. 
    \end{itemize}
    In any case, slashes and backslashes will be converted appropriately
    for the underlying operating system. The most common use is:
\begin{verbatim}
AT_INTERACTIVE_EXIT ~VIEW mymod\README.txt~
\end{verbatim}
    This causes your README file to be displayed using a system appropriate
    viewer. Here's a more complicated example that pulls up a
    language-specific README if one is available: 
\begin{verbatim}
ACTION_IF FILE_EXISTS ~mymod\README.%LANGUAGE%.txt~ THEN BEGIN
  AT_INTERACTIVE_EXIT ~VIEW mymod\README.%LANGUAGE%.txt~
END ELSE BEGIN
  AT_INTERACTIVE_EXIT ~VIEW mymod\README.txt~
END
\end{verbatim}
    \\
  or & \DEFINE{AT!INTERACTIVE!EXIT} commandToRun &
    As \ttref{AT!EXIT}, but the command is only executed if the user
    specifically asked for the \ttref{component} to be installed or
    upgraded. \\
  or & \DEFINE{AT!UNINSTALL} commandToRun &
    As \ttref{AT!EXIT}, but when this \ttref{component} is removed,
    commandToRun is executed.\\
  or & \DEFINE{AT!INTERACTIVE!UNINSTALL} commandToRun &
    As \ttref{AT!EXIT}, but whenever the user specifically asks for this
    \ttref{component} to be removed, commandToRun is executed.
    Only the \t{\%LANGUAGE\%} variable is guaranteed to be
    replaced, so do not count on any others. \\
  or & \DEFINE{AT!NOW} commandToRun &
    As \ttref{AT!EXIT}, but commandToRun is executed when found, rather than
    at the end of the installation. Use with oggdec, tisunpack, wav2acm...
    but not with readmes (you'll create dozens of windows), nor with --make-biff
    (you'll crash the installation).\\
  or & \DEFINE{AT!INTERACTIVE!NOW} commandToRun &
    As \ttref{AT!NOW}, but commandToRun is executed only if the installation is
    run interactively.\\
  or & \DEFINE{MAKE!BIFF} name-of-biff \t{BEGIN} \ttref{directory-file-regexp} \Slist \t{END} &
    Create a biff \t{Data/name-of-biff.bif} from the files that can be matched by
    directory-file-regexp. The chitin.key file is restored as a normal file, and 
    reloaded whenever the component is installed or uninstalled (which means that its 
    contents will be available exactly when the biff exists), while the .bif file
    itself is NOT deleted on uninstall.  \\
  or & \DEFINE{LOAD!TRA} traName \Slist &
    Loads all traName files (variable substitution is done, the file cannot be inlined)
    to be used in the following tp2 actions, as if you had declared them in \ttref{LANGUAGE}. \\
  or & \DEFINE{UNINSTALL} modToUninstall modComponent &
    If the given component of the given mod is currently installed,
    uninstall it before proceeding. \emph{Do not use this action.} This
    should only be used if you release a new version of a component under a
    new name. For example, many Tactics Mod components replace old
    Solaufein mod components. In order to prevent such a component from
    being installed twice, the Tactics version uninstalls the Solaufein
    version.  \\
  or & \DEFINE{COPY!KIT} oldKit newKit \verb+(+ diffName diffValue \Slist
  \verb+)+ &
    Copies a copy of the oldKit kit called newKit. This copy is non-player
    selectable, while all other fields can be edited by setting diffName to
    the field to be changed and diffValue to the new value. Valid values for
    diffName are:
    \begin{verbatim}
clasweap
weapprof
abclasrq
abclsmod
abdcdsrq
abdcscrq
dualclas
alignmnt
clab
lower
mixed
help
luabbr
25stweap
unusabilities
    \end{verbatim}
    Currently, lower, mixed and help can only be numbers referring to a TLK
    string. Unusabilities requires to be both kit and class unusables, there
    isn't a way to BAND or BOR them.
    \\
  or & \DEFINE{ADD!KIT} internalKitName manyComplexArguments &
    This command allows you to add new kits to the BGII. 
    See the example file \t{mymod.tp2} or the tutorial at
    \ahrefurl{\url{http://forums.gibberlings3.net/index.php?showtopic=584}}
    for information on how to do this.
    \\
  or & \DEFINE{ADD!MUSIC} internalMusicName newMUSFile & 
    No documentation yet!
    \\
  or & \DEFINE{ADD!PROJECTILE} modpath/PROName.PRO &
    Appends an entry for PROName to \t{PROJECTL.IDS} and assigns it the next
    available ProRef number.  Then copies the file \t{modpath/PROName.PRO}
    to the \t{override} folder.  The new ProRef number can be accessed
    through the variable \t{\%PROName\%} and used to updated the
    \t{Projectile type} field of an ITM or SPL file's \t{Item Ability} or
    \t{Spell Ability} sub-structures.  (The hexadecimal offsets for these
    fields can be found using NearInfinity.) In the following example, a
    new PRO file and an ITM file that will use it are added to the game:
    \begin{verbatim}
        ADD_PROJECTILE      ~MyMod/MYDXP.PRO~
        COPY ~MyMod/MYDART.ITM~ ~override/MYDART.ITM~
            WRITE_SHORT   0x09c ~%MYDXP%~
    \end{verbatim}
    \\
  or & \DEFINE{ADD!SPELL} newSPLfile type level idsName \ttref{patch} \Slist
       \ttref{when} \Slist &
    adds newSPLfile as a spell of type and level into the game (IE, SPPR102 or
    whatnot), in the first empty slot possible, appends the idsName to
    spell.ids, and sets \verb+%idsName%+
    to the 4-digit code associated with idsName in Spell.ids. While you copy
    newSPLfile to the override, you also apply the patches listed. \\
  or & \DEFINE{STRING!SET} indexOrString newValue \Slist
    \Ob \t{USING} traFile \Oe &
    This command replaces each given string in the user's \ttref{TLK} file
    with the associated newValue. \emph{Do not use this command.} If a
    traFile is given, that file is is read once before all of the
    replacements take place and its contents are forgotten after. \emph{Do
    not use this command.} \\

  or & \DEFINE{STRING!SET!EVALUATE} \ttref{value} newValue \Slist
    \Ob \t{USING} traFile \Oe &
    This command replaces the string at index value in the user's \ttref{TLK} file
    with the associated newValue. \emph{Do not use this command.} If a
    traFile is given, that file is is read once before all of the
    replacements take place and its contents are forgotten after. \emph{Do
    not use this command.} \\

  or & \DEFINE{STRING!SET!RANGE} \#min \#max \t{USING} traFile &
    For every integer i between min and max (inclusive) we do
    \t{STRING!SET i @i USING traFile} (except that this command should be
    executed more rapidly). The command will fail if @i is not defined
    (either by traFile or by some other tra file in scope) for some i
    between min and max.  \emph{Do not use this command.} \\

	or & \DEFINE{ALTER!TLK!RANGE} \ttref{value} \ttref{value} \t{BEGIN} \ttref{patch} \Slist \t{END} &
		Executes the given patch list on all the strings *currently* in dialog.tlk between the
		two given values (both inclusive).
		This means that strings added in the current mod installation will not
		be patched, and strings already altered via \ttref{ALTER!TLK}* and/or \ttref{STRING!SET}*
		will be patched from the pre-patch condition. DNUT. \\

or & \DEFINE{ALTER!TLK!LIST} \t{BEGIN} \ttref{value} \Slist \t{END} \t{BEGIN} \ttref{patch} \Slist \t{END} &
		Executes the given patch list on all the strings *currently* in dialog.tlk from the given list.
		This means that strings added in the current mod installation will not
		be patched, and strings already altered via \ttref{ALTER!TLK}* and/or \ttref{STRING!SET}*
		will be patched from the pre-patch condition. DNUT. \\

	or & \DEFINE{ALTER!TLK} \t{BEGIN} \ttref{patch} \Slist \t{END} &
		Executes the given patch list on all the strings *currently* in dialog.tlk.
		This means that strings added in the current mod installation will not
		be patched, and strings already altered via \ttref{ALTER!TLK}* and/or \ttref{STRING!SET}*
		will be patched from the pre-patch condition. DNUT. Consider using
		\ttref{ALTER!TLK!RANGE} with the base game's boundaries instead. \\

  or & \DEFINE{REQUIRE!FILE} filename warningString &
    If filename does not exist (or the bif file is not referenced inside
    the chitin.key), warningString is displayed and this
    \ttref{component} cannot be installed. This is checked before any
    actions are executed. \\
  or & \DEFINE{FORBID!FILE} filename warningString &
    If filename does exist (or the bif file is referenced inside
    the chitin.key), warningString is displayed and this
    \ttref{component} cannot be installed. This is checked before any
    actions are executed. \\
  or & \DEFINE{FAIL} warningString &
    If this \ttref{TP2 Action} is execution, warningString is displayed and
    the \ttref{component} fails to install. \\
  or & \DEFINE{PRINT} displayString &
    The string DisplayString is echoed to the user. Useful for debugging or
    status reports. If displayString contains \t{\%}\ttref{variable}\t{\%}
    references, their values will be displayed. \\
or & \DEFINE{OUTER!SPRINT} \ttref{variable} stringWithVars &
  Any WeiDU variables (enclosed in \t{\%}s) inside stringWithVars are
  replaced by their values and the resulting string (constructed at
  mod-installation time!) is assigned to the variable \t{variable}. 
  This works somewhat like \t{sprintf()} but it not as cool. \\
or & \DEFINE{OUTER!SET} \ttref{variable} \t{=} \ttref{value} &
  Update \ttref{variable} so that it is equal to \ttref{value}. \\
or & \DEFINE{OUTER!INNER!PATCH} buffString \t{BEGIN} \ttref{patch} \Slist \t{END} &
  Any WeiDU variables inside \t{\%}s within buffString are replaced by
  their values. All of the \ttref{patch}es given are evaluated as if the
  contents of the current file were buffString. Any modifications to
  buffString are thrown away. This is considered an action, not a patch. \\
or & \DEFINE{OUTER!PATCH} buffString \t{BEGIN} \ttref{patch} \Slist \t{END} &
  Equal to \ttref{OUTER!INNER!PATCH}, if you feel that OUTER!INNER sounds wrong. \\
or & \DEFINE{OUTER!INNER!PATCH!SAVE} savevar buffString \t{BEGIN} \ttref{patch} \Slist \t{END} &
  As with \ttref{OUTER!INNER!PATCH}, except that any modifications to buffString are stored inside
  savevar. \\
or & \DEFINE{OUTER!PATCH!SAVE} savevar buffString \t{BEGIN} \ttref{patch} \Slist \t{END} &
  Equal to \ttref{OUTER!INNER!PATCH!SAVE}, if you feel that OUTER!INNER sounds wrong. \\
or & \DEFINE{OUTER!FOR} \t{(} \ttref{patch} \Slist \t{;}
                        \ttref{value} \t{;}
                        \ttref{patch} \Slist \t{)}
                  \t{BEGIN} \ttref{TP2 Action} \Slist \t{END} &
  The \ttref{TP2 Action} \t{OUTER!FOR (init;pred;inc) BEGIN body END} is equivalent to
  \t{init WHILE pred BEGIN INNER!ACTION BEGIN body END inc END}, except that
  it's considered an action. Note that the predicate \ttref{value} cannot be empty.  \\
or & \DEFINE{ACTION!BASH!FOR} \ttref{directory-file-regexp} \t{BEGIN} \ttref{TP2 Action} \Slist \t{END} &
  for all files that match \ttref{directory-file-regexp}, sets a bunch of variables
  and executes the actions for each file found. Assuming the file being copied
  is somedir/yourfile.cre, the following variables will be set:
\begin{verbatim}
"%BASH_FOR_DIRECTORY%" = "somedir"
"%BASH_FOR_FILESPEC%" = "somedir/yourfile.cre"
"%BASH_FOR_FILE%" = "yourfile.cre"
"%BASH_FOR_RES%" = "yourfile"
"%BASH_FOR_SIZE%" = <size of somedir/yourfile.cre>
\end{verbatim}                                           \\

or & \DEFINE{ACTION!DEFINE!ARRAY} \t{\ttref{String}1 BEGIN \ttref{String}2} \Slist \t{END} &
	Sets the array \verb+$string1(0)+,\verb+$string1(1)+ etc. to the various elements in string2.
\\

or & \DEFINE{ACTION!FOR!EACH} \t{\ttref{String}1 IN \ttref{String}} \Slist
                              \t{BEGIN} \ttref{TP2 Action} \Slist \t{END} &
    will set the string1 variable to each value in string list and process each action. \\

or & \DEFINE{ACTION!PHP!EACH} \t{\ttref{String}1 AS \ttref{String}2 => \ttref{String}3} \Slist
                              \t{BEGIN} \ttref{TP2 Action} \Slist \t{END} &
    For every value of the string1 array that has been created or read, sets
    \verb+string2!0+ to the first array parameter, \verb+string2!1+ to the second array
    parameter, etc. and string3 to the result of the array. \verb+string2+ will also contain
		the first array parameter (as a synonym of \verb+string2!0+). then executes the
    actions listed. More exaustive documentation will be provided by SConrad.
\\

or & \DEFINE{INCLUDE} \t{\ttref{String}} \Slist & 
    loads the file string as if it were a list of tp2 actions and executes it (as if
		it had been typed inside your tp2).
    These files have by convenience tph as an extension, due to no reason other than
    randomness (you can use .tp1 or .xyzsucks if you're so oriented).
		Please note that, to speed up inclusions, tph files are stored in memory,
	  rather than re-read each time from the hard-disk. If you need automorphing code
		(IE, you want to edit your tph file), you can use \ttref{REINCLUDE} instead. \\
or & \DEFINE{ACTION!INCLUDE} \t{\ttref{String}} \Slist &
    A synonym of \ttref{INCLUDE}.
\\
or & \DEFINE{REINCLUDE} \t{\ttref{String}} \Slist &
    Works like \ttref{INCLUDE}, but loads each time the tph file from the hard disk.
    This is slower, but required if you want to edit your tph file between an
    inclusion and another.
    \\
or & \DEFINE{ACTION!REINCLUDE} \t{\ttref{String}} \Slist &
    A synonym of \ttref{INCLUDE}.
    \\
  or & \DEFSYN{ADD!GAM!NPC} npcCRE npcARE xCoord yCoord &
    See the \ttref{ADD!GAM!NPC} tutorial for more information about this
    action, which is used when adding NPCs to Baldur's Gate 1. BG2 mods
    should not use this command.  \\
  or & \t{<<<<<<<<} fileName fileBody \t{>>>>>>>>} &
    (That's eight (8) angle brackets on each side.)
    For the purposes of copying and compiling files, WeiDU will pretend
    that fileName is a real file with contents fileBody. This allows you to
    define \DEFINE{inlined} files inside your TP2 file. Such definitions
    must be executed before the \ttref{inlined} file is used. Other operations
    on fileName (such as \ttref{FILE!EXISTS}, \ttref{FILE!MD5} or
    \ttref{FILE!SIZE}) are undefined. Inlined files will be skipped by
    \ttref{COPY!EXISTING!REGEXP} and other ``wildcard'' approaches: you
    must name them directly. Unlike most other WeiDU things,
    spacing matters here. After the initial \t{<<<<<<<<} there can be
    any number of spaces. The first non-space character after the
    \t{<<<<<<<<} is the first character of fileName. All other
    characters up to and excluding the newline on that line are part of
    fileName (and thus fileName cannot start with a space or contain a
    newline). All user variables (e.g., \t{\%foo\%}) in fileName will be
    replaced by their values.
    The fileBody contains all characters after that newline up to
    and excluding the \t{<<<<<<<<}. Note that a single inlined filename
    namespace is shared by WeiDU for all \ttref{TP2} files it reads (it
    might read other \ttref{TP2} files in the process of installing yours
    in order to uninstall or reinstall another mod's components), so it is
    \emph{criticially} important that you use some sort of unique prefix.
    I also suggest that you avoid using your mod's actual directory
    structure (if any) in order to avoid confusion with real files.
    Consider using \t{.../yourmod-inlined/fileName}.  Here is a concrete
    working example:
\begin{verbatim}
BEGIN ~MyMod Component 1~

<<<<<<<< .../mymod-inlined/myfile.baf
IF
  True()
THEN
  RESPONSE #100
    Kill("Anomen")
END
>>>>>>>>

COMPILE ~.../mymod-inlined/myfile.baf~
\end{verbatim} 
  This inclusion method is eight-bit clean, so if you are very careful you
  can \ttref{inline} a binary file (e.g., a \ttref{CRE} or \ttref{BAM}) with
  this method. Be careful to shave off the newline before the \t{>>>>>>>>}
  in such cases. Finally, note that \ttref{inline}d files have the same
  maximum size as other (non-BIFF) WeiDU files and strings (usually about
  16 megs).  
\\

\\

\DEFINE{optNoBackup} & & 
  A \ttref{COPY} command normally makes a backup copy of its target (if one
  exists) so that the mod can be uninstalled later by restoring the backup.
  \\

  is &   & If you don't say anything here, WeiDU {\em will} make a backup
           copy of the file and the \ttref{COPY} will be undone if the mod
           is uninstalled. \\
  or & \t{+} & If you put a \t{+} here, WeiDU will {\em not} make a backup
           copy of the file and the \ttref{COPY} will {\em not} be
           undone if the mod is uninstalled. {\em Do not use this feature.  } \\
  or & \t{-} & If you put a \t{-} here, WeiDU will {\em not} copy the file,
           but only store it as an inlined file (so you can patch a file and
           then use it for \ttref{EXTEND!BOTTOM} or whatever.
           This option is not available for \ttref{COPY!LARGE}. \\
\\

\DEFINE{directory-file-regexp} & & This is a directory path and a \ttref{regexp} string.
It's used by \ttref{BIFF}, \ttref{ACTION!BASH!FOR} and \ttref{PATCH!BASH!FOR}
for listing patterns to be matched. Please note that
the directory / filename distinction must be enforced. \\
is & directory \ttref{regexp} & get a list of all files in directory that match \ttref{regexp}.
Case doesn't matter. \\
or & directory \t{EVALUATE!REGEXP} \ttref{regexp} & get a list of all files in directory that match \ttref{regexp}.
Case doesn't matter. This is the same as the above item. \\
or & directory \t{EXACT!MATCH} name & get the file directory/name. Please note that
the directory / filename distinction must be enforced. \\

\\
\DEFINE{optGlob} & &
  A \ttref{COPY} command may use \emph{globbing} to expand filename 
  wildcards with respect to files \emph{on the host filesystem}. Unlike
  \ttref{COPY!EXISTING!REGEXP}, glob wildcards do not range over game
  resources. Instead, they range over physical files actually on the disk. 
  \\
  is & & Do not use local filesystem globbing. This is the default. \\
  or & \DEFINE{GLOB} & Use local filesystem globbing. Globbing is
  generally architecture specific! \emph{Do not use globbing if you can
  help it.} 

  Here is a concrete example. Imagine that \t{CHITIN.KEY} contains 
  two files: C1.ITM and C2.ITM. The \t{override} contains C2.ITM and
  C\_MOD.ITM.
  \begin{verbatim}
  COPY_EXISTING_REGEXP "C.*.ITM" "override" 
    // catches C1.ITM, C2.ITM

  COPY_EXISTING_REGEXP GLOB "C.*.ITM" "override" 
    // catches C1.ITM, C2.ITM, C_MOD.ITM

  COPY "override" "override" 
    // catches C2.ITM, C_MOD.ITM
  \end{verbatim}
  To put it another way: if you do not specify \ttref{GLOB} with
  \ttref{COPY!EXISTING}, WeiDU pretends that the \t{override} directory
  contains 0 files that are not in \t{CHITIN.KEY}. Finally, GLOB has no
  effect on wildcards in the "destination" part of the \ttref{COPY}:
  \begin{verbatim}
  COPY GLOB "mymod/foo" "music/*"  
    // this is illegal: DO NOT DO THIS
  \end{verbatim}
  
  \\

\\

\DEFINE{optcase} && Allows you to decide wether regexp matching is case-sensitive
or not. \\
is  & & Uses the WeiDU default (which is undocumented and varies with the action).
      Please specify case-sensitiveness manually. \\
or & \DEFINE{CASE!SENSITIVE} & matching is case-sensitive. \\
or & \DEFINE{CASE!INSENSITIVE} & matching is case-insensitive. \\

\\

\\

\DEFINE{optexact} && Allows you to decide wether regexp matching is exact. \\
is  & & Uses the WeiDU default (which is undocumented and varies with the action).
      Please specify matching policy manually. \\
or & \DEFINE{EXACT!MATCH} & only the given string is searched for. \\
or & \DEFINE{EVALUATE!REGEXP} & matching is evaluated following the usual regexp
      conventions. \\

\\

\\

\DEFINE{patch} & & A \ttref{patch} tells WeiDU how to modify a file.  \\
is & \DEFSYN{SAY} \ttref{offset} \ttref{String} &
  The string-ref associated with \ttref{String} is written at
  \ttref{offset}. This is commonly used to change the name or
  description of a spell or item. \\
or & \DEFINE{PATCH!PRINT} displayString & 
  The string DisplayString is echoed to the user. Useful for debugging or
  status reports. If displayString contains \t{\%}\ttref{variable}\t{\%}
  references, their values will be displayed. See also \ttref{PRINT}.
  Example: 
  \begin{verbatim}
    COPY_EXISTING_REGEXP ~.*\.CRE~ ~override~
      READ_BYTE 0x272 race
      READ_BYTE 0x273 class
      PATCH_IF class = 3 THEN BEGIN
        PATCH_PRINT
          ~%SOURCE_FILE% is a cleric with race = %race%.~
      END 
  \end{verbatim} \\
or & \DEFINE{SAY!EVALUATED} \ttref{offset} stringWithVars & 
  Any WeiDU variables (enclosed in \t{\%}s) inside stringWithVars are
  replaced by their values and the resulting string (constructed at
  mod-installation time!) is added to \t{DIALOG.TLK} and its string
  reference it written to the \ttref{offset}. Example:
  \begin{verbatim}
    COPY_EXISTING_REGEXP ~RING.*.ITM~ ~override~
      READ_LONG 0x38 cost 
      SAY_EVALUATED IDENTIFIED_DESC
        ~I Am %SOURCE_RES%, I Cost %cost%~
  \end{verbatim}
  \emph{Do not use this feature.} \\
or & \DEFINE{TO!UPPER} \ttref{variable} &
  Turns to upper-case the contents of \verb+%variable%+ and store the
  results in variable. \\
or & \DEFINE{TO!LOWER} \ttref{variable} &
  Turns to lower-case the contents of \verb+%variable%+ and store the
  results in variable. \\
or & \DEFINE{SPRINT} \ttref{variable} stringWithVars &
  Any WeiDU variables (enclosed in \t{\%}s) inside stringWithVars are
  replaced by their values and the resulting string (constructed at
  mod-installation time!) is assigned to the variable \t{variable}.
  This works somewhat like \t{sprintf()} but it not as cool. Currently this
  is the only way to assign a string value to a variable. \\

or & \DEFINE{SNPRINT} \ttref{value} \ttref{variable} stringWithVars & 
  As \ttref{SPRINT}, but only the first \t{N} characters are stored in
  the \ttref{variable}, where \t{N} is the result of evaluating the
  \ttref{value}. This works somewhat like \t{snprintf()}. Thus:
  \begin{verbatim}
  SPRINT "author" "Jason"
  SNPRINT 3 "myvar" "1:%author%"
  \end{verbatim}
  ... assigns \t{1:J} to \t{myvar}.  \\

or & \DEFINE{SPACES} \ttref{variable} stringWithVars &
  \verb+%variable%+ will be inited to a string the same length as stringWithVars,
  but made entirely of spaces. \verb+SPACES var ~123~+ will crate \verb+%var% = "   "+.
\\
or & \DEFINE{QUOTE} \ttref{variable} stringWithVars &
  \verb+%variable%+ will be inited to a string that will match exactly stringWithVars.
  \verb+SPACES var ~some\thing^~+ will crate \verb+%var% = "some\\thing\^"+.
\\
or & \DEFSYN{REPLACE} \ttref{optcase} \ttref{optexact} \ttref{regexp} \ttref{text}
   &
  All occurences of \ttref{regexp} in the file are replaced with the ASCII
  printing of the string reference for \ttref{text}. So if \ttref{regexp}
  is "FRED" and the \ttref{text} ends up being strref \#1234, "FRED" will
  be replaced with "1234". This is usually used to replace string
  references in \ttref{BCS} files (where they are stored textually). Put a
  command like \t{DisplayString(Myself,99999)} in your \ttref{BCS} file
  and use something like \t{REPLACE 99999 "Hello, World"}. \\
or & \DEFINE{REPLACE!TEXTUALLY} \ttref{optcase}  \ttref{optexact}
    \ttref{regexp} string \Ob \t{(} \t{sizeValue} \t{)} \Oe & 
  All occurences of the given \ttref{regexp} in the file are replaced with
  the given string.
  \ttref{variable} 
  substitution (e.g., kit and music names) is performed on both the 
  string and the regexp. 
  If you use the sizeValue field, optexact is automatically set to true (IE 
  without regexp patterns). The regexp and the string are padded by zeros to 
  be long exactly sizeValue bytes. \\
or & \DEFINE{EVALUATE!BUFFER!SPECIAL} string &
  String must be one character long. Any WeiDU variables (like \t{XmyvarX})
	inside the current file are replaced by their values, where X is to be intended
	as string. Example:
\begin{verbatim}
<<<<<<<< .../script.baf
IF
  See($myvar$)
THEN
  RESPONSE #100
    Kill(%myvar%)
END
>>>>>>>>
EXTEND_TOP ~sola.bcs~ ~.../script.baf~
  SPRINT myvar = ~"Anomen"~
  EVALUATE_BUFFER_SPECIAL ~$~
\end{verbatim}
	\t{$myvar$} will be substituted with Anomen, but \t{\%myvar\%} will be not.
	
	DNUT.
\\
or & \DEFINE{EVALUATE!BUFFER} &
  Any WeiDU variables (like \t{\%myvar\%}) inside the current file (which
  should probably be a plain text file in order for this to make much sense)
  are replaced by their values. Example:
\begin{verbatim}
<<<<<<<< .../script.baf
IF
  See(%myvar%)
THEN
  RESPONSE #100
    Kill(%myvar%)
END
>>>>>>>>
EXTEND_TOP ~sola.bcs~ ~.../script.baf~
  SPRINT myvar = ~"Anomen"~
  EVALUATE_BUFFER
\end{verbatim}
  Those two actions extend the top of \t{sola.bcs} with the script
  block \t{IF See("Anomen") THEN RESPONSE \#100 Kill("Anomen") END}.
  You can also use \ttref{EVALUATE!BUFFER} in \ttref{COMPILE} actions
  or before strings in \ttref{value}s.
  \\

or & \DEFINE{APPLY!BCS!PATCH} patchFile &
  Applies patchFile to the current file. See \ttref{--bcmp-from} and similar
  command-line arguments for constructing these patches. \\
or & \DEFINE{APPLY!BCS!PATCH!OR!COPY} patchFile copyFile &
  Applies patchFile to the current file, as \ttref{APPLY!BCS!PATCH}.
  However, if the patching fails the current file is replaced with copyFile
  instead. \\
or & \DEFINE{WRITE!BYTE} \ttref{offset} \ttref{value} &
  The first argument is the offset at which the second argument (an 8-bit
  byte value) is written. \\
or & \DEFINE{WRITE!SHORT} \ttref{offset} \ttref{value} &
  The first argument is the offset at which the second argument (a 16-bit
  short value) is written. \\
or & \DEFINE{WRITE!LONG} \ttref{offset} \ttref{value} &
  The first argument is the offset at which the second argument (a 32-bit
  long word value) is written. \\
or & \DEFINE{WRITE!ASCII} \ttref{offset} ascString
    \Ob \t{\#requiredSize} \Oe &
  The ASCII ascString is written to the file starting at offset. 
  If you specify a \t{requiredSize} then exactly that many bytes are
  written (if ascString is smaller, it is padded with \t{NUL}s; if
  ascString is larger, it is truncated). 
  If you do not specify a requiredSize, the terminating \t{NUL} is not
  written. \\
or & \DEFINE{WRITE!ASCII!TERMINATE} \ttref{offset} ascString &
  The ASCII ascString is written to the file starting at offset.
  If you do not specify a requiredSize, the terminating \t{NUL} \em{is}
  written. \\
or & \DEFINE{WRITE!EVALUATED!ASCII} \ttref{offset} ascString
    \Ob \t{\#requiredSize} \Oe &
  The ASCII ascString is evaluated (so \t{\%variable\%} is replaced by its
  value) and written to the file starting at offset (as in
  \ttref{WRITE!ASCII}. \\
or & \DEFINE{WRITE!FILE} \ttref{offset} filename &
  The entire contents of ``filename'' (which may contain variables) are
  loaded and copied over the current file starting at offset
  \ttref{offset}. ``filename'' must be a literal filename like
  \t{mymod/data/file.bam}. If there is not enough room between
  \ttref{offset} and the end of the file for the contents of ``filename''
  the \ttref{patch} will fail with an error message. \\
or & \DEFINE{INSERT!FILE} \ttref{offset} filename &
  Just like \ttref{WRITE!FILE} except that the entire contents of
  ``filename'' are inserted at \ttref{offset}, just as if you had done an
  \ttref{INSERT!BYTES} with the size of ``filename'' to that \ttref{offset}
  followed by a \ttref{WRITE!FILE} to that \ttref{offset}. \\
or & \DEFINE{APPEND!FILE} filename &
  Just like \ttref{INSERT!FILE} except that the entire contents of
  ``filename'' are appended to the end of the current file. \\
or & \DEFINE{APPEND!FILE!EVALUATE} filename &
  Just like \ttref{APPEND!FILE} except that \verb+%variables%+ in the contents of
  ``filename'' are evaluated before the appending. \\
or & \DEFINE{REPLACE!BCS!BLOCK} oldFile newFile &
  If the current file is a \ttref{BCS} file, the segment of it
  corresponding to oldFile is replaced with the contents of newFile. 
  oldFile and newFile may be \ttref{BCS} or \ttref{BAF} files. If they
  are \ttref{BAF} files they will not get the benefit of \ttref{AUTO!TRA}. 
  \\
or & \DEFINE{INSERT!BYTES} \ttref{offset} \ttref{value} &
  The first argument is the offset, the second argument is the count. 
  The file will be expanded at the given offset with count bytes worth of
  zeroes. \\
or & \DEFINE{DELETE!BYTES} \ttref{offset} \ttref{value} &
  The first argument is the offset, the second argument is the count. 
  The file will shrink as count bytes are deleted starting at the given
  offset. \\
or & \DEFINE{READ!BYTE} \ttref{offset} \ttref{variable} \Ob \t{ELSE}
\ttref{value} \Oe &
  An 8-bit value is read from the file at the given \ttref{offset} and is stored
  in the given \ttref{variable}. If \ttref{offset} is out-of-bounds and the
  \t{ELSE} is present, the \t{ELSE}-\ttref{value} is assigned to
  \ttref{variable}. If \ttref{offset} is out-of-bounds and the \t{ELSE} is
  not present, the \ttref{patch} fails with a visible error.  \\
or & \DEFINE{READ!SBYTE} \ttref{offset} \ttref{variable} \Ob \t{ELSE}
\ttref{value} \Oe &
  As \ttref{READ!BYTE}, but the value is interpreted as signed. \\
or & \DEFINE{READ!SHORT} \ttref{offset} \ttref{variable} \Ob \t{ELSE}
\ttref{value} \Oe &
  A 16-bit value is read from the file at the given \ttref{offset} and is
  stored in the given \ttref{variable}. See \ttref{READ!BYTE}. \\
or & \DEFINE{READ!SSHORT} \ttref{offset} \ttref{variable} \Ob \t{ELSE}
\ttref{value} \Oe &
  As \ttref{READ!SHORT}, but the value is interpreted as signed. \\
or & \DEFINE{READ!LONG} \ttref{offset} \ttref{variable} \Ob \t{ELSE}
\ttref{value} \Oe &
  A signed 32-bit value is read from the file at the given \ttref{offset}
  and is stored in the given \ttref{variable}. See \ttref{READ!BYTE}. \\
or & \DEFINE{READ!SLONG} \ttref{offset} \ttref{variable} \Ob \t{ELSE}
\ttref{value} \Oe &
  As \ttref{READ!SLONG}, but the value is interpreted as signed. \\
or & \DEFINE{READ!ASCII} \ttref{offset} \ttref{variable} \Ob \t{ELSE}
  \t{string} \Oe \Ob \t{(} \ttref{value} \t{)} \Ob \t{NULL} \Oe \Oe &
    A nul-terminated string is read from the file at
    the given \ttref{offset} and is stored in the given \ttref{variable}.
    The terminating nul is not stored. The default read size is 8 bytes.
    If an explicit size \ttref{value} is specified then that many bytes are read
    into the \ttref{variable}, even if some of them are nuls, except if \t{NULL}
    is present, in which case a nul-terminated string is read, without storing
    the terminating null. See
  \ttref{READ!BYTE}.  If the \ttref{offset} is out-of-bounds and the
  \t{ELSE} clause is present, the \t{string} is evaluated as in
  \t{WRITE!EVALUATED!ASCII} and then assigned into \ttref{variable}.
  \\
or & \DEFINE{READ!STRREF} \ttref{offset} \ttref{variable} \Ob \t{ELSE}
\t{string} \Oe &
  A 32-bit Infinity Engine \t{DIALOG.TLK} string reference is read from the
  file at the given \ttref{offset}. The string reference is looked up in
  \t{DIALOG.TLK} and the (male) string value for it (without any quotes) is
  stored in the \ttref{variable}. In some sense this is the opposite of
  \ttref{SAY!EVALUATED}.  \\

or & \DEFINE{GET!OFFSET!ARRAY} \ttref{String} \t{seven \ttref{value}s} &
		This is too complicated to explain with words. SConrad owes documentation.
\\

or & \DEFINE{GET!OFFSET!ARRAY2} \ttref{String} \t{eight \ttref{value}s} &
		This is too complicated to explain with words. SConrad owes documentation.
\\

or & \DEFINE{GET!STRREF} \ttref{value} \ttref{variable} &
  The string reference value is looked up in \t{DIALOG.TLK} and the (male) string
  (without any quotes) is stored in the \ttref{variable}.  \\
or & \DEFINE{SET} \ttref{variable} \t{=} \ttref{value} &
  Update \ttref{variable} so that it is equal to \ttref{value}. \\
or & \ttref{variable} \t{=} \ttref{value} &
  Update \ttref{variable} so that it is equal to \ttref{value}. \\
or & \Ob \ttref{SET} \Oe \ttref{variable} \t{+=} \ttref{value} &
  Equivalent to \t{SET variable = variable + value}. \\
or & \Ob \ttref{SET} \Oe \ttref{variable} \t{-=} \ttref{value} &
  Equivalent to \t{SET variable = variable - value}. \\
or & \Ob \ttref{SET} \Oe \ttref{variable} \t{*=} \ttref{value} &
  Equivalent to \t{SET variable = variable * value}. \\
or & \Ob \ttref{SET} \Oe \ttref{variable} \t{/=} \ttref{value} &
  Equivalent to \t{SET variable = variable / value}. \\
or & \Ob \ttref{SET} \Oe \ttref{variable} \t{\&=} \ttref{value} &
  Equivalent to \t{SET variable = variable BAND value}. \\
or & \Ob \ttref{SET} \Oe \ttref{variable} \t{|=} \ttref{value} &
  Equivalent to \t{SET variable = variable BOR value}. \\
or & \Ob \ttref{SET} \Oe \ttref{variable} \t{<<=} \ttref{value} &
  Equivalent to \t{SET variable = variable BLSL value}. \\
or & \Ob \ttref{SET} \Oe \ttref{variable} \t{>>=} \ttref{value} &
  Equivalent to \t{SET variable = variable BLSR value}. \\

or & \DEFINE{WHILE} \ttref{value} \t{BEGIN} 
  \ttref{patch} \Slist \t{END} & 
  If \ttref{value} is non-zero, execute the given \ttref{patch} \Slist and
  then repeat, re-evaluating the \ttref{value}. 
  {\em Be very careful when using this command. } You can easily describe
  an infinite loop. See the \ttref{WHILE} loop tutorial for more
  information. 
  \\
or & \DEFINE{FOR} \t{(} \ttref{patch} \Slist \t{;}
                        \ttref{value} \t{;}
                        \ttref{patch} \Slist \t{)} 
                  \t{BEGIN} \ttref{patch} \Slist \t{END} &
  The \ttref{patch} \t{FOR (init;pred;inc) BEGIN body END} is equivalent to
  \t{init WHILE pred BEGIN body inc END}. Note that the predicate
  \ttref{value} cannot be empty.  \\
or & \DEFINE{PATCH!BASH!FOR} \ttref{directory-file-regexp} \t{BEGIN} \ttref{patch} \Slist \t{END} &
  for all files that match \ttref{directory-file-regexp}, sets a bunch of variables
  and executes the patches for each file found. Assuming the file being copied
  is somedir/yourfile.cre, the following variables will be set:
\begin{verbatim}
"%BASH_FOR_DIRECTORY%" = "somedir"
"%BASH_FOR_FILESPEC%" = "somedir/yourfile.cre"
"%BASH_FOR_FILE%" = "yourfile.cre"
"%BASH_FOR_RES%" = "yourfile"
"%BASH_FOR_SIZE%" = <size of somedir/yourfile.cre>
\end{verbatim}            \\

or & \DEFINE{DEFINE!ARRAY} \t{\ttref{String}1 BEGIN \ttref{String}2} \Slist \t{END} &
	Sets the array \verb+$string1(0)+,\verb+$string1(1)+ etc. to the various elements in string2.
\\

or & \DEFINE{PATCH!DEFINE!ARRAY} \t{\ttref{String}1 BEGIN \ttref{String}2 \Slist END} &
	Same as \ttref{DEFINE!ARRAY}.
\\


or & \DEFINE{PATCH!FOR!EACH} \t{\ttref{String}1 IN \ttref{String}} \Slist
                             \t{BEGIN} \ttref{patch} \Slist \t{END} &
    will set the string1 variable to each value in string list and process each patch. \\

or & \DEFINE{PHP!EACH} \t{\ttref{String}1 AS \ttref{String}2 => \ttref{String}3} \Slist
                       \t{BEGIN} \ttref{patch} \Slist \t{END} &
    For every value of the string1 array that has been created or read, sets
    string2!0 to the first array parameter, string2!1 to the second array
    parameter, etc. and string3 to the result of the array. \verb+string2+ will also contain
		the first array parameter (as a synonym of \verb+string2!0+). then executes the
    patches listed. More exaustive documentation will be provided by SConrad.
\\

or & \DEFINE{PATCH!PHP!EACH} \t{\ttref{String}1 AS \ttref{String}2 => \ttref{String}3} \Slist
                             \t{BEGIN} \ttref{patch} \Slist \t{END} &
    A synonym of \ttref{PHP!EACH}.
\\

or & \DEFINE{CLEAR!ARRAY} \ttref{String} &
    `Forgets' that the array \t{string} exists until its values are recalled.
    The actual variables' values are kept, the only effect is that \t{*PHP!EACH}
    will not consider old values.
\\


or & \DEFINE{PATCH!IF} \ttref{value} \Ob \t{THEN} \Oe \t{BEGIN}
  \ttref{patch} \Slist \t{END} 
  \Ob \t{ELSE} \t{BEGIN} \ttref{patch} \Slist \t{END} \Oe 
  &
  If \ttref{value} is non-zero, execute the first \ttref{patch} \Slist 
  once. Otherwise, execute the second \ttref{patch} \Slist (if any). As a
  convenient shorthand, you may omit the \t{BEGIN}-\t{END} in the \t{ELSE}
  branch if the \t{ELSE} branch contains exactly one \t{patch}.  
  \\
or & \DEFINE{PATCH!INCLUDE} \t{\ttref{String}} \Slist &
    loads the file string as if it were a list of tp2 patches and executes it (as if
		it had been typed inside your tp2).
    These files have by convention tpp as an extension, due to no reason other than
    randomness (you can use .tp1 or .xyzsucks if you're so oriented).
		Please note that, to speed up inclusions, tpp files are stored in memory,
	  rather than re-read each time from the hard-disk. If you need automorphing code
		(IE, you want to edit your tpp file), you can use \ttref{PATCH!REINCLUDE} instead. \\
or & \DEFINE{PATCH!REINCLUDE} \t{\ttref{String}} \Slist &
    Works like \ttref{PATCH!INCLUDE}, but loads each time the tph file from the hard disk.
    This is slower, but required if you want to edit your tpp file between an
    inclusion and another.
    \\
or & \DEFSYN{SET!2DA!ENTRY} \ttref{value} \ttref{value} \ttref{value}
\ttref{value} &
  The first \ttref{value} is the row, the second is the column and the
  third is the \emph{required column count}. The entry on the given column
  of the given row is set to the fourth \ttref{value}, but only rows with
  at least as many columns as the required column count are considered. 
  The fourth \ttref{value}, the new entry, is evaluated specially: if it
  can be evaluated like a value (e.g., \t{``3+4''}) it will be evaluated
  and its integer result will be written as an ASCII string. Otherwise if
  it is a single string (that is not a variable in scope) that string will
  be written at the new value.
  See
  the \ttref{SET!2DA!ENTRY} tutorial for more information.  \\
or & \DEFSYN{SET!2DA!ENTRY!LATER} string \ttref{value} \ttref{value} \ttref{value} &
  Similar to \t{SET!2DA!ENTRY}, memorizes the 2da changes in the RAM without
  flushing them to the file. See the \ttref{SET!2DA!ENTRY!LATER} tutorial. \\
or & \DEFSYN{SET!2DA!ENTRIES!NOW} string \ttref{value} & To be used with
  \t{SET!2DA!ENTRY!LATER}: flushes the file changes in one go. See the 
  \ttref{SET!2DA!ENTRIES!NOW} tutorial. \\
or & \DEFINE{PRETTY!PRINT!2DA} & Indents the 3rd line in the current file (which
  should be a  2da file). \\
or & \DEFSYN{PRETTY!PRINT!2DA} \ttref{value} & Indents the value'th line
(counting from 0) in the current file (which should be a 2da file). \\
or & \DEFINE{INSERT!2DA!ROW} \t{\ttref{value}1 \ttref{value}2 \ttref{String}} &
  String (after variable substitution) will be inserted as a new line in the table.
  Value1 is the row count, value2 is the \emph{required column count}. If row count is
  the same as the number of long enough lines in the file, then the line will be inserted
  at the end; if row count is lesser than the number of lines, it will be inserted just before
  the nth line in the original file (starting count from 0); finally, if row count is greater
  than the number of lines, the component will fail to install.
  \begin{verbatim}<<<<<<<< 2dafile
asd foo
a b c
d e f
g h i
>>>>>>>>
COPY ~2dafile~ ~2dafile~
INSERT_2DA_ROW 3 3 ~4 4 4~
INSERT_2DA_ROW 2 3 ~3 3 3~
INSERT_2DA_ROW 1 3 ~2 2 2~
INSERT_2DA_ROW 0 3 ~1 1 1~
\end{verbatim} will result in
\begin{verbatim}
asd foo
1 1 1
a b c
2 2 2
d e f
3 3 3
g h i
4 4 4
\end{verbatim} \\
or & \DEFSYN{READLN} \ttref{variable} &
  Waits for the user to provided an enter-terminated string and store it in
  variable. Said string will be stored and re-used at reinstall time. See the
  \ttref{READLN} tutorial. \\
or & \DEFINE{PATCH!RANDOM!SEED} \ttref{value} &
  See \ttref{RANDOM!SEED}. \\
or & \DEFSYN{ADD!STORE!ITEM} \Ob \t{+} \Oe itemName \Ob position \Oe
  numCharges ext2 ext3 itemFlag maxInStack \Ob unlimited \Oe &
  See the \ttref{ADD!STORE!ITEM} tutorial for more information.
 \\
or & \DEFINE{REMOVE!STORE!ITEM} itmName \Slist &
  Remove the listed items from the current store. Does nothing if an item is not for sale.
	Multiple instances are removed. \\
or & \DEFINE{READ!2DA!ENTRY} \ttref{value} \ttref{value} \ttref{value}
\ttref{variable} &
  The first \ttref{value} is the row, the second is the column and the
  third is the \emph{required column count}. The variable specified is set
  to the the entry on the given column of the given row, but only column
  with at least as many columns as the required column count are
  considered. This is the reverse of \ttref{SET!2DA!ENTRY}. \\
or & \DEFSYN{READ!2DA!ENTRIES!NOW} string \ttref{value} &
  Reads in one go all the 2da in the RAM for \ttref{READ!2DA!ENTRY!FORMER}. See the
  \ttref{READ!2DA!ENTRIES!NOW} tutorial. \\
or & \DEFSYN{READ!2DA!ENTRY!FORMER} string \ttref{value} \ttref{value} \ttref{value}
  & Similar to \ttref{READ!2DA!ENTRY}, but reads from a prepared
  \ttref{READ!2DA!ENTRIES!NOW} command rather than from the file.
  See the \ttref{READ!2DA!ENTRY!FORMER} tutorial. \\
or & \DEFINE{COUNT!2DA!ROWS} \ttref{value} \ttref{variable} &
  The first \ttref{value} is the required column count. This command
  counts the number of rows in the current file (which should be a
  \ttref{2DA} file) that have at least as many columns as the required
  column count and stores the result in the variable. \\
or & \DEFINE{COUNT!2DA!COLS} \ttref{variable} &
  This command counts the number of columns in the current file (which should be a
  \ttref{2DA} file) and stores the result in the variable. \\
or & \DEFINE{COUNT!REGEXP!INSTANCES} \ttref{optcase} \ttref{optexact} \ttref{regexp}
    \ttref{variable} &
  This command counts the number of times regexp appears in the current file
  and stores the result in the variable. Variable substitution is performed
  on regexp prior to regexp handling (EG, if \verb+%var% = ~abc~+,
  \verb+~[%var%]~+ is evaluated as \verb+~[abc]~+. \\

or & \DEFINE{LOOKUP!IDS!SYMBOL!OF!INT} variable idsFile \ttref{value} &
  The symbolic constant associated with \ttref{value} in idsFile (which may
  contain user variables) is stored
  in variable. If that doesn't work, \ttref{value} is stored in variable.
  Example:
  \begin{verbatim}
    LOOKUP_IDS_SYMBOL_OF_INT foo ~spell~ 1101
    SPRINT myfile "SPELL" 
    LOOKUP_IDS_SYMBOL_OF_INT bar ~%myfile%~ (0x44c + 1)
    LOOKUP_IDS_SYMBOL_OF_INT baz ~spell~ 77777
  \end{verbatim}
  Both \t{foo} and \t{bar} are \t{CLERIC\_BLESS} while \t{baz} is
  \t{777777}. \\

or & \DEFINE{COMPILE!BAF!TO!BCS} & 
  The current file, which must be a valid \ttref{BAF} script, is compiled
  to a \ttref{BCS}. In general you should use the \ttref{COMPILE}
  \ttref{TP2 Action} instead, unless you are using other \t{patch} commands
  to modify the file under consideration. \\
or & \DEFINE{DECOMPILE!BCS!TO!BAF} & 
  The current file, which must be a valid \ttref{BCS} script, is decompiled
  to a \ttref{BAF}. \\
or & \DEFINE{DECOMPILE!DLG!TO!D} &
  The current file, which must be a valid \ttref{DLG} file, is decompile
  to a textual \ttref{D} file (with string refs and no comments). Once you
  have a \ttref{D} file you can use other \t{patch} commands to change the
  actions and triggers around. You should use \ttref{D} actions (like
  \ttref{REPLACE!ACTION!TEXT} instead whenever possible.  \\
or & \DEFINE{COMPILE!D!TO!DLG} &
  The current file, which must be a valid \ttref{D} file that defines
  a single \ttref{DLG} file (via an obvious \ttref{BEGIN} action) is
  compiled to a \ttref{DLG}. Typically this is only used after a
  \ttref{DECOMPILE!DLG!TO!D}.  \\
or & \DEFINE{REPLACE!EVALUATE} \ttref{optcase} findRegexp \t{BEGIN}
  \ttref{patch} \Slist \t{END} replaceRegexp & 
  For every instance of the \ttref{regexp} findRegexp found, the
  \ttref{patch} list is evaluated (with the variable \t{MATCH}$i$ set to
  the $i$th matched group in findRegexp), variable substitute is performed
  on replaceRegexp, and then findRegexp is replaced by replaceRegexp. Any
  writes dones by the \ttref{patch} list (e.g., \ttref{SAY} or
  \ttref{WRITE!ASCII}) are ignored: \ttref{SET} should be the main
  component of the \ttref{patch} list. For example:
  \begin{verbatim}
    COPY ~nice.baf~ ~mean.baf~
      REPLACE_EVALUATE
        ~Give(\([0-9]+\),\([0-9]+\))~
        BEGIN
          SET "RESULT" = ("%MATCH1%" + "%MATCH2%") / 2
        END
        ~Take(%RESULT%)~
  \end{verbatim}
  This \ttref{COPY} \ttref{TP2 Action} would replace \t{Give(10,20)} with
  \t{Take(15)}.
   optcase allows you to decide if the matching is case-sensitive or not.  \\


  or & \DEFINE{ADD!MAP!NOTE} xCoord yCoord color \ttref{String} &
    If the file currently being patched is an \ttref{ARE} area file, this
    patch command adds a map note to it. Valid colors include: gray,
    violent, green, orange, red, blue, darkblue, lightgray.
    Example:
\begin{verbatim}
COPY_EXISTING ~ar0202.are~ ~override/ar0202.are~
  ADD_MAP_NOTE #123 #777 ~violet~
  ~This is my new map note!  Yippee!~
\end{verbatim}
    Special thanks to Japh for coding this feature.  \\

or & \DEFINE{ADD!KNOWN!SPELL} splName spellLevel spellType &
  When applied to a CRE file, this \ttref{patch} causes the given spell to
  be known. Note that spellLevel counts from 0 (e.g., you should say
  \t{\#2} for a third-level Fireball). Possible values for spellType are
  \t{priest}, \t{innate} and \t{wizard}. Example:
\begin{verbatim}
    COPY_EXISTING ~some.cre~ ~override/some.cre~
      ADD_KNOWN_SPELL ~SPPR314~ #2 ~priest~
      // Unholy Blight is now known as a 3rd level priest spell
\end{verbatim}
  Special thanks to Japh for coding this feature.  \\

or & \DEFINE{ADD!MEMORIZED!SPELL} splName spellLevel spellType
  \Ob \t{(} \ttref{value} \t{)} \Oe&
  When applied to a CRE file, this \ttref{patch} causes the given spell to
  be memorized one more time (or value times if specified).
  Note that spellLevel counts from 0 (e.g., you
  should say \t{\#2} for a third-level Fireball). Possible values for spellType
  are \t{priest}, \t{innate} and \t{wizard}. Example:
\begin{verbatim}
    COPY_EXISTING ~some.cre~ ~override/some.cre~
      ADD_MEMORIZED_SPELL ~SPPR314~ #2 ~priest~ ( 5 )
      // Unholy Blight is now memorized five times as 3rd priest
\end{verbatim} \\

or & \DEFINE{REMOVE!KNOWN!SPELL} splName \Slist &
  When applied to a CRE file, this \ttref{patch} causes all of the
  listed spells to be removed. Example:
\begin{verbatim}
    COPY_EXISTING ~aerie.cre~ ~override/aerie.cre~
      REMOVE_KNOWN_SPELL ~sppr101~ ~sppr102~
\end{verbatim}
  Special thanks to Japh for coding this feature.  \\

or & \DEFINE{REMOVE!MEMORIZED!SPELL} splName \Slist &
  When applied to a CRE file, this \ttref{patch} causes all of the
  listed spells to be removed from their memory. Example:
\begin{verbatim}
    COPY_EXISTING ~aerie.cre~ ~override/aerie.cre~
      REMOVE_MEMORIZED_SPELL ~sppr101~ ~sppr102~
\end{verbatim}
 \\

or & \DEFINE{SET!BG2!PROFICIENCY} String \ttref{value} &
	Removes all effects from the current CRE file that alter the proficiency specified by
	String (relative to Stats.ids). After that, if value is different from zero, add an effect
	to set said proficiency to value. \\

or & \DEFSYN{ADD!CRE!ITEM} itmName \#charge1 \#charge2 \#charge3 flags slot \Ob
\t{EQUIP} \Oe \Ob \t{TWOHANDED} \Oe &
  See the \ttref{ADD!CRE!ITEM} tutorial. \\

or & \DEFINE{REPLACE!CRE!ITEM} itmName \#charge1 \#charge2 \#charge3 flags slot \Ob
\t{EQUIP} \Oe \Ob \t{TWOHANDED} \Oe &
  If there's an item in the slot position, replace it; otherwise, process \ttref{ADD!CRE!ITEM} \\

or & \DEFINE{REMOVE!CRE!ITEM} itmName \Slist &
  Remove the listed items from the current creature. Does nothing if an item is not possessed.
	Multiple instances are removed. \\

or & \DEFINE{REMOVE!CRE!ITEMS} &
  Remove all items from the current creature. \\
or & \DEFINE{REMOVE!CRE!EFFECTS} &
  Remove all effects from the current creature. \\
or & \DEFINE{REMOVE!KNOWN!SPELLS} &
  Remove all known spells from the current creature. \\
or & \DEFINE{REMOVE!MEMORIZED!SPELLS} &
  Remove all memorized spells from the current creature. \\
or & \DEFINE{PATCH!SILENT} & makes WeiDU skip all messages; it's reenabled once a component
    is installed (or fails to), or a \ttref{PRINT}, \ttref{PATCH!PRINT},
    \ttref{VERBOSE} or \ttref{PATCH!VERBOSE} is found. \\
or & \DEFINE{PATCH!VERBOSE} & undoes the latest \ttref{SILENT} or \ttref{PATCH!SILENT} command. \\

or & \DEFINE{INNER!PATCH} buffString \t{BEGIN} \ttref{patch} \Slist \t{END} &
  Any WeiDU variables inside \t{\%}s within buffString are replaced by
  their values. All of the \ttref{patch}es given are evaluated as if the
  contents of the current file were buffString. Any modifications to
  buffString are thrown away (making this mostly useful for reads).
  Example:
  \begin{verbatim}
  INNER_PATCH "ABC" BEGIN
    READ_BYTE 0x2 "myvar"
  END 
  PATCH_PRINT "myvar is %myvar%" 
  \end{verbatim}
  This sequence will always print \t{myvar is 67} (since 67 is the ASCII
  code for \t{C}). \\

or & \DEFINE{INNER!PATCH!SAVE} savevar buffString \t{BEGIN} \ttref{patch} \Slist \t{END} &
  As with \ttref{INNER!PATCH}, except that any modifications to buffString are stored inside
  savevar.
  Example:
  \begin{verbatim}
  SPRINT foo "ABC"
  INNER_PATCH_SAVE bar "%foo%" BEGIN
    WRITE_BYTE 0x2 65
  END
  PATCH_PRINT "foo is %foo%, bar is %bar%"
  \end{verbatim}
  This sequence will always print \t{foo is ABC, bar is ABA } (since 65 is the ASCII
  code for \t{A}). \\


or & \DEFINE{INNER!PATCH!FILE} resource \t{BEGIN} \ttref{patch} \Slist \t{END} &
  Any WeiDU variables inside \t{\%}s within resource are replaced by
  their values. If the resulting resource is present in the game or in the
  override folder, the \ttref{patch}es given are evaluated as if the
  current file were that resource. If not, nothing happens. Any
  modifications to that resource are thrown away (making this mostly useful
  for reads).
  Example:
  \begin{verbatim}
  INNER_PATCH_FILE "SW1H01.ITM" BEGIN
    READ_BYTE 0x1 "myvar"
  END 
  PATCH_PRINT "myvar is %myvar%" 
  \end{verbatim}
  This sequence will always print \t{myvar is 84} (since 84 is the ASCII
  code for \t{T} and \ttref{SW1H01.ITM} starts with \t{ITM}). \\

or & \DEFSYN{INNER!ACTION} \t{BEGIN} \ttref{TP2 Action} \Slist \t{END} & 
  See the \ttref{INNER!ACTION} tutorial, but loosely the current
  \ttref{COPY} is paused, the given \ttref{TP2 Actions} are executed, and
  then the current \ttref{COPY} is resumed. \emph{Note that an
  \ttref{INNER!ACTION} should never modify a file that is being modified by
  the current action. For example, never put \t{APPEND ~foo.2da~} inside of
  \t{COPY!EXISTING ~foo.2da~}. More formally, if the inner action and the
  outer action both modify the same file, the results are undefined.}\\

or & \DEFINE{DECOMPRESS!REPLACE!FILE} start length uncompressedlength &
	Decompress (ZLIB) the \verb/start...start+length-1/ portion of the current
	file (requires to specify the uncompressed length as well). The result overwrites
	the current file. It's a synonym for
	\verb+DECOMPRESS!INTO!FILE start length uncompressedlength 0 BUFFER!LENGTH+
\\
or & \DEFINE{DECOMPRESS!INTO!FILE} start length uncompressedlength overwritefrom
  overwriteto &
	Decompress (ZLIB) the \verb/start...start+length-1/ portion of the current
	file (requires to specify the uncompressed length as well). The result overwrites
	the overwritefrom...overwriteto-1 portion of the current file.
\\
or & \DEFINE{DECOMPRESS!INTO!VAR} start length uncompressedlength varName &
	Decompress (ZLIB) the \verb/start...start+length-1/ portion of the current
	file (requires to specify the uncompressed length as well). The result is stored
	into varName.
\\

or & \DEFINE{COMPRESS!REPLACE!FILE} start length level &
	Compress (ZLIB) the \verb/start...start+length-1/ portion of the current
	file (level is 0 to 9; 0 means don't compress, 1 is fastest compression, 9 is best
	compression). The result overwrites
	the current file. It's a synonym for
	\verb+DECOMPRESS!INTO!FILE start length uncompressedlength 0 BUFFER!LENGTH+
\\
or & \DEFINE{COMPRESS!INTO!FILE} start length level overwritefrom
  overwriteto &
	Compress (ZLIB) the \verb/start...start+length-1/ portion of the current
	file (level is 0 to 9; 0 means don't compress, 1 is fastest compression, 9 is best
	compression). The result overwrites
	the overwritefrom...overwriteto-1 portion of the current file.
\\
or & \DEFINE{COMPRESS!INTO!VAR} start length level varName &
	Compress (ZLIB) the \verb/start...start+length-1/ portion of the current
	file (level is 0 to 9; 0 means don't compress, 1 is fastest compression, 9 is best
	compression). The result is stored into varName.
\\
\\

\DEFINE{when} & & A \ttref{when} clause gives you local control over when a 
  \ttref{COPY}, \ttref{COPY!EXISTING} or \ttref{APPEND!COL} happens. If the
  \ttref{COPY} or \ttref{COPY!EXISTING} contains multiple files, each one
  is checked against the \ttref{when} clauses separately.  \\
is & \DEFINE{IF!SIZE!IS} fileSize & True if the input file size is
fileSize. \\
or & \DEFINE{IF} \ttref{regexp} & True if the input file contains
\ttref{regexp}. \\
or & \DEFINE{UNLESS} \ttref{regexp} & False if the input file contains
\ttref{regexp}.  \\
or & \DEFINE{BUT!ONLY!IF!IT!CHANGES} & True only if the file is actually
changed by patching actions. Unlike all other \ttref{when} clauses, this
one is evaluated just before the result would be written out to the disk.  \\

\\

\DEFINE{offset} & & A \ttref{offset} is a normal \ttref{value}.
\\

\\


\DEFINE{value} & & An expression that evaluates to an integer. See
\ttref{--debug-value}. \\
is & integer & An absolute location or amount. You may format your numbers
in decimal, hex, octal or binary. Use 0x for hex, 0o for octal and 0b for
binary. \\
or & \t{(} \ttref{value} \t{)} & \\
or & \ttref{value} \t{+} \ttref{value} & Addition. \\
or & \ttref{value} \t{-} \ttref{value} & Subtraction. \\
or & \ttref{value} \t{*} \ttref{value} & Multiplication. \\
or & \ttref{value} \t{/} \ttref{value} & Division. Division by zero yields
the value zero. Briefly, fractions are dropped and the result is an integer
(so 11 / 6 = 1). More technically, ``this division rounds the real quotient
of its arguments towards zero'' -- see
\ahrefurl{{http://caml.inria.fr/pub/docs/manual-ocaml/libref/Pervasives.html}}
for more information. 
\\
or & \DEFINE{BYTE!AT} \ttref{offset} &
  The 8-bit value from the file at the given \ttref{offset}.  \\
or & \DEFINE{SBYTE!AT} \ttref{offset} &
  The 8-bit signed value from the file at the given \ttref{offset}.  \\
or & \DEFINE{SHORT!AT} \ttref{offset} &
  The 16-bit value from the file at the given \ttref{offset}.  \\
or & \DEFINE{SSHORT!AT} \ttref{offset} &
  The 16-bit signed value from the file at the given \ttref{offset}.  \\
or & \DEFINE{LONG!AT} \ttref{offset} &
  The 32-bit value from the file at the given \ttref{offset}.  \\
or & \DEFINE{SLONG!AT} \ttref{offset} &
  The 32-bit signed value from the file at the given \ttref{offset}.  \\
or & \ttref{value} \DEFINE{**} \ttref{value} & Exponentiation. The first
value is raised to the power of the second. This is done by converting both
to floating point numbers, calculating the exponent, and converting the
answer back to a 32-bit integer. If anything goes wrong the value zero is
returned or the result is undefined. \\
or & \ttref{value} \DEFSYN{**} \t{(} \ttref{value} \ttref{value} \t{)} &
  Fractional exponentation. \t{a ** (b c)} yields \t{a} raised to the 
  power of \t{(b/c)}. All of the internal operations are done in floating
  point. If anything goes wrong, zero is returned or the result is
  undefined. Example: 
  \begin{verbatim}
    SET x = 100 ** 2            
    SET y = 100 ** (1 2) // square root of 100 = 10
    SET z = 100 ** (1 3) // cube root of 100 = 4.64 
    PATCH_PRINT "w = %w%, x = %x%, y = %y%, z = %z%"
  \end{verbatim}
  yields \t{x = 10000, y = 10, z = 4}.  \\

or & \ttref{value} \DEFINE{=} \ttref{value} & \emph{Integer} Equality. If the two
values evaluate to equal integers, the result is 1. Otherwise, the result
is 0. See \ttref{STRING!COMPARE} for comparing \ttref{String}s. Synonym:
\DEFSYN{==}. 
\\
or & \DEFINE{NOT} \ttref{value} & Negation. If the value is 0, the result is 1.
Otherwise the result is 0. \\
or & \DEFINE{ABS} \ttref{Value} & Absolute value. If the value is >= 0, the result
is x. Otherwise the result is -x. \\
or & \ttref{value} \DEFINE{\textexcl=} \ttref{value} & \emph{Integer} Disequality. If
the two values evaluate to equal integers, the result is 0. Otherwise the
result is 1. See \ttref{STRING!COMPARE} for comparing \ttref{String}s. \\
or & \ttref{value} \DEFINE{OR} \ttref{value} & Disjunction. If either value is
non-zero, the result is 1. Otherwise, the result is 0. Synonym: \DEFSYN{\textpipe\textpipe}. \\
or & \ttref{value} \DEFINE{AND} \ttref{value} & Conjunction. If both values are
non-zero, the result is 1. Otherwise, the result is 0. Synonym: \DEFSYN{\&\&}. \\

or & \ttref{value} \DEFINE{BAND} \ttref{value} & Bitwise And.
\t{0b101 BAND 0b110 = 0b100}. Synonym: \DEFSYN{\&}.\\
or & \ttref{value} \DEFINE{BOR} \ttref{value} & Bitwise Or. 
\t{0b101 BOR 0b110 = 0b111}. Synonym: \DEFSYN{\textpipe}. \\
or & \ttref{value} \DEFINE{BXOR} \ttref{value} & Bitwise Exclusive Or. 
\t{0b101 BXOR 0b110 = 0b011}. Synonym: \DEFSYN{^^}.  \\
or & \DEFINE{BNOT} \ttref{value} & Bitwise Not. 
\t{BNOT 0b111 = 0b1111111111111111111111111111000}. Synonym: \DEFSYN{\verb+~+}. \\
or & \ttref{value} \DEFINE{BLSL} \ttref{value} & Bitwise Logical Shift Left. 
\t{0b101 BLSL 2 = 0b10100}. Synonym: \DEFSYN{<<}. \\
or & \ttref{value} \DEFINE{BLSR} \ttref{value} & Bitwise Logical Shift Right. 
\t{0b101 BLSR 2 = 0b1}. Synonym: \DEFSYN{>>}. \\
or & \ttref{value} \DEFINE{BASR} \ttref{value} & Bitwise Arithmetic Shift Right. 
This is an arithmetic shift: the sign bit of the first value is replicated
and inserted in the vacated bits. \t{0b101 BASR 2 = 0b1}.  \\

or & \ttref{value} \DEFSYN{>} \ttref{value} & If the first value is
greater than the second, the result is 1. Otherwise, the result is 0. \\
or & \ttref{value} \DEFSYN{>=} \ttref{value} & If the first value is
greater than or equal to the second, the result is 1. Otherwise, the result
is 0. \\
or & \ttref{value} \DEFSYN{<} \ttref{value} & If the first value is
less than the second, the result is 1. Otherwise, the result
is 0. \\
or & \ttref{value} \DEFSYN{<=} \ttref{value} & If the first value is
less than or equal to the second, the result is 1. Otherwise, the result
is 0. \\
or & \ttref{value} \DEFSYN{?} \ttref{value} \t{:} \ttref{value} &
An expression-valued conditional.  If the first value is not 0 then the
second value is evaluated and returned, otherwise the third value is
evaluated and returned.  \\

or & \ttref{String} \DEFINE{STRING!COMPARE} \ttref{String} &
This is legacy synthax for \ttref{STRING!EQUAL}:
This expressione valuates to 0 if and only if its two string arguments are
equal (have the same length and the same contents). Otherwise it will evaluate
to a negative or positive integer, depending on whether the first string argument
would sort lexicographically before or after the second string argument.
\ttref{variable}s within the strings (e.g., ``\t{\%mykit\%}'') are replaced by
their values. Note that variables that you want expanded \emph{must} be put in \%'s,
otherwise the raw text will be used.
You may use \DEFINE{STR!CMP} as a synonym for \ttref{STRING!COMPARE}. This
function works just like C's \t{strcmp}.
Note also that \ttref{STRING!EQUAL} and \ttref{STRING!COMPARE} are similar,
but \ttref{STRING!EQUAL} has more intuitive return values. \\

or & \ttref{String} \DEFINE{STRING!COMPARE!CASE} \ttref{String} &
This is legacy synthax for \ttref{STRING!EQUAL!CASE}:
As \ttref{STRING!COMPARE}, but the comparison ignores case. That is,
\t{"ANOMEN"} and \t{"aNoMeN"} are considered equal.\\

or & \ttref{String} \DEFINE{STRING!EQUAL} \ttref{String} &
This expressione valuates to 1 if and only if its two string arguments are
equal (have the same length and the same contents), otherwise it values to 0.
\ttref{variable}s within the strings (e.g., ``\t{\%mykit\%}'') are replaced
by their values.
Note that variables that you want expanded \emph{must} be put in \%'s,
otherwise the raw text will be used.
Note also that \ttref{STRING!EQUAL} and \ttref{STRING!COMPARE} are similar, 
but \ttref{STRING!EQUAL} has more intuitive return values. \\

or & \ttref{String} \DEFINE{STRING!EQUAL!CASE} \ttref{String} &
As \ttref{STRING!EQUAL}, but the comparison ignores case. That is,
\t{"ANOMEN"} and \t{"aNoMeN"} are considered equal.\\

or & \ttref{String} \DEFINE{STRING!MATCHES!REGEXP} \ttref{String} &
As \ttref{STRING!COMPARE!CASE}, but the second string is treated as a
\ttref{regexp}. Thus \t{"AR1005" STRING!MATCHES!REGEXP "AR[0-9]+"}
evaluates to 0 (``no difference''). You may use
\DEFINE{STRING!COMPARE!REGEXP} as a synonym. \\                           

or & \ttref{String} \DEFINE{STRING!CONTAINS!REGEXP} \ttref{String} &
As \ttref{STRING!MATCHES!REGEXP}, but it evaluates to 0 if the first string
contains the second \ttref{regexp}. Thus \t{"AR1005" STRING!CONTAINS!REGEXP
"[w-z]"} evaluates to 1 (``mismatch''). \\

or & \DEFINE{GAME!IS} \ttref{String} & Returns true if the IE game variant
is one from the String, otherwise it returns false. String is a list of
whitespace separated entries, chosen between (case doesn't matter)
\verb+bg2=soa, tob, iwd2, pst, bg1, totsc, iwd=iwd1, how, tolm=totlm, tutu, tutu_totsc, bgt+.
In the list, \verb+bg2=soa+ means that bg2 and soa are synonyms. Please note that
the items in list are defined to be mutually exclusive (except tob will detect both plain tob
and tob with bgt installed, for legacy purposes), so bg2 will detect a
soa-only game, without either tob or tutu installed. As such, a mod which is
useable with any flavor of bg2 and any flavor of tutu would contain
\verb+REQUIRE_PREDICATE GAME_IS ~bg2 tob tutu tutu_totsc~+ . \\

or & \DEFINE{IDS!OF!SYMBOL} (File \ttref{String}) &
Will return the number associated with String in File.ids,
or -1 if String is not associated in File.ids. \\

or & \DEFINE{VARIABLE!IS!SET} \ttref{String} &
Returns true if the variable String is set (there's a variable called either
\verb+String+ or \verb+%String%+, regardless of wether it is a string or an
integer).  \\

or & \DEFSYN{VARIABLE!IS!SET} \ttref{String} &
Returns true if the variable String is set to an integer (there's a variable called either
\verb+String+ or \verb+%String%+ with integer value).  \\

or & \DEFINE{MOD!IS!INSTALLED} modTp2Name modComponent &
Returns true if the modComponent of modTp2Name is installed. The synthax
is the same as with \ttref {REQUIRE!PREDICATE}.  \\

or & \DEFINE{STATE!WHICH!SAYS} \ttref{text} \t{FROM} \ttref{String} &
  Returns:
  \begin{enumerate}
  \item fails the installation if it can't evaluate the text (an \t{@x} reference out of bounds)
  \item -3 if the text is not currently in the tlk or in the list of strings
    to add
  \item -2 if the text is spoken (= \verb+SAY ~Foo~+) at least twice in the file String
    (String must be an in-game or in-override .dlg file)
  \item -1 if the text is never spoken in the file String
    (String must be an in-game or in-override .dlg file)
  \end{enumerate}
  otherwise it returns the number of the state in which text is spoken in the file String
    (String must be an in-game or in-override .dlg file). \t{@x} references are taken from
    the loaded TRA files (the ones defined in the \ttref{Language} part).
\\

or & \DEFSYN{STATE!WHICH!SAYS} \t{\ttref{value} IN \ttref{String}1 FROM \ttref{String}2} &
  As above, except that \t{@x} references are taken from
    the String1 tra file. In particular, one \verb+%s+ in String1 is expanded to the list 
    of directories; for example (as of Sola v102), \verb+solarom/%s/epilogue.tra+ would match
\begin{verbatim}
    solarom/american/epilogue.tra
    solarom/french/epilogue.tra
    solarom/german/epilogue.tra
    solarom/italian/epilogue.tra
    solarom/polski/epilogue.tra
    solarom/portuguese/epilogue.tra
    solarom/russian/epilogue.tra
\end{verbatim}
\\

or & \DEFINE{RANDOM} ( \ttref{value} \ttref{value} ) &
A random-number generator. The first \ttref{value} is the lower bound, the
second value is the upper bound. A random integer between the lower bound
and the upper bound (inclusive) is returned. Thus \t{RANDOM(3 5)} can
return 3, 4 or 5. If the lower bound is greater than the upper bound, zero
is returned. See also \ttref{RANDOM!SEED}. \\

or & \DEFINE{BUFFER!LENGTH} &
Returns the length of the string currently being patched, or 0 if outside of
a patch expression. \\

or & \DEFINE{STRING!LENGTH} \ttref{String} &
Returns the length of the argument \ttref{String} (after variable evaluation). \\

or & \DEFINE{FILE!CONTAINS} fileName \ttref{regexp} & Evaluates to 1 if
the file \t{fileName} contains the regular expression \ttref{regexp}
and 0 otherwise. Case is ignored. \\

or & \DEFINE{FILE!CONTAINS!EVALUATED} ( fileName varsRegexp ) &
  First, all WeiDU variables enclosed in \t{\%}s in \t{varsRegexp} and
  \t{fileName} are
  substituted. The expression is 1 if the resulting \ttref{regexp} occurs
  in \t{fileName} and 0 otherwise. If \t{fileName} does not exist or has
  size 0, the result is 0. The comparison ignores case.  See also
  \ttref{FILE!CONTAINS}. Example:
\begin{verbatim}
COPY_EXISTING_REGEXP ~.*\.CRE~ ~override~
  READ_BYTE   0x273 class
  READ_ASCII  0x280 deathvar
  PATCH_IF (class = 14) AND // class 14 = CLERIC_MAGE
           (NOT FILE_CONTAINS_EVALUATED(~pdialog.2da~
                                        ~%deathvar%~))
    THEN BEGIN
      ADD_CRE_ITEM ~POTN08~ #10 #10 #10 ~IDENTIFIED~ ~INV15~
    END
  BUT_ONLY_IF_IT_CHANGES
\end{verbatim}
The example gives ten healing potions to all cleric-mages who cannot join
the party. Notably it excludes Aerie
since she has the death variable \t{Aerie} and \t{pdialog.2da} contains
\t{AERIE}.  \\

is & \DEFINE{FILE!EXISTS} fileName & Evaluates to 1 if the file exists in the
filesystem and has non-zero size (or the bif file is referenced inside
the chitin.key) and evaluates to 0 otherwise. \\
or & \DEFINE{FILE!EXISTS!IN!GAME} fileName & Evaluates to 1 if the file
exists as a game resource and has non-zero size. Evaluates to 0 otherwise.
\ttref{BIFF}s and the \t{override} directory are searched in the standard
manner. Evaluates to 0 for a file that does not exist but has been
\ttref{ALLOW!MISSING}'d.\\
or & \DEFINE{FILE!MD5} fileName md5sum & Evaluates to 1 if the file exists
and has the given MD5 checksum. Evaluates to 0 otherwise. Two different
files are exceptionally unlikely to have the same MD5 checksum. In any
event, the discovered checksum is printed to the log. If the file does not
exist, it evaluates to 0. \\
or & \DEFINE{FILE!SIZE} fileName fileSize & Evaluates to 1 if the
size of the file \t{fileName} is exactly \t{fileSize}. Evaluates to 0
otherwise. \\

or & \t{\%}\ttref{variable}\t{\%}   &
    The value of the \ttref{variable} is used. \\

or & \DEFSYN{EVALUATE!BUFFER} \ttref{variable} &
    User variables inside the given string are evaluated one additional
    time. You may prepend \ttref{EVALUATE!BUFFER} when a \ttref{value} is
    called for and you would normally use a string. You may also use it for
\ttref{SET} and \ttref{SPRINT} statements. Example:
\begin{verbatim}
    SPRINT x ~y~
    SET y = 5
    SPRINT z EVALUATE_BUFFER ~tricky %%x%%~
    SET EVALUATE_BUFFER "%x%" += 77
    PATCH_PRINT "y is %y% ; z is %z%"
\end{verbatim}
    This prints out \t{y is 82 ; z is tricky 5}. You may also do hackery like
    \t{FILE!SIZE "myfile" "\%\%indirection\%\%"}. Be very careful with this
    feature. \\
or & \verb+$array(index list)+ &
    The so-called \ttref{array construct}. See the tutorial.
\\  

or & \t{\%}\DEFINE{WEIDU!ARCH}\t{\%} & The special variable \t{WEIDU!ARCH}
is set to either \t{"x86"} or \t{"mac"} at WeiDU startup and can be used to
determine the underlying system architecture. \\

or & \t{\%}\DEFINE{WEIDU!OS}\t{\%} & The special variable \t{WEIDU!OS} is set to either
\t{"win32"} or \t{"osx"} or \t{"unix"} at WeiDU startup and can be used to
determine the underlying operating system. \\

or & \t{\%}\DEFINE{COMPONENT!NUMBER}\t{\%} & The special variable \t{COMPONENT!NUMBER}
is set to the number of the component being installed. \\

or & \t{\%}\DEFINE{INTERACTIVE}\t{\%} & The special variable \t{INTERACTIVE}
is set to 1 if the install is being done interactively (IE you launched setup-mymod.exe and you're
installing mymod), or is set to 0 if the install is being done non-interactively (IE you launched
setup-mymod.exe and now weidu is reinstalling othermod due to the domino uninstall and reinstall). \\

or & \ttref{variable} &
    The value of the \ttref{variable} is used.
  In a \ttref{patch} \ttref{value}, you may use either \t{\%myvar\%} or
  \t{myvar} to get the value of a variable, provided that your variable's
  name is not the same as a WeiDU syntactic keyword or known
  \ttref{constant}. Also note that while it is common to ``call out''
  variables by putting quotation marks around them, this is not necessary
  if the variable is unambiguous. Thus the following three \ttref{patch}es
  are all equivalent:
\begin{verbatim}
  SET "x" = "%y%" + "%z%"       // these all
  SET "x" = "y" + "z"           //    do the
  SET x = y + z                 //  same thing
\end{verbatim} \\

or & \t{NAME1}   & The offset within an infinity engine resource where the unidentified general name (e.g., "Battle Axe") is stored. \\
or & \t{NAME2}   & The offset within an infinity engine resource where the identified general name (e.g., "K'logarath +4") is stored. \\
or & \t{UNIDENTIFIED!DESC}  & The offset within an infinity engine resource where the unidentified description (e.g., "The hand axe or throwing axe is also known as a hatchet ...") is stored. \\
or & \t{IDENTIFIED!DESC}    & As above ... ("Clans have gone to war to possess K'log...")\\
or & \t{BIO}                & As above ... NPC Biography\\
or & ...        & Almost everything in \t{SNDSLOT.IDS} or \t{SOUNDOFF.IDS}
works as well. \\

\\

\DEFINE{variable} & & A variable is a textual name that holds a
\ttref{value}. Variables are usually set with \ttref{READ!BYTE},
\ttref{SET} or \ttref{SPRINT}. \\
is & string & You may name the variable whatever you like, but stay
away from the special characters used in \ttref{regexp}s. When you want to
obtain the value of a variable, enclose it in \t{\%}s.

\

Example: If a file contains the two binary integers 33 and 77, then after
executing:

\begin{verbatim}
READ_LONG   0 ~myvar~
WRITE_LONG  4 ( ~%myvar%~ + 11 )
\end{verbatim}

The file will contain the two binary integers 33 and 44. \\

\end{tabular}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{WeiDU \ttref{TP2} Tutorials}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\label{TP Tutorials}

Note: it's advised to read these tutorials in the order they were written,
as often a tutorial depends on contents explained in the tutorials before
it. If the tutorial-writer is kind enough, they'll state dependancies while
introducing the subject.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{\ttref{COPY!EXISTING!REGEXP}} 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
This tutorial was thoughtfully provided by Japheth.

The purpose of \ttref{COPY!EXISTING} and \ttref{COPY!EXISTING!REGEXP} is to
patch a file for patching. It will grab the file out of the \ttref{BIFF}s,
or if an \t{override} version exists, it will grab it out of the override
folder.

\ttref{COPY!EXISTING!REGEXP}, \ttref{EXTEND!BOTTOM!REGEXP} and
\ttref{EXTEND!TOP!REGEXP} can be potentially powerful actions if you need
to make some changes to a certain set of files all in one shot.

Consider this example for \ttref{COPY!EXISTING!REGEXP}:

In my mod I want to make it so that all 1-handed swords only do D6 damage,
rather than the varying damages they do in SOA.  To do this with the
"normal" \ttref{COPY!EXISTING}, I would have to write out all the one
handed swords like this:

\begin{verbatim}
COPY_EXISTING ~sw1h01.itm~ ~override/sw1h01.itm~
              ~sw1h02.itm~ ~override/sw1h02.itm~
              etc...
\end{verbatim}

That could take a lot of time to do.  Using \ttref{COPY!EXISTING!REGEXP} I
can minimize writing 70+ lines of code into 3 lines of code.  Take a look
at this:

\begin{verbatim}
COPY_EXISTING_REGEXP ~sw1h..[^abc].*itm~ ~override~
  WRITE_LONG 0x88 "6"
  WRITE_LONG 0x8a "1" 
\end{verbatim}

I'll explain how the \ttref{regexp} wildcards in the above example work:
I want to avoid copying over the files sw1h54a.itm, sw1h54b.itm and
sw1h54c.itm because they are the three components that make up the
Equalizer, and because of that, the offsets of 0x88 and 0x8a won't work
because they don't exist in those items.

To find which offset to \ttref{WRITE!LONG} at I opened up Near Infinity,
(found at \ahrefurl{\url{http://www.idi.ntnu.no/~joh/ni/}})
and looked up the offset with
it.  Fortunately for us, the offset is the same in all items, so we can
make the changes in one shot. {\tt \ttref{WRITE!LONG} 0x88 "6"} is telling
WeiDU to write the value of 6 at offset 88 hex.  Similarly, {\tt
\ttref{WRITE!LONG} 0x8a "1"} is telling WeiDU to write the value 1 at
offset 8a hex.

The 6 is the dice size and the 1 is the number of dice.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{\ttref{EXTEND!TOP!REGEXP}} 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
This tutorial was thoughtfully provided by Japheth.

Let's take this situation that I was in:

I am making a Hirelings mod, and in order to get non party NPC's to
transition from area to area, I needed to make use of a combination of
MakeGlobal(), InMyArea(O:Object*) and MoveGlobalObject(O:Object*,O:Target*).  

I originally put the script that moves them from area to area into
baldur.bcs (this script is constantly running in the game), but for some
strange reason, the cre's wouldn't move to smaller areas, only the large
"main" areas.  (Like The Docks, Temple District, Slums, etc.)  So I
figured, "Huh, guess I'm going to have to put the script in every area
script".  (Area scripts are scripts that are assigned to areas that are ran
while you are in the area.  Pretty obvious right?)

Now, writing the code to \ttref{EXTEND!TOP} this little script into every area
script would of taken quite a while, and well, rather than do that, I
humbly requested Wes to implement the \ttref{regexp} feature of 
\ttref{EXTEND!TOP} and \ttref{EXTEND!BOTTOM}, and he obliged.  (My penance
for that request is writing the docs you are reading right now.)

So now with Wes' help, I could \ttref{EXTEND!TOP} to every area in 1 fell
swoop.  If you were to open up NI and expand the \ttref{BCS} tree, you
would see a whole crapload of scripts that begin with the prefix AR.  These
are the area scripts I mentioned before.  They go from
AR0014 to AR6400.  So now, using \ttref{regexp}, here is how you would
extend the script to the top of every area script:

\begin{verbatim}
EXTEND_TOP_REGEXP ~ar[0-6].*bcs~ ~pathtoscript/patch.bcs~
\end{verbatim}

So there we are, instead of 100+ lines of code, I minimized it to 1 lines.
Now, if you are understanding regexp at all, you probably are going ``Hey
wait, why didn't you just go {\tt \ttref{EXTEND!TOP!REGEXP} "ar.*bcs"
"pathtoscript/patch.bcs"} ?''  Well, infact, I did do that at first, but I
forgot to account that there are other ``normal'' scripts that begin with AR.
So, I had to write it so that the \ttref{regexp} had the number after the
initial AR so that WeiDU would know only to patch the script to area files.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{\ttref{READ!BYTE} and \ttref{PATCH!IF} (Last update: v189)}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

This tutorial was thoughtfully provided by Japheth, and shamelessly edited
by Bigg to use PATCH!IF rather than IF!EVAL.

\ttref{READ!BYTE}, \ttref{READ!SHORT} and \ttref{READ!LONG} can be
potentially powerful functions when used in conjunction with
\ttref{PATCH!IF}.

Here's a brief demonstration.

The scenario: I want to make all longswords in the game do 1D6 damage,
rather than their normal 1D8. To do that manually would be a pain, so why
not use the great feature of \ttref{READ!BYTE}/LONG/SHORT?

Here's how it's done.

First of all, we need to copy all the items so they are ready to be patched. 
Here's how we do that:

\begin{verbatim}
COPY_EXISTING_REGEXP ~.*\.itm~ ~override~
\end{verbatim}

All this does is copy all files with a .itm extension to the override folder.

Next, we read the item category offset into a variable. We'll use the variable 
name "type".

\begin{verbatim}
READ_BYTE "0x1c" "type"
\end{verbatim}

I found the offset by looking at an item file in Near Infinity. The
variable "type" can really be anything, it's just what I've chosen.

We should edit the item only if the item is really a longsword:

\begin{verbatim}
PATCH_IF ("%type%" = "0x14") BEGIN
\end{verbatim}

So, to call back our variable, you just wrap it with \% signs. 0x14 is just
the value for longsword. If you look at the Category offset in Near
Infinity (which is 0x1c), and scroll down in the box below, you'll see
Longsword (20).  The 20 just represents the decimal value. 0x14 is just 20
in hexadecimal.

Now that we're done reading that into a variable and doing the checks, we can now
\ttref{WRITE!SHORT} the values we want to give our new longswords. Namely,
6 for damage and 1 for dice size. (Or, 1D6 for simplicity sake.)

\begin{verbatim}
WRITE_SHORT 0x88 6
WRITE_SHORT 0x8a 1
\end{verbatim}

0x88 is the offset for dicesize and 0x8a is the offset for the number of
dice.  Again, I found these offsets using Near Infinity beforehand.

\begin{verbatim}
END
BUT_ONLY_IF_IT_CHANGES
\end{verbatim}

Finally, we close the BEGIN that was after PATCH!IF and tell WeiDU not to copy
the item if it didn't change (IE, if it wasn't a long sword).

So, to loop through the logic again, this is what we're saying:

If the category is longsword, make the dice size 6 and the dice damage 1. If 
there are no changes, ignore the file and don't copy it over.

And that's it. Now all items with the category Longsword will have 1D6 as their 
dice damage. Pretty neat eh? Obviously you can do many, many other types of 
thing with these functions. So go ahead and experiment.

Here's the full code:

\begin{verbatim}
COPY_EXISTING_REGEXP ~.*\.itm~ ~override~
  READ_BYTE     "0x1c" "type"

  PATCH_IF ("%type%" = "0x14") BEGIN
    WRITE_SHORT   0x88 6
    WRITE_SHORT   0x8a 1

  END
BUT_ONLY_IF_IT_CHANGES
\end{verbatim}

Oh yeah, and if you're going "But I don't know when to \ttref{READ!SHORT}
or \ttref{WRITE!LONG}. It's so confusing," don't worry, cause
it kind of is if you've never worked with bytes before. Here's a very brief
synopsis.

Use READ/WRITE!SHORT for anything that is two bytes. You can determine this
easily by looking at the field you want to change in NI and subtracting the
next listed field's offset from the offset of the field you want to change.

For example, if I wanted to change Bodhi's Max HP here's what I would do.
First look at her creature file in NI. (She has many, but for the sake of
argument, we'll use bodhi.cre). If you look at the Max HP field, it says
it's offset is 26h. The next field in the creature file is Animation ID,
which is 28h. So, subtracting 28h from 26h gives you 2h. The perfect
\ttref{WRITE!SHORT} size.

Use READ/WRITE!LONG for anything that is 4 bytes. Use the above example to
figure this out as well.

Use READ/WRITE!BYTE for anything that is one byte. Again, use the
above example to figure this out.

Use \ttref{WRITE!ASCII} for things like death variable, dialogues, scripts,
etc. Note, that if you're \ttref{WRITE!ASCII}ing to say, the death
variable, and the previous death variable entry is longer than the one
you're writing, then you'll have spillover after \ttref{WRITE!ASCII}. To
avoid this, embed a null character at the end of your string. So, if I have 
\begin{verbatim}
WRITE_ASCII 0x280 ~Guy~
\end{verbatim} 
I would want to put a null character right after the y in Guy. You can do
this by using a hex editor and inserting 00 after the y.

These are by no means "hard and fast" rules, but generally they ring true.
However, there could be times when you need to \ttref{WRITE!LONG} twice if
the field is 8 bytes long, etc.

Also, if you tried to run the template, you'd have noticed that it didn't work
correctly. That's because there are some corrupt files in the key (that is,
files of size 0). To avoid that, WeiDU gives us the \verb+%SOURCE_SIZE%+ variable,
which is set to the original file size. We can simply check that the file is
large enough (using either NI or the IESDP, we see that a basic itm file must
have at least 0x72 bytes long, so we can check that before doing anything:

\begin{verbatim}
COPY_EXISTING_REGEXP ~.*\.itm~ ~override~
  PATCH_IF ("%SOURCE_SIZE%" > "0x71") BEGIN
    READ_BYTE     "0x1c" "type"
  
    PATCH_IF ("%type%" = "0x14") BEGIN
      WRITE_SHORT   0x88 6
      WRITE_SHORT   0x8a 1
  
    END
  END
BUT_ONLY_IF_IT_CHANGES
\end{verbatim}

Again, we instruct WeiDU to not do a thing if the file is not large enough.

And that, as they say, is that.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{\ttref{value}s and expressions  (Last update: v189)}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
This tutorial was thoughtfully provided by Japheth, and shamelessly edited
by Bigg to use PATCH!IF rather than IF!EVAL.

Using expressions with WeiDU can get quite complex, however the power they
give you is more than worth the effort in learning how to use them.

Say, for instance, that you want to give a creature file a shield that
doesn't have one originally.  The old way to do this would be to add the
item to the creature file using Near Infinity or ShadowKeeper and then copy
that creature file over upon installation of your mod.  However, now that
INSERT/DELETE!BYTES and READ/WRITE!BYTE/LONG/SHORT take expressions, we can
do this "on the fly" when installing your mod.

The benefits of doing it this way should be obvious.  Now you no longer
have to overwrite someone else's modifications to that creature file.  You
can simply add your shield and leave their modifications intact.  (Unless
of course *they* also decided to give the exact same creature a shield.
And if that's the case, the shield you specify won't be used because of our
\ttref{PATCH!IF} statement.)

Anyways, on to the example.  I'll use acolyte1.cre as my example creature.

The first thing we want to do is copy the creature over so it's ready for 
patching, and ensure it isn't corrupt.  That's easy to do using a simple \ttref{COPY!EXISTING}
statement:

\begin{verbatim}
COPY_EXISTING ~acolyte1.cre~ ~override/acolyte1.cre~
PATCH_IF ("%SOURCE_SIZE%" > "0x2d3") BEGIN
\end{verbatim}

Next, we need to read in the offsets so we know where to insert our bytes and 
where to update our number of items.  I figured out these offsets by simply 
viewing the creature file in Near Infinity.

The offsets we need to read in are the item slots offset, the items offset and 
the number of items.  This is how we do it:

\begin{verbatim}
READ_LONG "0x2bc" "itemsoffset"
READ_LONG "0x2b8" "itemslot"
READ_LONG "0x2c0" "#items"
\end{verbatim}

"itemsoffset", "itemslot" and "\#items" can be anything you choose, but I
would name them something that's easy to remember because we'll be using
them later.

Next, we're going to read in the shield slot to make sure that it's empty.
We do this by taking the "itemslot" variable and adding 0x04 to it which we
know is always going to be the shield slot.  (You can verify this by
looking at a creature file in NI.  If you look at the offset 0x2b8 it will
have the offset for item slots.  If you add 0x04 to that number, it should
equal the offset for the shield slot.)

This is done like so:

\begin{verbatim}
READ_SHORT ("%itemslot%" + 0x04) "shield"
\end{verbatim}

Note: To access your variables after they've been read, you always have to
wrap them in percent signs.

We want to tell WeiDU only to do this if the shield slot is
*empty*.  This is where \ttref{PATCH!IF} comes in handy.  The way a creature
file is setup is that if a slot is set to -1, it means it's empty.  WeiDU
doesn't read unsigned bytes, so if the value is indeed -1, it will come out
as 65535 as the value.  So, this is the statement we use to tell WeiDU only
to execute all of the above code if "\%shield\%" is -1:

\begin{verbatim}
PATCH_IF ("%shield%" = "65535") BEGIN
\end{verbatim}

Now, we have to update the shield slot to reflect that it's the newest item
out of all the items the creature has equipped.  This is a bit misleading
because in the slots part of the creature file, they count from 0.  So, all
we need to do is take the value of 0x2c0 (The number of items the creature
has.) and use that as our value to write.

To do that, this is what we do:

\begin{verbatim}
WRITE_SHORT ("%itemslot%" + 0x04) "%#items%"
\end{verbatim}

Now we have to update the itemslot offset value to reflect the fact that
we've added a new item to the creature.  An item is *always* 0x14 bytes.
We already know the offset of the itemslot offset and we've already read
it's value, so all we need to do is add 0x14 to it

\begin{verbatim}
WRITE_LONG 0x2b8 ("%itemslot%" + 0x14)
\end{verbatim}

The last step before inserting our bytes is to increase the \#items by 1 to
reflect the fact that we've added an item to the creature.  We've already
read in the number of items into "\%\#items\%" so this is dead easy:

\begin{verbatim}
WRITE_LONG 0x2c0 ("%#items%" + 1)
\end{verbatim}

Now we can actually insert out bytes.  To do this we have to take the
number of items that the creature has multiplied by 0x14 and add that to
the itemsoffset.  (The reason we can't just insert it right at
"\%itemsoffset\%" is because it would mess up the order of the items in game.
If we inserted the shield at the beginning, then the creature would more
than likely have some items equipped in some weird places in the game.)

This is done like so:

\begin{verbatim}
INSERT_BYTES ("%itemsoffset%" + "%#items%" * 0x14) 0x14
\end{verbatim}

Now we can actually write our information for our item.  You don't need the
.itm extension at all, just everything before the .itm.  And again, since
the item entry is always the first entry in an item field on a creature
file, we just need to use the same formula as above because we'll be
writing at the same offset that we inserted our bytes at:

\begin{verbatim}
WRITE_ASCII ("%itemsoffset%" + "%#items%" * 0x14) ~shld01~
\end{verbatim}

If you wanted to add a magical shield to the creature file and wanted it to
be already identified in the slot, then you would simply have to add 0x10
bytes to the previous expression and \ttref{WRITE!LONG} the value of 1.
Like this:

\begin{verbatim}
WRITE_LONG ("%itemsoffset%" + ("%#items%" * 0x14) + 0x10) 1
\end{verbatim}

Finally, we close the PATCH!IF statements and add BUT!ONLY!IF!CHANGES.

\begin{verbatim}
    END
  END
BUT_ONLY_IF_IT_CHANGES
\end{verbatim}

Here's the full code:

\begin{verbatim}
COPY_EXISTING ~acolyte1.cre~ ~override/acolyte1.cre~
  PATCH_IF ("%SOURCE_SIZE%" > "0x2d3") BEGIN
    READ_LONG "0x2bc" "itemsoffset"
    READ_LONG "0x2b8" "itemslot"
    READ_LONG "0x2c0" "#items"
    READ_SHORT ("%itemslot%" + 0x04) "shield"
    
    PATCH_IF ("%shield%" = "65535") BEGIN

      WRITE_SHORT ("%itemslot%" + 0x04) "%#items%"
      WRITE_LONG 0x2b8 ("%itemslot%" + 0x14)
      WRITE_LONG 0x2c0 ("%#items%" + 1)
      
      INSERT_BYTES ("%itemsoffset%" + "%#items%" * 0x14) 0x14
      
      WRITE_ASCII ("%itemsoffset%" + "%#items%" * 0x14) ~shld01~
    END
  END
BUT_ONLY_IF_IT_CHANGES
\end{verbatim}

Note that you can use the \ttref{PRINT} action in a \ttref{tp2} to debug
your code as well.  Like this:

\begin{verbatim}
COPY_EXISTING ~acolyte1.cre~ ~override/acolyte1.cre~
  PATCH_IF ("%SOURCE_SIZE%" > "0x2d3") BEGIN
    READ_LONG "0x2bc" "itemsoffset"
    READ_LONG "0x2b8" "itemslot"
    READ_LONG "0x2c0" "#items"
    READ_SHORT ("%itemslot%" + 0x04) "shield"
    
    PATCH_IF ("%shield%" = "65535") BEGIN

      WRITE_SHORT ("%itemslot%" + 0x04) "%#items%"
      WRITE_LONG 0x2b8 ("%itemslot%" + 0x14)
      WRITE_LONG 0x2c0 ("%#items%" + 1)
      
      INSERT_BYTES ("%itemsoffset%" + "%#items%" * 0x14) 0x14
      
      WRITE_ASCII ("%itemsoffset%" + "%#items%" * 0x14) ~shld01~
    END
  END
BUT_ONLY_IF_IT_CHANGES

PRINT ~The value of the items offset is %itemsoffset%~
\end{verbatim}

I should also mention that the above code for adding an item to a creature
file is "portable" in a sense.  You would only have to change a couple
things.  The changes that would have to be made are as follows:

\begin{enumerate}
\item Change acolyte1.cre to the actual creature that you want to modify
\item You'll have to change ("\%itemslot\%" + 0x04) to something else if you
are adding anything else but a shield.  You can figure this out by
subtracting the slot offset of the slot you want to modify from the item
slots offset.
\item You would need to change ~shld01~ to the item you are going to add.
\item You'd have to add your own flags if they need adding  (i.e.
Identified, Not Stealable, etc.).
\end{enumerate}

And that's the end of it.  All this can be a bit tricky, but as I mentioned 
above, it can be quite powerful as well.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{\DEFINE{ADD!STORE!ITEM} (Last Update: v192)}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
This tutorial and this feature were thoughtfully provided by Japheth. 

  Using ADD!STORE!ITEM is a relatively painless procedure. Consider this
  example: I want to add a new item to \t{ribald.sto} in BGII.  There were
  two ways of doing this before.

\begin{enumerate}
\item I could add the item to the store beforehand and then simply copy over
  the new store file upon installing my mod.

\item I could use WeiDU's \ttref{READ!BYTE} and \ttref{WRITE!BYTE} patch
      expressions to patch the item into the store while installing.
\end{enumerate}

  Now we can do \#2 rather easily thanks to ADD!STORE!ITEM.

  First off copy over the store file to set it up for patching as you
  normally would.

\begin{verbatim}
  COPY_EXISTING ~ribald.sto~ ~override/ribald.sto~
\end{verbatim}

  Next we issue the ADD!STORE!ITEM patch expression with the following
  arguments:

\begin{verbatim}
  ADD_STORE_ITEM "myitem" #10 #0 #0 ~IDENTIFIED~ #5
\end{verbatim}

  ``myitem'' is the name of the item file that we will want to appear in the
  store without it's .itm extension.
  \#10 is the first extension headers number of charges
  The two \#0s that follow are the second and third extension headers number
  of charges.
  ~IDENTIFED~ is the flag that we want on the item.  Here are the flags
  that you can use:

\begin{verbatim}
  IDENTIFIED
  UNSTEALABLE
  STOLEN
  IDENTIFIED&STOLEN
  IDENTIFIED&UNSTEALABLE
\end{verbatim}

  \#5 is the number of items that will be in stock.

  Pretty easy stuff right?

  You can also add an optional + after ADD!STORE!ITEM if you want to
  overwrite an item that already exists in the store.

  So, if we wanted to replace HAMM05.ITM in ribald.sto this is what we'd
  do:

\begin{verbatim}
  ADD_STORE_ITEM + ~hamm05~ #10 #0 #0 ~IDENTIFIED~ #5
\end{verbatim}

  One final note: remember to copy over your new item because
  ADD!STORE!ITEM doesn't do that part for you.

  So, a complete set of actions that would patch a store file and copy over
  the new item would look like this:

\begin{verbatim}
  COPY_EXISTING ~ribald.sto~ ~override/ribald.sto~
  ADD_STORE_ITEM ~myitem~ #10 #0 #0 ~IDENTIFIED~ #5

  COPY ~mymod/myitem.itm~ ~override/myitem.itm~
\end{verbatim}

  Note that you can also add a final optional string argument if you want
  the store to have unlimited copies of that item:

\begin{verbatim}
  ADD_STORE_ITEM ~myitem~ #10 #0 #0 ~IDENTIFIED~ #1 ~UNLIMITED~
\end{verbatim}

  That's about all there is to it.
  

Note that as of v188 you can specify the position of the item being added:
\begin{verbatim}
  COPY_EXISTING ~ribald.sto~ ~override/ribald.sto~
    ADD_STORE_ITEM ~myitem~   AFTER  ~olditem~ #10 #0 #0 ~IDENTIFIED~ #5
    ADD_STORE_ITEM ~otheritm~ BEFORE ~olditem~ #10 #0 #0 ~IDENTIFIED~ #5
\end{verbatim}
  Valid options for position are:

  \t{FIRST} will add the item at the top of the stack.
     This is the default, equivalent to putting nothing there.

  \t{LAST} will add the item to the bottom of the stack.

  \t{BEFORE ~olditem~} will add the item exactly before olditem,
    or to the top of the stack if olditem is missing.

  \t{AFTER  ~olditem~} will add the item exactly after olditem,
    or to the bottom of the stack if olditem is missing.

As of 192, if there's a list of items in BEFORE|AFTER olditem (IE \verb+~item1 item2 item3+), 
we add the new item BEFORE or AFTER the first item that is present in the list.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{\DEFINE{ADD!GAM!NPC}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
This tutorial and this feature were thoughtfully provided by Japheth. 

In BGII, the game engine was refined so that when any NPC joined your party
they would be added to the baldur.gam file, regardless of the fact if they
were in there already or not.

Sadly, in BG1 this is not the case.  If you were to simply CreateCreature
any old NPC and add them to your party, as soon as you moved to another
area the game would crash and die.

This is where ADD!GAM!NPC comes in handy for all you BG1 modders out there.

By using ADD!GAM!NPC you can patch your NPC into all the \t{baldur.gam}
files on an end users install.  This includes the default \ttref{GAM} file
that's loaded up when you start a new game as well as all the \ttref{GAM}
files in the \t{save} and \t{mpsave} directories.

Note: However, there really is no foolproof way to back up all the save
games, so you may want to warn the end user in a readme to manually back
them up themselves beforehand.

Anyways, I digress.

To use ADD!GAM!NPC you have to first copy over the \ttref{CRE} file that
you will want to appear in the \ttref{GAM} file.  I'm pretty sure we all
know how to do this, but for completeness, here it is:

\begin{verbatim}
COPY ~mymod/mynpc.cre~ ~override/mynpc.cre~
\end{verbatim}

After the \ttref{COPY} statement, make sure you do all your \ttref{SAY}s
and any other type of patching that you'll want to do for your .cre file.
You will \emph{always} want to use ADD!GAM!NPC last since you want the
updates to your cre file to be reflected in the \ttref{GAM} file as well.

Here's a typical patch statement for most NPC mods:

\begin{verbatim}
COPY ~mymod/mynpc.cre~ ~override/mynpc.cre~
SAY NAME1 ~Japh~
SAY NAME2 ~Japh~
\end{verbatim}

So, after doing all that, we would issue ADD!GAM!NPC with the following
arguments:

\begin{verbatim}
ADD_GAM_NPC "mynpc" "ar2600" #123 #456
\end{verbatim}

``mynpc'' is the name of your NPCs cre file that you're copying over without
the .cre extension.

``ar2600'' is the area that you want him/her placed in.  In this case we're
placing the NPC in Candlekeep.

\#123 is the x co-ordinate on the map.

\#456 is the y co-ordinate on the map.

That's all there is to it.  Just to recap, here's the full set of
expressions we would use:

\begin{verbatim}
COPY ~mymod/mynpc.cre~ ~override/mynpc.cre~
SAY NAME1 ~Japh~
SAY NAME2 ~Japh~
// Do any other patching stuff here
ADD_GAM_NPC ~mynpc~ ~ar2600~ #123 #456
\end{verbatim}

Note: Again, I have to stress the importance of warning the end users to
backup their save and mpsave directories beforehand.  There really is no
elegant way to do this via WeiDU (well, maybe there is, but I can't think
of a way) so I'd just warn them.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{\DEFINE{SET!2DA!ENTRY}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

This tutorial was thoughtfully provided by Idobek.

There have been some queiries about \ttref{SET!2DA!ENTRY} in the WeiDU
forum recently. This is a consolidation of my posts on the subject.
The command takes this form:

\begin{verbatim}
SET_2DA_ENTRY value value value newEntry
\end{verbatim}

The first value is the row, the second is the column and the third is the
required column count. The entry on the given column of the given row is
set to \t{newEntry}, but only rows with at least as many columns as the
required column count are considered. The upper-left entry is 0,0. For
example, given the following 2DA file:

\begin{verbatim}
2DA V1.0
*
     ROWNAME        LOWER MIXED HELP
0    RESERVE        *     *     *
1    BERSERKER      25179 25151 25201
2    WIZARD_SLAYER  25180 25152 25203
3    KENSAI         25181 25153 25204
4    CAVALIER       25182 25154 25206
\end{verbatim}

Then the patch: 

\begin{verbatim}
SET_2DA_ENTRY 3 1 5 ~SAMURAI~ 
\end{verbatim}

would result in:

\begin{verbatim}
2DA V1.0
*
     ROWNAME        LOWER MIXED HELP
0    RESERVE        *     *     *
1    BERSERKER      25179 25151 25201
2    WIZARD_SLAYER  25180 25152 25203
3    SAMURAI        25181 25153 25204
4    CAVALIER       25182 25154 25206
\end{verbatim}

So the columns and rows you want WeiDU to consider are:

\begin{verbatim}
      Column0 Column1       Column2 Column3 Column4

              ROWNAME       LOWER   MIXED   HELP
Row0: 0       RESERVE       *       *       *
Row1: 1       BERSERKER     25179   25151   25201
Row2: 2       WIZARD_SLAYER 25180   25152   25203
Row3: 3       KENSAI        25181   25153   25204
Row4: 4       CAVALIER      25182   25154   25206
\end{verbatim}

The total number of columns is five. If, however, you put 1 as your
required column count then you tell WeiDU you want to consider all rows
with at least 1 column. So your row numbers change:

\begin{verbatim}
Row0: 2DA V1.0
Row1: *
Row2:      ROWNAME        LOWER MIXED HELP
Row3: 0    RESERVE        *     *     *
Row4: 1    BERSERKER      25179 25151 25201
Row5: 2    WIZARD_SLAYER  25180 25152 25203
Row6: 3    KENSAI         25181 25153 25204
Row7: 4    CAVALIER       25182 25154 25206
\end{verbatim}

So the required column count is what you use to tell WeiDU which row you
want to use as row0. So using the code 
\begin{verbatim}
SET_2DA_ENTRY 3 1 1 ~SAMURAI~
\end{verbatim}
would result in:

\begin{verbatim}
2DA V1.0
*
     ROWNAME        LOWER MIXED HELP
0    SAMURAI        *     *     *
1    BERSERKER      25179 25151 25201
2    WIZARD_SLAYER  25180 25152 25203
3    KENSAI         25181 25153 25204
4    CAVALIER       25182 25154 25206
\end{verbatim}

Hopefully, that explains the required column count a little better.

%If you have tried any of the above code you will have found that the
%results are not quite as described. 
%
%\begin{verbatim}
%SET_2DA_ENTRY 3 1 5 ~SAMURAI~ 
%\end{verbatim} 
%actually resulted in:
%
%\begin{verbatim}
%2DA             V1.0
%*
%ROWNAME         LOWER           MIXED           HELP
%0               RESERVE         *               *               *
%1               BERSERKER       25179           25151           25201
%2               WIZARD_SLAYER   25180           25152           25203
%3               SAMURAI         25181           25153           25204
%4               CAVALIER        25182           25154           25206
%\end{verbatim}
%
%This, I imagine, is not what you were expecting. Well don't worry: Nothing
%is wrong and the file \emph{will work fine}. Not aesthetically pleasing
%though. To fix this all you need to do is add another column header using
%\ttref{SET!2DA!ENTRY} on a file and removing it once you are done, like so:
%
%\begin{verbatim}
%SET_2DA_ENTRY 0 0 4 ~IDOBEK ROWNAME~
%SET_2DA_ENTRY 6 1 1 ~SAMURAI~
%SET_2DA_ENTRY 0 0 5 ~~
%\end{verbatim}

Finally, if \t{newEntry} is a string that contains any
\t{\%WeiDU\_Variables\%} they are replaced by their values.
That's the end of this tutorial.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{\ttref{WHILE} Loops (Last update: v189)}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

This tutorial was thoughtfully provided by Idobek, and shamelessly edited
by Bigg to use PATCH!IF rather than IF!EVAL, and PATCH!IF rather than WHILE.

So what is a \t{WHILE} loop? Well very simply put it is a way of
applying the same patch to a file multiple times under a different
condition each time. Or it is a way of applying different patches depending
upon the conditions. This example will show both of these methods. Keeping
in theme we are going to modify the damage done by axes. Now, some axes
have both a melee \emph{and} a ranged ability. We are going to want to
change both of these abilities but give different damage to ranged and
melee.


First, as always, we need to copy the files ready for patching, and throw
in the usual sanity check:
\begin{verbatim}
COPY_EXISTING_REGEXP ~.*\.itm~ ~override~
PATCH_IF ("%SOURCE_SIZE%" > "0x71") BEGIN
\end{verbatim}
We only want to modify axes so let's find out what the item is:
\begin{verbatim}
READ_BYTE 0x1c "category"
\end{verbatim}
Once we are done with our patching we will use \ttref{PATCH!IF} to tell
WeiDU to only patch axes:

\begin{verbatim}
PATCH!IF ("%category%" = 25) BEGIN
\end{verbatim}
Now, we need to find out how many abilities there are and where they are
located:
\begin{verbatim}
READ_LONG 0x64 "abilitiesoffset"
READ_SHORT 0x68 "#abilities"
\end{verbatim}
So far, so good. Here's where the fun begins. We want to patch examine
every ability in the item. We need to use a \ttref{WHILE} loop to patch the
abilities one by one. We open the loop like so:
\begin{verbatim}
WHILE ("%#abilities%" > 0) BEGIN
\end{verbatim}
For the \ttref{WHILE} loop to progress and close we need to modify the
"\#abilities" variable. We use the \ttref{SET} command to do this:

\begin{verbatim}
SET "#abilities" = ("%#abilities%" - 1)
END
\end{verbatim}
These lines are placed at the end of the \ttref{WHILE} loop. WeiDU will
process the abilities from last to first and reduce the "\#abilities"
variable by one each time. Once the "\#abilities" variable hits zero the
\ttref{WHILE} loop will stop.

OK, now we need to find out what type of ability we are looking at. Within
an item an ability is 0x38 bytes, abilities also count from 0 within items
so we must take this into account:
\begin{verbatim}
READ_BYTE ("%abilitiesoffset%" + ("%#abilities%" - 1) * 0x38) "abilitytype"
\end{verbatim}
Now we get to the meat of the patch. This patch is conditional on the
ability type we have just read. First we will deal with the melee damage
patch. We are going to be using a \ttref{PATCH!IF} command to do this

\begin{verbatim}
PATCHING ("%abilitytype%" = 1) BEGIN
\end{verbatim}
So we are patching when the ability type is 1 (melee). Time for the actual patch:
\begin{verbatim}
WRITE_SHORT ("%abilitiesoffset%" + ("%#abilities%" - 1) * 0x38 + 0x16) 6
WRITE_SHORT ("%abilitiesoffset%" + ("%#abilities%" - 1) * 0x38 + 0x18) 2
\end{verbatim}
Time to close the PATCH!IF statement.
\begin{verbatim}
END
\end{verbatim}
We use exactly the same method for ranged abilities:
\begin{verbatim}

PATCH!IF ("%abilitytype%" = 2) BEGIN
   WRITE_SHORT ("%abilitiesoffset%" + ("%#abilities%" - 1) * 0x38 + 0x16) 12
   WRITE_SHORT ("%abilitiesoffset%" + ("%#abilities%" - 1) * 0x38 + 0x18) 1
END
\end{verbatim}
We can now close the main loop (using the aforementioned method):
\begin{verbatim}
SET "#abilities" = ("%#abilities%" - 1)
END
\end{verbatim}
We are done with our patches so we can add our usual END and BUT!ONLY.
\begin{verbatim}
END
END
BUT!ONLY!IF!IT!CHANGES
\end{verbatim}
The full code is:
\begin{verbatim}
COPY_EXISTING_REGEXP ~.*\.itm~ ~override~
  PATCH_IF ("%SOURCE_SIZE%" > "0x71") BEGIN
    READ_BYTE 0x1c "category"
    PATCH_IF ("%category%" = 25) BEGIN
      READ_LONG 0x64 "abilitiesoffset"
      READ_SHORT 0x68 "#abilities"
      WHILE ("%#abilities%" > 0) BEGIN
        READ_BYTE ("%abilitiesoffset%" + ("%#abilities%" - 1) * 0x38) "abilitytype"
        PATCH_IF ("%abilitytype%" = 1) BEGIN
          WRITE_SHORT ("%abilitiesoffset%" + ("%#abilities%" - 1) * 0x38 + 0x16) 6
          WRITE_SHORT ("%abilitiesoffset%" + ("%#abilities%" - 1) * 0x38 + 0x18) 2
        END
        PATCH_IF ("%abilitytype%" = 2) BEGIN
          WRITE_SHORT ("%abilitiesoffset%" + ("%#abilities%" - 1) * 0x38 + 0x16) 12
          WRITE_SHORT ("%abilitiesoffset%" + ("%#abilities%" - 1) * 0x38 + 0x18) 1
        END
        SET "#abilities" = ("%#abilities%" - 1)
      END
    END
  END
BUT_ONLY_IF_IT_CHANGES
\end{verbatim}

So what have we done? Let's list the steps involved:
\begin{enumerate}
\item First off we copied all the item files ready for patching.
\item Then we the read in the item category.
\item We also read in the number of abilities and the file location of those abilities.
\item We open a \ttref{WHILE} loop based upon the number of abilities.
\item Within the \ttref{WHILE} loop, we read in the ability type.
\item Next we defined a new variable to indicate that we had not yet patched any melee type abilities.
\item We opened  \ttref{PATCH!IF} statement.
\item We patched melee abilities to do 2D6 damage.
\item We closed this \ttref{PATCH!IF} loop.
\item We repeated steps 6-9 to give the ranged abilities 1D12 damage.
\item We closed our main \ttref{WHILE} loop by reducing the number of abilities by 1 and indicating that it should stop if the number of abilities reached 0.
\item We used an \ttref{IF!EVAL} statement to ensure the patch is only applied to axes.
\end{enumerate}

That's the end of this tutorial.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Bitwise Operators (Last update: v189)}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

This tutorial was thoughtfully provided by CamDawg, and shamelessly edited
by Bigg to use PATCH!IF rather than IF!EVAL.

This was a topic that I struggled with while trying to convert some kits
with unusual item restrictions. Thanks to WeiDU's new bitwise operators,
this is a process that can done dynamically and non-destructively and
affect all items of a particular type, even if added or altered by another
mod (assuming yours is installed after others of course  ). The basic idea
is to construct a function in WeiDU that:

\begin{enumerate}
\item Searches through all item files in the game
\item Reads selected data from an item (type, usability, etc)
\item Alters specific data on an item without changing anything else
\end{enumerate}

This tutorial is basically an expansion on Japheth's excellent
READ/BYTE/LONG/SHORT tutorial and I suggest you take a look at that before
going further.

My initial problem came about when trying to make specific items usable or
unusable by a particular class/race/kit. If you look at the item file
structure at IESDP, you see that all of the unusability flags of an item
are controlled by the individual bits of bytes 0x1E, 0x1F, 0x20 and 0x21
for class/race alignment restrictions and 0x29, 0x2B, 0x2D and 0x2F for the
individual kit restrictions. (Near Infinity combines and displays the four
bytes of class/race restrictions as a single chunk of data.)

A quick aside about notation before I proceed. Numbers in binary (the
strings of bits) are preceded with 0b and hexadecimal numbers (typically
the bytes) are preceded with 0x.  Eight bits make a byte and bits read
right-to-left. So if the second bit is 1 and the rest 0, then the bit would
be written as 0b00000010.

If you were trying to alter the usability of a specific class or race,
simply using a \ttref{WRITE!BYTE} command on any of these particular bytes
would result in changing the usability of an item by all the classes in the
particular byte. The new bitwise operators provide an easier solution.

First we need to look at what the new operators \ttref{BAND} and
\ttref{BOR} do with bits.  They are both ways of combining two bytes, based
on different rules. Both \ttref{BAND} and \ttref{BOR} compare the
individual bits (bit 0 vs bit 0, bit 1 vs bit 1, etc. all the way through
bit 7 vs bit 7) of two bytes. For each individual bit, the following tables
are used to determine the value:

\begin{verbatim}
0 BAND 0 = 0
0 BAND 1 = 0
1 BAND 0 = 0
1 BAND 1 = 1

0 BOR 0 = 0
0 BOR 1 = 1
1 BOR 0 = 1
1 BOR 1 = 1
\end{verbatim}

So if byte 0x23 is 0b00110101 and byte 0x24 is 0b10010001, then 0x23 BAND
0x24 is 0b00010001 whereas 0x23 BOR 0x24 is 0b10110101.

Back to relating this to unusability in items. For an item to be flagged as
unusable, the corresponding bit must be set to 1. A 0 means a particular
item is usable by the class/race. Let's look at the example of changing
mage robes usable by bards. This would go into your TP2 file.

\begin{verbatim}
COPY_EXISTING_REGEXP GLOB ~.*\.itm~ ~override~ //copies all item files
  PATCH_IF ("%SOURCE_SIZE%" > "0x71") BEGIN // avoid crashing on empty items
    READ_BYTE    "0x20" "mage" //reads the byte containing the mage usability flag
    PATCH_IF (("%mage%" BAND "0b00000100") = "0b00000000") BEGIN // if it is usable by mages
      READ_BYTE    "0x1E" "bard" //reads the byte containing bard usability flag
      READ_SHORT    "0x1C" "type" //reads the byte containing item type
      PATCH_IF ("%type%" = "67") OR ("%type%" = "2") BEGIN // if it is a robe or armor
        WRITE_BYTE    "0x1E" ("%bard%" BAND "0b10111111")  // makes usable by bards
      END
    END
  END
BUT_ONLY_IF_IT_CHANGES
\end{verbatim}

This is the same basic idea in Japheth's BYTE tutorial , except now we're
utilizing the bitwise operators in the writing and evaluation commands. The
mage usability flag is the bit 2 in byte 0x20 (IESDP). By checking "\%mage\%"
BAND 0b00000100, the values of any of the 7 other bits (0-1,3-7) are set to
0, whereas bit 2 is equal to 0 if and only if it is 0 to begin with.
Therefore the statement will only be true if the item is usable by mages
(bit 2 = 0). If that is true and the item is a robe or armor, then we write
("\%bard\%" BAND "0b10111111") into the bard usability byte, 0x1E. By using 1
in bits 0-5 and 7, this ensures that the original value of the flag is
preserved, and using 0 in bit 6 ensures that bit 6 is set to 0 regardless
of its previous value--making it usable by bards whether it was before or
not.

Just as an aside, you could read the entire usability block with a
\ttref{READ!LONG} at 0x1E. However, it becomes a pain because then you need
to start writing out all 32 bits when doing the bitwise operations.

Let's try another example. Let's try making large weapons such as
two-handed swords and halberds unusable by short folks--gnomes, halflings,
and dwarves.

\begin{verbatim}
COPY_EXISTING_REGEXP GLOB ~.*\.itm~ ~override~ //copies all item files
  PATCH_IF ("%SOURCE_SIZE%" > "0x71") BEGIN // avoid crashing on empty items
    READ_BYTE    "0x21" "race" //reads the byte containing race usability flags we're interested in
    READ_BYTE    "0x31" "prof" //reads the byte containing item type
    PATCH_IF ("%prof%" = "93") OR    // two-handed sword
             ("%prof%" = "99") BEGIN // or halberd
      WRITE_BYTE    "0x21" ("%race%" BOR "0b00010101")  // makes unusable by dwarves, halflings, and gnomes
    END
  END
BUT_ONLY_IF_IT_CHANGES

\end{verbatim}

In this case, rather than reading the 'type' byte of the item, I've opted
for the 'proficiency' byte. Many two-handed swords in BG2 are classed as
long swords for some reason so in this case proficeiency is a better
indicator if it is a two-handed sword IMHO.

The unusability flags for dwarves, halflings and gnomes are all in byte
0x2F at bits 0, 2, and 4 respectively (thanks again IESDP). By writing
"\%race\%" BOR "0b00010101" to byte 0x2F we're preserving the values of bits
1,3, and 5-7 while setting the 0, 2, and 4 bits to 1 (unusable) regardless
of their previous values.

Thanks especially to Smoketest for helping me with this, Japheth for the
tutorial that inspired this and the help given, and the IESDP team.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Scripting Styles}\label{sec-scripting-styles}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

While the \ttref{BCS} and \ttref{BAF} script formats are common to all
Infinity Engine games, there are three main variants. The variations deal
largely with how ``object parameters'' are expressed. The style used by
Baldur's Gate, Baldur's Gate 2, and Icewind Dale is considered to be the
default. This document will not explain Infinity Engine scripting -- look
for a tutorial elsewhere. 

\begin{tabular}{cp{10in}|p{10in}}
BG BAF Object & \t{EA.GENERAL.RACE.CLASS.SPECIFIC.GENDER.ALIGN} \\
PST BAF Object & \t{EA.FACTION.TEAM.GENERAL.RACE.CLASS.SPECIFIC.GENDER.ALIGN} \\
IWD2 BAF Object & \t{EA.GENERAL.RACE.SUBRACE.CLASS.SPECIFIC.GENDER.ALIGNMNT} \\
\end{tabular}

If \t{SUBRACE.IDS} is present in \t{CHITIN.}\ttref{KEY}, the scripting
style is autodetected as IWD2. Otherwise, if \t{FACTION.IDS} is present,
the scripting style is autodetected as PST. Otherwise the scripting style
is set to BG. The \t{--script-style} command-line argument and the
\ttref{SCRIPT!STYLE} \ttref{TP2} flag both override this default.
You should not need to use \t{--script-style} explicitly if the
\t{--game} is set correctly.

Also, \t{IWD1} and \t{IWD2} have different rules for parsing certain IDS files,
which contain spaces and/or commas in the tokens.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{TP2 \DEFINE{SUBCOMPONENT} Groups (Last Update: v192)}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

This tutorial was thoughtfully provided by CamDawg, and edited by the Bigg
to account for FORCED!SUBCOMPONENT.

\t{SUBCOMPONENT}s allow to group together a set of mutually exclusive mod
components into a single menu-style selection. The primary purpose of
\t{SUBCOMPONENT}s is to streamline mod installation and to make life easier for
end users. For example, \t{SUBCOMPONENT}s are ideal if you wish to provide
multiple portrait selections for an NPC mod, have several kits available to
one NPC, or for changes that conflict with one another (i.e. raising an XP
cap to 10 million or raising it to 20 million). We'll use the first
one (multiple portrait options) as an example.

Without \t{SUBCOMPONENT}s, the install dialogue would look something like this:

\begin{verbatim}
Install Component [Delainy Portrait 1 by Bob]?
[I]nstall, [N]ot Install, or [Q]uit

Install Component [Delainy Portrait 2 by Fred]?
[I]nstall, [N]ot Install, or [Q]uit

Install Component [Delainy Portrait 3 by Wilhelmus]?
[I]nstall, [N]ot Install, or [Q]uit
\end{verbatim}

The end user would need to click through the options each time. Worse,
conflicting components could be installed. These problems can be limited
somewhat by judicious use of predicates, but taking advantage of the
\t{SUBCOMPONENT} feature yields far superior results:

\begin{verbatim}
Install Component [Delainy Portrait]?
[N]o, [Q]uit, or choose one:
 1] Portrait 1 by Bob
 2] Portrait 2 by Fred
 3] Portrait 3 by Wilhelmus
\end{verbatim}

Only one of these options can be installed at any time; re-installing
and selecting a different \t{SUBCOMPONENT} will automatically uninstall the
previously installed one. Setting this up is dead simple:

\begin{verbatim}
BEGIN ~Portrait 1 by Bob~ 
/* The string above is displayed in the subcomponent listing, i.e. the list
with 1] 2] 3] etc. You can, of course, use TRA references instead for this
and the SUBCOMPONENT string below. */
SUBCOMPONENT ~ Delainy Portrait~
/* The string above is displayed as the component listing and must be the
same for each SUBCOMPONENT. The tp2 code that follows is only executed if
this SUBCOMPONENT is selected. */
COPY ~Delainy/portraits/opt1G.bmp~ ~override/CDDELAIG.bmp~
COPY ~Delainy/portraits/opt1M.bmp~ ~override/CDDELAIM.bmp~ 
COPY ~Delainy/portraits/opt1S.bmp~ ~override/CDDELAIS.bmp~

BEGIN ~Portrait 2 by Fred~ 
SUBCOMPONENT ~ Delainy Portrait~
COPY ~Delainy/portraits/opt2G.bmp~ ~override/CDDELAIG.bmp~
COPY ~Delainy/portraits/opt2M.bmp~ ~override/CDDELAIM.bmp~ 
COPY ~Delainy/portraits/opt2S.bmp~ ~override/CDDELAIS.bmp~

BEGIN ~Portrait 3 by Wilhelmus~ 
SUBCOMPONENT ~ Delainy Portrait~
COPY ~Delainy/portraits/opt3G.bmp~ ~override/CDDELAIG.bmp~
COPY ~Delainy/portraits/opt3M.bmp~ ~override/CDDELAIM.bmp~ 
COPY ~Delainy/portraits/opt3S.bmp~ ~override/CDDELAIS.bmp~
\end{verbatim}

Any \ttref{REQUIRE!FILE}s or other module requirements for the whole group
should be put with the first subcomponent. If such a requirement fails,
none of the subcomponents can be installed. In addition, each individual
subcomponent can be guarded by its own predicate. If that predicate fails,
that particular subcomponent cannot be installed. Example:

\begin{verbatim}
BEGIN ~Imoen: Turnip-Mage~
SUBCOMPONENT ~Imoen Mage Kit~ (FILE_EXISTS_IN_GAME ~turnip.spl~)
  // This particular subcomponent will only be displayed if TURNIP.SPL
  // exists. If it does not, you can still install other subcomponents.
\end{verbatim}

One note about \t{SUBCOMPONENT}s and mod ordering: WeiDU will display
\t{SUBCOMPONENT}s in a single grouping no matter if they fall consecutively
in the \ttref{TP2}. However, the component number (the one that gets placed in
\t{weidu.log} and the one you check for in \ttref{REQUIRE!COMPONENT} et al.) is
still based on their \ttref{TP2} order.

As of v192, if all subcomponents fail their requirement, then we don't ask about
the specific group; moreover, if at least one of the subcomponents is defined with
\t{FORCED!SUBCOMPONENT} rather than \t{SUBCOMPONENT}, then the user is forced to
install one of them. This could be useful if you want to ask the user if he wants
biffing of wav files or not (as you need different actions for either choice). 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{\DEFINE{ADD!CRE!ITEM} (Last Update: v189)}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
This tutorial was thoughtfully provided by Japheth.

This command is a little bit more complex.  First I'll list all the valid
flags and inventory slots.

Flags:
\begin{itemize}
\item none
\item identified
\item unstealable
\item stolen
\item undroppable
\item identified\&stolen
\item identified\&unstealable
\item identified\&undroppable
\item unstealable\&undroppable
\item stolen\&undroppable
\item identified\&stolen\&undroppable
\item identified\&unstealable\&undroppable
\end{itemize}

Inventory Slots:
\begin{itemize}
\item helmet
\item armor
\item shield
\item gloves
\item lring
\item rring
\item amulet
\item belt
\item boots
\item weapon1
\item weapon2
\item weapon3
\item weapon4
\item quiver1
\item quiver2
\item quiver3
\item quiver4
\item cloak
\item qitem1
\item qitem2
\item qitem3
\item inv1
\item inv2
\item inv3
\item inv4
\item inv5
\item inv6
\item inv7
\item inv8
\item inv9
\item inv10
\item inv11
\item inv12
\item inv13
\item inv14
\item inv15
\item inv16
\end{itemize}

Now here is the syntax:

\begin{verbatim}
COPY_EXISTING ~alynar.cre~ ~override/alynar.cre~
  ADD_CRE_ITEM ~itemname~ #charge1 #charge2 #charge3 ~Flags~ ~Inventory Slots~ [EQUIP] [TWOHANDED]
\end{verbatim}

\t{EQUIP} and \t{TWOHANDED} are optional and are only needed when dealing
with weapons.  I'll give some examples now.

Example \#1:

If I want to add a Ring of Protection to Sir Alynar, here's what I'd do:

\begin{verbatim}
COPY_EXISTING ~alynar.cre~ ~override/alynar.cre~
  ADD_CRE_ITEM ~ring06~ #0 #0 #0 ~IDENTIFIED~ ~RRING LRING~
\end{verbatim}

This will add the item to his right ring slot. If that slot is full, it
will be added to the left ring slot. If both are full, we move the current
right ring (the first slot in the list) to an an empty inventory slot so
that the Ring of Protection is still put in it's appropriate slot.

Example \#2:

If I want to add a +2 Longsword to his second weapon slot, but \emph{don't}
want to equip it, here's what I'd do:

\begin{verbatim}
COPY_EXISTING ~alynar.cre~ ~override/alynar.cre~
  ADD_CRE_ITEM ~sw1h06~ #0 #0 #0 ~IDENTIFIED~ ~WEAPON2~
\end{verbatim}

Again, if there happens to be a weapon in his second weapon slot already,
then we simply move that weapon to an empty inventory slot.

Example \#3:

Same deal as example \#2 except now I want to equip the sword.

\begin{verbatim}
COPY_EXISTING ~alynar.cre~ ~override/alynar.cre~
  ADD_CRE_ITEM ~sw1h06~ #0 #0 #0 ~IDENTIFIED~ ~WEAPON2~ EQUIP
\end{verbatim}

This will put the sword in his second weapon slot and equip it.  And again,
if there's already a weapon in that slot, it will be moved to an empty
inventory slot.

Example \#4:

If you want to add a two-handed weapon \emph{and} equip it, here's what you do:

\begin{verbatim}
COPY_EXISTING ~alynar.cre~ ~override/alynar.cre~
  ADD_CRE_ITEM ~sw2h01~ #0 #0 #0 ~NONE~ ~WEAPON2~ EQUIP TWOHANDED
\end{verbatim}

This will place the item in the second weapon slot (and again, if there's
already a weapon there it's moved to inventory), remove anything that's in
the shield slot and put it in an empty inventory slot and finally it will
equip the weapon.

If you just want to add a two-handed weapon to a cre but don't need it
equipped, then you don't have to worry about specifying \t{EQUIP} or 
\t{TWOHANDED}.

Finally, it is worth noting that any WeiDU variables inside \t{\%}s in the 
\t{itemname} will be replaced by their values. 

Phew, that's it.

Note: starting from v189, you can use INV, QITEM, QUIVER and RING as shortcuts
respectively
to INV1 INV2 ... INV15 INV16, QITEM1 QITEM2 QITEM3, QUIVER1 QUIVER2 QUIVER3,
RRING LRING

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{\DEFINE{Prompt Customization}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
This tutorial was thoughtfully provided by Rastor.

A customized installer can make your mod look more unique to your end user,
giving a feel that ``This isn't your basic, cookie-cutter mod.''  WeiDU
actually allows for a great deal of customization of the mod installer
program (ie. the \t{setup-mymod.exe} file).  For the most part, just about
every line of text can be changed to suit your needs.  This tutorial will
show you how.

{\bf Understanding the Installer}. 
WeiDU, like most computer programs, draws every line of text that it
displays from a series of strings.  In a default installer (simply a
renamed weidu.exe and the appropriate .tp2), all of the strings that WeiDU
displays are programmed into WeiDU's source code.  Fortunately, weidu
allows you to overwrite these strings with ones of your own choosing.

{\bf prompts.tra}. 
In the WeiDU download package (from http://www.weidu.org), you will find a
file in the \t{examples} folder called \DEFINE{prompts.tra}.  This is the
file that you modify to customize your installer. Go look at it now. 

Upon loading, weidu always looks to see if a \t{prompts.tra} file exists in
the folder that corresponds to the language that the user selects.  If so,
then weidu automatically loads the file and uses it to display your strings
instead of the ones that are normally coded into it.  In order to change
what the setup-mymod.exe file displays to the user, you need to edit this
file and then place it into the relevant language folder.  Your translators
should then translate this into whatever language and include it in that
language folder.

{\bf An Example}. 
Let us assume for a minute that you want the question asking if users want
to install to read:
\begin{verbatim}
You are a big stupid moron if you do not install the [Component Name].
Install?
[Y]es you idiot or [N]o, bonehead or [Q]uit
\end{verbatim}

For obvious reasons, you would never want your mod's installer to
actually say that but it will serve as a good working example.

To change the install component text, find the section of prompts.tra that
corresponds with the text that you wish to change.  In this case, we want
to change \t{@-1006} and \t{@-1008}.  If you look at these lines, you will
see a strange \\n that does not actually appear when the installer is
running.  This is a carriage return (or ``new line'') character.  It simply
indicates that you want any text following it to be inserted below the text
that precedes the carriage return.

The name of the component in your mod is always inserted immediately
following \t{@-1006} without any spaces.  This means that you are going to
want to include a space or a bracket or some other distinguishing character
at the end of your new text, otherwise the installer's text will look
quite strange.  The name of the component also is always followed (with no
spaces) by either line \t{@-1007} or \t{@-1008} depending on whether the
component is already installed or not.

If you want to include more text in your custom line before the \t{[I]nstall or
[N]ot Install} stuff, then simply place it before the \\n character.

To generate the custom text that I presented above, change the lines in
your prompts.tra file to read:
\begin{verbatim}
@-1006= "You are a big stupid moron if you do not install the ["
@-1008= "].  Install?\n[Y]es you idiot or [N]o, bonehead or [Q]uit"
\end{verbatim}

After making these changes, place \t{prompts.tra} into the TRA folder.

If you are familiar with the default text in the installer, then you will
recognize the all of the lines that are listed in \t{prompts.tra}.  You may
change any of the text, but simply remember the meaning of the carriage
return.  The WeiDU installer will not word wrap, meaning that if you insert
a very large line that is not broken up by \\n, the user will not be able
to see all of it.  You should do some experimentation to determine the
optimal length for each line (it's roughly 72 characters).

{\bf What you cannot change}.
Although WeiDU does allow for a large degree of customization, there are a
few things that you cannot change. You cannot change the input keys used to
collect the player's response. You cannot change the \t{Copying one file}
and \t{Compiling dialogues} (and the similar) text.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{\DEFINE{INNER!ACTION}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Normally I would start off with \emph{don't use this feature}, but since
this \ttref{patch} can basically only be used to do really obscure things,
you're probably already a master if you're considering it.

We'll use \ttref{INNER!ACTION} in the context of a hypothetical mod
that causes all monsters to drop special ``skins'' that can be worn by the
PCs, granting the PCs all of the ``natural talents'' (e.g., fire
resistance, seeing through invisibility, animation avatar) of that monster.

First, we will specially prepare a ``template'' object -- a special blank
``skin'' item that has slots equipped effects like ``fire resistance bouns
+0'' and ``natural armor class 10'' and ``change creature animation''. Each
creature ``skin'' will be a specialized copy of this template.

Then we'll consider each monster in turn. We'll read the fire resistance
value from the monster and write that value into a copy of the ``skin''
item. Then we'll repeat the process for ``armor class'', ``cold
resistance'', etc.  We'll also copy over any ``CRE effects'' the creature
might have (e.g., ``can see invisible'') and make them additional equipped
effects of the ``skin'' item. Finally we'll add that personalized ``skin''
item to the monster's inventory. If the monster is \t{C6BODHI.CRE}, we'll
call the skin \t{C6BODHI.ITM}.

We'll give the code in pieces. First, we want to go over every existing
creature and make sure that \t{CREATURE.ITM} doesn't already exist in the
game. If it does we won't make a ``skin'' for that monster. We'll also
include a little size sanity check to make sure that we're not ready any
degenerate 0-byte files.

\begin{verbatim}
COPY_EXISTING_REGEXP GLOB ~.*\.cre~ ~override~
  PATCH_IF
    (SOURCE_SIZE > 0x2c8) AND
    (NOT FILE_CONTAINS_EVALUATED("%SOURCE_RES%.ITM" "ITM"))
  THEN BEGIN // %SOURCE_RES%.ITM does not exist.
\end{verbatim}

See \t{SOURCE!RES}. Using \t{"ITM"} as the
second argument makes \ttref{FILE!CONTAINS!EVALUATED} behave like
\t{FILE!EXISTS!EVALUATED}, since any real item contains \t{ITM} as part of
its header.

Now we're going to read the animation, armor class, resistances, and
creature effects. We'll also equip this creature with its special skin,
even through we haven't made that skin yet.

\begin{verbatim}
    READ_SHORT 0x28    anim_id
    READ_SHORT 0x46    natural_ac
    READ_ASCII 0x59    resists (11) // read 11 bytes (even 0's)
    READ_LONG  0x2c4   eff_off
    READ_LONG  0x2c8   num_eff
    READ_ASCII eff_off effects (num_eff * 264)
    ADD_CRE_ITEM ~%SOURCE_RES%~ #0 #0 #0 ~IDENTIFIED~ ~INV10~
\end{verbatim}

Since there are 11 resistances (e.g., fire, cold, magic fire, ...) we are
just leaving them in a string as an array of bytes rather than making up
individual variables for each one. Now we want to go about creating our
special skin item. We'll use the mysterious \ttref{INNER!ACTION} to do so.

\begin{verbatim}
    INNER_ACTION BEGIN
      COPY ~foo/footemp.itm~ ~override/%SOURCE_RES%.ITM~
        WRITE_SHORT 0x76 anim_id
        WRITE_SHORT 0xa6 natural_ac
\end{verbatim}

Using \ttref{SOURCE!RES} as part of a computed \ttref{COPY} destination is
normally somewhat dangerous because it is reset every time you enter a
\ttref{COPY} -- but we're OK here.

Our template \t{footemp.itm} item has a number of pre-made equipped
abilities (e.g., no dispel, bypass resistance, apply 100\% of the time to
the wearer, last while equipped) that are just lacking concrete values.
Here we fill in the animation and armor class. Next we'll do the
resistances:

\begin{verbatim}
        // copy over all resistances
        FOR (i=0; i<11 ; i=i+1) BEGIN
          INNER_PATCH "%resists%" BEGIN
            READ_BYTE i resist_i
          END
          foo_resist_off = 0xd6 + (i * (0x102 - 0xd2))
          WRITE_LONG foo_resist_off resist_i
        END
\end{verbatim}

For each of the 11 resistances we remember its value from the creature by
using \ttref{INNER!PATCH} to get it out of our \t{resists} ``array''. The
resistance effects in \t{footemp.itm} are stored in the same order as the
creature resistances are in a \ttref{CRE} file.

Having handled the standard resistances we now turn to creature effects.
We don't know in advance how many creature effects there will be, so for
each one we will make a new effect structure and insert it into our skin
item. We'll get the new effect structure by copying one of the ones that
was already there (called \t{dummy\_eff} in the code below).

Unfortunately, creature effects are not stored in quite the same way as item
effects, so we can't copy them over directly. Instead, from each creature
effect we'll extract the opcode, value and resource fields. We end up with
a three step process: (1) insert some bytes into the skin file to hold the new
effect, (2) copy over the \t{dummy\_eff} effect structure as a framework,
and (3) fill in the appropriate values from the creature effect. Here it
is:

\begin{verbatim}
        // copy all CRE effects
        PATCH_IF num_eff > 0 THEN BEGIN
          READ_ASCII 0x72 dummy_eff (0x30)
          FOR (i=0; i<num_eff; i=i+1) BEGIN
            INNER_PATCH "%effects%" BEGIN
              READ_ASCII ((i * 264) +  8) "cre_eff_opcode" (0x4)
              READ_ASCII ((i * 264) + 20) "cre_eff_value"  (0x8)
              READ_ASCII ((i * 264) + 40) "cre_eff_res"    (0x8)
            END
            INSERT_BYTES 0x72 0x30                        // step 1
            WRITE_EVALUATED_ASCII 0x72 "%dummy_eff%"      // step 2
            WRITE_EVALUATED_ASCII 0x72 "%cre_eff_opcode%" // step 3
            WRITE_EVALUATED_ASCII 0x76 "%cre_eff_value%"  // step 3
            WRITE_EVALUATED_ASCII 0x86 "%cre_eff_res%"    // step 3
          END
          READ_SHORT  0x70 num_global_itm_eff
          WRITE_SHORT 0x70 (num_global_itm_eff + num_eff)
        END
    END
\end{verbatim}

Huzzah. Notice our use of variables to ``pass information'' between the
main copying action and the \ttref{INNER!ACTION}. Yes, I hate WeiDU syntax
as well. Why do you ask? Anyway, after that we update the item header to
take into account the new global effects.

\begin{verbatim}
  END
  BUT_ONLY_IF_IT_CHANGES
\end{verbatim}

Finally we close off our sanity-checks and throw in the ever-popular
\ttref{BUT!ONLY!IF!IT!CHANGES}. It would be ``easy'' (read: annoying and
time-consuming but possible) to extend this hackery so that it also stole
all of the effects from undroppable items held by creature (e.g., most
``undead'' immunities are actually stored in \t{RING95.ITM} and not as
creature effects) by nesting yet-another \ttref{INNER!ACTION}. You could
even be selective and avoid copying over effects like ``minimum hit
points''. Then you could perhaps create an on-the-fly description for the
``skin'' item using \ttref{SAY!EVALUATED}.

Bonus points if you actually understood this code. Additional bonus points
if you find a real use for \ttref{INNER!ACTION} in your mod. As a closing
warning, do not try to re-invent the WeiMorph wheel using a \ttref{TP2}
script -- email Japheth instead.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{\DEFINE{SET!2DA!ENTRY!LATER} and \DEFINE{SET!2DA!ENTRIES!NOW} (Last Update: v188)}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\ttref{SET!2DA!ENTRY!LATER} and \ttref{SET!2DA!ENTRIES!NOW} are an extension
of the \ttref{SET!2DA!ENTRY} patch, so you are encouraged to study the
\ttref{SET!2DA!ENTRY} tutorial by Idobek before reading this one.

The main difference between the standard \ttref{SET!2DA!ENTRY} and these new
variants is that S!2!E changes the file each instance, while the LATER
variant stores a list of changes in the memory and then the NOW part flushes
them in one go, resulting faster processing than S!2!E. According to Weimer's
calculations, using LATER/NOW gives an edge when 5 or more S!2!E are to be
applied to the same file.

We'll begin with a side-by-side confrontation of the code, for a mod which
allows Thieves, Cleric/Thieves and Mage/Thieves to use 3 proficiency points
in Two Weapon Fighting:

using S!2!E:
\begin{verbatim}
COPY_EXISTING ~weapprof.2da~ ~override~
  SET_2DA_ENTRY 34 7  1 3
  SET_2DA_ENTRY 34 39 1 3
  SET_2DA_ENTRY 34 40 1 3
\end{verbatim}

using S!2!E!L/N:
\begin{verbatim}
COPY_EXISTING ~weapprof.2da~ ~override~
  SET_2DA_ENTRY_LATER ~_#_#_#weapprof~ 34 7  3
  SET_2DA_ENTRY_LATER ~_#_#_#weapprof~ 34 39 3
  SET_2DA_ENTRY_LATER ~_#_#_#weapprof~ 34 40 3
  SET_2DA_ENTRIES_NOW ~_#_#_#weapprof~ 1
\end{verbatim}

The things to change are the following:
\begin{itemize}
\item you have to replace SET!2DA!ENTRY with SET!2DA!ENTRY!LATER
\item in S!2!E!L you don't have to specify the required coloumn count parameter
(in the example, the '1')
\item in S!2!E!L you have to specify a string (in the example,
\verb+~_#_#_#weapprof~+) before other parameters.
\item finally, after all your SET!2DA!ENTRY!LATER commands, you have to put
SET!2DA!ENTRIES!NOW, the string you put after each S!2!E!L, and the required
coloumn count.
\end{itemize}

You can also split S!2!E!L sessions across multiple parts - but it is easy to shoot
yourself in the foot:
\begin{verbatim}
// this is OK and works
  COPY_EXISTING ~weapprof.2da~ ~override~
    SET_2DA_ENTRY_LATER ~_#_#_#weapprof~ 34 7  3
    SET_2DA_ENTRY_LATER ~_#_#_#weapprof~ 34 39 3
  DO_SOMETHING_ELSE
  COPY_EXISTING ~weapprof.2da~ ~override~
    SET_2DA_ENTRY_LATER ~_#_#_#weapprof~ 34 40 3
    SET_2DA_ENTRIES_NOW ~_#_#_#weapprof~ 1

// this, however, is a bug:
  COPY_EXISTING ~weapprof.2da~ ~override~
    SET_2DA_ENTRY_LATER ~_#_#_#weapprof~ 34 7  3 /* (*) */
  DO_SOMETHING_ELSE
  COPY_EXISTING ~kitlist.2da~ ~override~
    SET_2DA_ENTRY_LATER ~_#_#_#weapprof~ 34 40 3
    SET_2DA_ENTRIES_NOW ~_#_#_#weapprof~ 1
    // BUG: the (*) action is processed to kitlist.2da, not to weapprof.2da.
    // you can use this to scare off newbies if you're mean.
\end{verbatim}

Now, the formalities - which could be useful to avoid hopelessly crashing of your tp2.

\verb+SET_2DA_ENTRY_LATER ~string~ row col value+
does the following variable associations (\t{\%i\%} is a counter which increases with
each S!2!E!L instruction):
\begin{itemize}
\item \verb+SET string%i%r = row+
\item \verb+SET string%i%c = col+
\item \verb+SPRINT string%i%v value+
\end{itemize}
\verb+SET!2DA!ENTRIES!NOW ~string~ row_count+
begins scanning all variables of the form string\t{\%i\%}r, string\t{\%i\%}c and
string\t{\%i\%}v which I spoke about earlier, applies their changes and erases
all those variables (so you can use the same string again).

So it is possible to cheat and/or introduce bugs:
\begin{verbatim}
COPY_EXISTING ~weapprof.2da~ ~override~
  SET_2DA_ENTRY_LATER ~_#_#_#weapprof~ 34 7  3
  SET_2DA_ENTRY_LATER ~_#_#_#weapprof~ 34 39 3
  SET_2DA_ENTRY_LATER ~_#_#_#weapprof~ 34 40 3
  SET _#_#_#weapprof1v = 5
  // BUG: you're doing SET_2DA_ENTRY_LATER ~_#_#_#weapprof~ 34 39 5 (and not 3)
  SET_2DA_ENTRIES_NOW ~_#_#_#weapprof~ 1
\end{verbatim}

SUGGESTION: prefix your S!2!E!L/N strings (which can accept \t{\%variables\%},
by the way) with a standard prefix (and don't use variables starting with that
prefix), to avoid accidental overwrites. I like to use, as a string,
\verb+_#_#_#FILE_NAME+ where FILE!NAME is the name of the file I'm editing.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{\DEFINE{READ!2DA!ENTRIES!NOW} and \DEFINE{READ!2DA!ENTRY!FORMER} (Last Update: v188)}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

READ!2DA!ENTRIES!NOW and READ!2DA!ENTRY!FORMER are a derivation of
\ttref{READ!2DA!ENTRY} pretty much the same way that \ttref{SET!2DA!ENTRY!LATER}
and \ttref{SET!2DA!ENTRIES!NOW} are a derivation of \ttref{SET!2DA!ENTRY}, so
you are advised to be familiar with how \ttref{READ!2DA!ENTRY},
\ttref{SET!2DA!ENTRY!LATER}, and \ttref{SET!2DA!ENTRIES!NOW} work. Ready? Let's go!

Here's a comparison of a R!2!E!N/F with R!2!E:

using R!2!E:
\begin{verbatim}
COPY_EXISTING ~kitlist.2da~ ~override~
  READ_2DA_ENTRY 0 1 9 somevar
  // somevar will be "RESERVE"
\end{verbatim}

using R!2!E!N/F:
\begin{verbatim}
COPY_EXISTING ~kitlist.2da~ ~override~
  READ_2DA_ENTRIES_NOW ~_#_#_#read_kitlist~ 9
  READ_2DA_ENTRY_FORMER ~_#_#_#read_kitlist~ 0 1 somevar
  // somevar will be "RESERVE"
\end{verbatim}

If you have read the tutorial about \ttref{SET!2DA!ENTRY!LATER} and
\ttref{SET!2DA!ENTRIES!NOW} you should already be familiar with the way to
translate this, so I'll only explain the technicalities.

\verb+READ_2DA_ENTRIES_NOW string col_count+
will store inside the variable \verb+%string_row_col%+ the contents of the
cell at row \t{\%row\%} and coloumn \t{\%col\%}, for all rows
with at least \verb+col_count+ items.
The variable \verb+%string%+ will be set to the number of large enough
rows (so, in effect, you also have processed \ttref{COUNT!2DA!ROWS} freely).

\verb+READ_2DA_ENTRY_FORMER string row col variable+
will store inside \verb+variable+ the contents of \verb+%string_row_col%+
which should be the content of the cell \verb+row col col_count+ as defined
by \ttref{READ!2DA!ENTRY}, unless the user edited the variable on his own.
 Here, \verb+col_count+ is defined by READ!2DA!ENTRIES!NOW.

Differently from \ttref{SET!2DA!ENTRIES!NOW}, neither of these two patches
will clear variables from former \ttref{READ!2DA!ENTRIES!NOW}, so be extra-careful
in choosing the string to be unique.

As you can see, I use \verb+_#_#_#read_FILE_NAME+ as a string (the \verb+read_+
part is to proactively avoid possible overlappings with
\ttref{SET!2DA!ENTRY!LATER}, while the WeiDU code also makes sure that these
problems to not occur accidentally).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{DEFINE,LAUNCH,LOCAL and everything else about personal macros (Last Update: v188)}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Macros were originally intended as a way to repeat a certain tp2 truncon
with small or no changes without resorting to copy-and-paste.

First, disclaimers: it's very easy to shoot yourself in the foot, since
there aren't any limits to the variable scoping of macros. Due to this reason, this tutorial
will skip on most basic stuff - if you're going to consider this, you should
already be a master of patching. \\
Also, for brevity, I'll give only examples involving tp2 actions. You can
do everything you're about to read here by substituting DEFINE!ACTION!MACRO
and LAUNCH!ACTION!MACRO with DEFINE!PATCH!MACRO and LAUNCH!PATH!MACRO. There
is no change in the treatment of LOCAL!SPRINT/LOCAL!SET.

For starters, you might want to define a macro that prints "Hello World!" to
the screen.

\begin{verbatim}
// at the tp2 flag level, IE after AUTHOR but before components.
DEFINE_ACTION_MACRO ~HW~ BEGIN
  PRINT ~Hello World!~
END

/* ... */

// a component
BEGIN ~Print Hello World and do nothing~
LAUNCH_ACTION_MACRO ~HW~
\end{verbatim}

So, the synthax is quite simple:
\begin{verbatim}
DEFINE_ACTION_MACRO name-of-the-macro BEGIN
  local variables list
  action list
END
\end{verbatim}
will bind the action listed here with name-of-the-macro. We'll deal with
local variables later. After that, LAUNCH!ACTION!MACRO name-of-the-macro
will work like if you copy-pasted there the action list defined in
DEFINE!ACTION!MACRO.

Well, suppose you wanted to say 'Hello Jon!' or 'Hello Jack!' or any other
name, rather than only 'Hello World!'. Do you have to define a macro for each
of these? Of course not, since all variables defined before the LAUNCH!ACTION!MACRO
instruction is called are not cleared, and so can be read (or written) during execution of the macro.

\begin{verbatim}
// before calling, have the string ~HW_Name~ contain the name of the person
// to greet.
DEFINE_ACTION_MACRO ~HW~ BEGIN
  PRINT ~Hello %HW_Name%!~
END

/* ... */
OUTER_SPRINT ~HW_Name~ ~Jon~
LAUNCH_ACTION_MACRO ~HW~
OUTER_SPRINT ~HW_Name~ ~Jack~
LAUNCH_ACTION_MACRO ~HW~
\end{verbatim}

Variables inside macros that are changed keep their new value once the
macro has finished being computed. This is bad and good at the same time.
For example, you might want to calculate a factorial:
\begin{verbatim}
// set ~%factorial_index%~ to the factorial you'd like to compute,
// ~%factorial_result%~ to 1,
// keep a backup copy of ~%factorial_index%~
// ~%factorial_result%~ will yield the resulting factorial.
DEFINE_ACTION_MACRO ~factorial~ BEGIN
  ACTION_IF ~%factorial_index%~ != 1 THEN
  BEGIN
    OUTER_SET ~factorial_result~ = ~%factorial_result%~ * ~%factorial_index%~
    OUTER_SET ~factorial_index~ = ~%factorial_index%~ - 1
     LAUNCH_ACTION_MACRO ~factorial~
  END
END

/* ... */
OUTER_SET ~factorial_index_old~ = 5
OUTER_SET ~factorial_index~ = 5
OUTER_SET ~factorial_result~ = 1
LAUNCH_ACTION_MACRO ~factorial~
PRINT ~%factorial_index_old%! = %factorial_result%~
\end{verbatim}
TThe fact that variables are kept through the entire tp2 execution (formally,
that they are global) is good, since you have a way of 'remembering' the result;
however, the bad part is that it may happen that variables are changed even if you
didn't want them to.\\
Note: risks grow exponentially as you use macros by somebody else.

By the way, another (rarely) useful feature of macros used here is that they
can call themselves (formally, they are recursive).

To solve the problem with variables being changed inside a macro, I provided
a rudimentary form of scoping: the aforementioned local variables list part.

Note: if 'global' and 'local' variables mean nothing to you (for example, if you
don't have experience in programming in real life languages) you might have
problems in understanding the logic beneath the rest of this tutorial. You'll do
fine with the tutorials about standard macros.

Basically, at the beginning of the macro declaration, you may use
\begin{verbatim}
LOCAL_SET name = value
LOCAL_SPRINT variable string
\end{verbatim}
to declare a variable as local, and assign it a new value. Use this for all variables
that don't need to be changed by the macro. After computing the macro, these variables
are set to the value they had before the macro was processed. They work for both
actions and patches. For example, here is a corrected
factorial macro (also converted to patch):
\begin{verbatim}
// set ~%tb#factorial_index%~ to the factorial you'd like to compute,
// ~%tb#factorial_result%~ to 1,
// ~%ftb#actorial_result%~ will yield the resulting factorial.
DEFINE_PATCH_MACRO ~tb#factorial~ BEGIN
  LOCAL_SET ~tb#factorial_index~ = ~%factorial_index%~
  PATCH_IF ~%tb#factorial_index%~ != 1 THEN
  BEGIN
    SET ~tb#factorial_result~ = ~%tb#factorial_result%~ * ~%tb#factorial_index%~
    SET ~tb#factorial_index~ = ~%tb#factorial_index%~ - 1
    LAUNCH_PATCH_MACRO ~tb#factorial~
  END
END

/* ... */
SET ~tb#factorial_index~ = 5
SET ~tb#factorial_result~ = 1
LAUNCH_PATCH_MACRO ~tb#factorial~
PATCH_PRINT ~%tb#factorial_index%! = %tb#factorial_result%~
\end{verbatim}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{standard macros (Last Update: v188)}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

For your convenience, WeiDU includes some standard macros for you to use.
See \ttref{Macros Listing} for a listing of all macros and how to invoke
them in detail. Here I'll describe the standard syntax.

In our example, we'll use the tb\#factorial macro (which is the same as the
last example in the preceeding tutorial).

Description (from \ttref{Macros Listing}):
\verb+tb#factorial+: computes the factorial of a number. \\
This is a PATCH macro.
\begin{itemize}
\item SET \verb+tb#factorial_index+ to the factorial you'd like to compute.
\item SET \verb+tb#factorial_result+ to 1;
\item The result is \verb+tb#factorial_result+.
\end{itemize}

Read the instructions on the variables to set:
\begin{verbatim}
SET ~tb#factorial_index~ = 5
SET ~tb#factorial_result~ = 1
LAUNCH_PATCH_MACRO ~tb#factorial~
PATCH_PRINT ~%tb#factorial_index%! = %tb#factorial_result%~
\end{verbatim}
(since you've read the warnings from the previous tutorial, standard macros
make use of LOCAL!SET/SPRINT to avoid overwriting variables that shouldn't
change).

Another example:

\verb+tb#fix_file_size+: overwrites all files matching a certain regexp with a
certain standard file, if they are under a certain size. \\
This is an ACTION macro.
\begin{itemize}
\item SET \verb+tb#fix_file_size_min+ to the maximum allowed size
(files whose size is exactly this value are NOT overwritten).
\item SPRINT \verb+tb#fix_file_size_target+ to the standard file used to replace file(s) that match the regexp.
\item SPRINT \verb+tb#fix_file_size_category+ to a descriptive name.
\item SPRINT \verb+tb#fix_file_size_regexp+ to the regexp for the file(s) to be checked for a match.
\end{itemize}
So, to overwrite all item files that are smaller than 0x72 with sw1h01.itm
(for example the corrupted iplot*.itm files)
\begin{verbatim}
OUTER_SET tb#fix_file_size_min = 0x72
OUTER_SPRINT tb#fix_file_size_target "SW1H01.ITM"
OUTER_SPRINT tb#fix_file_size_category "items"
OUTER_SPRINT tb#fix_file_size_regexp "^.*\.itm$"
LAUNCH_ACTION_MACRO ~tb#fix_file_size~
\end{verbatim}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{\DEFINE{GROUP}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

The GROUP flag came about in discussing component management with an
abnormally large number of independent components, e.g. BG2 Tweaks. Previously
WeiDU lacked a satisfactory way to organize such a modthe closest feature
would be the top level ASK!EVERY!COMPONENT, which only allows for a single
all-or-none approach.

The solution is a new component flag, GROUP, with the following syntax (and example):

Code:
\begin{verbatim}GROUP string

Code:
BEGIN ~100% Learn Spells~
GROUP ~Convenience Tweaks~
// component code

BEGIN ~Identify All Items~
GROUP ~Convenience Tweaks~
// component code

BEGIN ~Give Edwin his BG2 Stats~
GROUP ~NPC Tweaks~
// component code

BEGIN ~ Give Jaheira her BG2 Stats~
GROUP ~NPC Tweaks~
// component code
\end{verbatim}

Upon installing the mod, the player is now presented with meta-options on
each group at a high level:

Code:
\begin{verbatim}
Would you like to display the category [Convenience Tweaks]? [Y]es/[N]o
Would you like to display the category [NPC Tweaks]? [Y]es/[N]o
\end{verbatim}

Selecting \verb+[N]o+ on any group suppresses those options from being
displayed, leading to a simpler and more controlled installer experience for
the player. In the provided example, selecting \verb+[N]o+ to Convenience
Tweaks and \verb+[Y]es+ to NPC Tweaks would result in WeiDU starting
installation by asking to install the Give Edwin his BG2 Stats component.

GROUP operates independently of SUBCOMPONENT, meaning you can use both to
organize the mod as needed. A few other items of note:
\begin{itemize}
\item A component can belong to multiple GROUPs; a component is not offered
for install if and only if none of its member groups are selected
\item You could, in theory, have two components in the same SUBCOMPONENT
grouping but different GROUPs. Dont do this.
\item Every GROUP must be the first in the list of GROUPs of at least one
component. If you have this:
\begin{verbatim}
BEGIN ~1~
GROUP ~1~

BEGIN ~2~
GROUP ~2~

BEGIN ~123~
GROUP ~1~
GROUP ~2~
GROUP ~3~
\end{verbatim}
the ~3~ group will not be displayed. To workaround, add a dummy component with
only that GROUP:
\begin{verbatim}
BEGIN ~1~
GROUP ~1~

BEGIN ~2~
GROUP ~2~

BEGIN ~123~
GROUP ~1~
GROUP ~2~
GROUP ~3~

BEGIN ~Dummy component because it's too hard to fix this in WeiDU~
DEPRECATED ~Dummy component~
GROUP ~3~
\end{verbatim}
\item If some components of a mod are in a GROUP, but others are not, the
non-GROUPed components will always be presented.
\item Using a GROUP anywhere in your mod will act as an implied
ASK!EVERY!COMPONENT tp2 flag.
\end{itemize}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{\DEFINE{array construct}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

The array construct (for lack of a better term) can be used to create with
ease arrays at the install time. The construct is formed as follows:

\verb+$variable(modifier list)+

It is equivalent to saying

\verb+~variable_%modifier1%_%modifier2%_etc.~+

When it is on the right handed side of a SPRINT or SET statement, the contents of
a variable with the resulting name, if existing, is used in place of the variable name.
This does not happen on the left handed side (this is good for you).

Example dummy use:

\begin{verbatim}
OUTER_SPRINT ~var_1_sbar~ ~300~
OUTER_SPRINT ~var_1~ ~bar~
OUTER_SPRINT $asd(doo) ~f00~
  // equivalent to OUTER_SPRINT ~asd_doo~ ~f00~
OUTER_SET $s(x) = 4
  // equivalent to OUTER_SET ~s_x~ = 4
OUTER_SET one = 1
OUTER_SPRINT two ~sbar~

OUTER_SET ~x~ = $var("%one%" "%two%")
  // equivalent to OUTER_SET ~x~ = ~var_%one%_%two%~
  // which is again equivalent to OUTER_SET ~x~ = ~var_1_sbar~  (which is 300)
OUTER_SPRINT ~y~ $var("%one%")
  // equivalent to OUTER_SPRINT ~y~ (the contents of variable ~var_%one%~/~var_1~ )
OUTER_SPRINT ~z~ $asd(doo)
  // equivalent to OUTER_SPRINT ~z~ (the contents of variable ~asd_doo~ )
OUTER_SPRINT ~t~ $miss(ing)
  // equivalent to OUTER_SPRINT ~t~ (the contents of variable ~miss_ing~
	// there's no variable "miss_ing", so we default to the "miss_ing" text instead )
OUTER_SET ~f~ = $s(x)
  // equivalent to OUTER_SET ~f~ = ~s_%x%~

OUTER_SPRINT $var(x) ~p~
  // equivalent to OUTER_SPRINT ~var_x~ ~p~
OUTER_SPRINT $var(x) ~y~
  // equivalent to OUTER_SPRINT ~var_x~ ~y~
  // notice that the ~var_x~ variable is not checked, so this doesn't become OUTER_SPRINT ~p~ ~y~

PRINT ~"%x% %y% %z% %t% %f% %var_x%" should yeld "300 bar f00 miss_ing 4 y"~
\end{verbatim}

We expect somebody to actually write a mod which uses this form more seriously
this construct and use their code as a more useful example.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{\DEFINE{MODDER} (Last update: v203)}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

The MODDER flag allows for more debugging info to be reported. It is suggested to
leave MODDER enabled while you're developing your mod and then disable it before
you ship it to the players. However, given different coding styles, it is possible
that something gets interpreted as a critical bug for some users and as expected
behavior for others. For this reason, it's possible to fine-tune the reporting level
for some of the bugs that are found. This is done by writing additional modifiers
after your MODDER statement, for example:
\begin{verbatim}
MODDER setup_tra fail area_variables none missing_extern warn
\end{verbatim}

Each option can be set to either NONE, WARN or FAIL with the above synthax,
with the obvious meaning. If none is choosen, WARN is assumed. WARN may generate false positives.
In this case, "INSTALLED WITH WARNINGS" is not displayed.

Here the list of feedback options that you can configure, along with use cases when you
should deactivate them. In all other cases, using FAIL or WARN is a case of personal
preference (for example, use WARN early in the development process and FAIL when you're
near the beta status).
\begin{itemize}
\item setup_tra: a dialogue/script uses @references that aren't available from
     its own tra file, but are taken instead from the tp2-level setup.tra.
     \\
     When to use NONE: you're knowingly using references from
     setup.tra into scripts and/or dialogues, rather than using file-specific TRA files.
\item area_variables: the variable scope in a BAF/D \verb+*Global*("varname","scope")+
     statement is six characters long, but not GLOBAL, MYAREA, LOCALS, or a valid area name.
     \\
     When to use NONE: you biff your .are files using bat files, or you copy them to
		 the override after compiling your scripts.
\item missing_extern: an EXTERN transition in a D file references a DLG file that
     doesn't exist, nor is created in the current file.
     \\
     When to use NONE: you have two separate D files that EXTERN to each other.
\item missing_resref: a file referenced by a scripting command (EG a CRE file for a
     CreateCreature action) is not available.
     \\
     When to use NONE: you biff your files using bat files, or you copy them to
		 the override after compiling your scripts.
\item ict2_actions: you call an I_C_T2 into a state which has different actions.
		 If the different actions look like they're caused by another mod ICT2'ing in
		 the same state, only the warning is printed, further actions are not processed.
     \\
     When to use NONE: you want to ICT2 into a state with different exit actions.
\end{itemize}

As you can see, all of these are catching either really stupid coding practices
(yes, biffing ARE files is really stupid) or are avoidable with minor code
restructuration, but with some people this kind of things is enough to start flame wars,
so here's a way to choose what things I should let through. *shrugs*

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{\DEFINE{READLN} (Last update: v203)}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

This tutorial has been brought to you by plainab.

The goal of this tutorial is to explain the use of READLN within the tp2 structure.
READLN can be used as an action or as a patch.  My experience has been in using it
as an action command. I will describe the usage of READLN and then give you some
examples of its use.  To put it bluntly READLN stands for "read line" and it's use
causes WeiDU to pause and read any information entered by the user on the interface
screen and to then store that information within the given variable.

Syntax:
\begin{verbatim}
ACTION_READLN ~variable~
PATCH_READLN ~variable~
\end{verbatim}

Lets build an example from scratch:

First we need to have something we want to change.  For this example we will use the
stack amount for item files.  We could pick a high number and simply use:

\begin{verbatim}
COPY_EXISTING_REGEXP ~.*\.itm~ ~override~
 WRITE_SHORT 0x38 9999 //stack value
BUT_ONLY_IF_IT_CHANGES
\end{verbatim}

Or we can let the end user choose how many items they want in their stacks. 
To do that we first need to ask the user a question.

\begin{verbatim}
PRINT ~How many of one item do you want to be able to be stacked?~
\end{verbatim}

If we leave it at this, weidu will display the question, but keep running.
We have to make weidu pause and that is where READLN comes in. So we now have:

\begin{verbatim}
PRINT ~How many of one item do you want to be able to be stacked?~
ACTION_READLN ~new_stack~
\end{verbatim}

We can then take this entered value and use it on our copy block.

So the usage in this example would be:

\begin{verbatim}
BEGIN ~Modify the stack value of all items~
PRINT ~How many of one item do you want to be able to be stacked?~
ACTION_READLN ~new_stack~

COPY_EXISTING_REGEXP ~.*\.itm~ ~override~
 WRITE_SHORT 0x38 %new_stack% //stack value
BUT_ONLY_IF_IT_CHANGES
\end{verbatim}

You could leave it at this and it will work, but I will tell you now that the end
user can input any character from their keyboard.  READLN doesn't care what is
entered, but weidu may have problems if it is expecting an integer rather than text.
To get around that issue we need to add a loop that will re-ask the question when the
user enters the incorrect type of information.

\begin{verbatim}
BEGIN ~Modify the stack value of all items~
PRINT ~How many of one item do you want to be able to be stacked?~
ACTION_READLN ~new_stack~

OUTER_WHILE NOT(IS_AN_INT %new_stack%) BEGIN
 PRINT ~How many of one item do you want to be able to be stacked?~
 ACTION_READLN ~new_stack~
END

COPY_EXISTING_REGEXP ~.*\.itm~ ~override~
 WRITE_SHORT 0x38 %new_stack% //stack value
BUT_ONLY_IF_IT_CHANGES
\end{verbatim}

The loop we added looks to see if the entered value is an integer and if the
entered value is not an integer then it will re-ask the question.  This loop
will go indefinitly until the user inputs the correct type of information.
Should your user not understand why they keep getting asked the question you may
wish to add new text to your questions to help them to understand what it is
you are looking for.  As in this example:

\begin{verbatim}
BEGIN ~Modify the stack value of all items~
PRINT ~How many of one item do you want to be able to be stacked?
Please enter your answer as an integer.~
ACTION_READLN ~new_stack~

OUTER_WHILE NOT(IS_AN_INT %new_stack%) BEGIN
 PRINT ~Your answer was not an integer.
Please enter your answer as an integer.
How many of one item do you want to be able to be stacked?~
 ACTION_READLN ~new_stack~
END

COPY_EXISTING_REGEXP ~.*\.itm~ ~override~
 WRITE_SHORT 0x38 %new_stack% //stack value
BUT_ONLY_IF_IT_CHANGES
\end{verbatim}

That is the basics on asking for information from the user and then applying that
information later on in the install process.  PATCH_READLN works just like
ACTION_READLN only it's location of use within the tp2 is different.

\\

Another use of READLN is to create options that the user can choose from.
Top level options are taken care of by the use of SUBCOMPONENT and/or GROUP, but since
WeiDU cannot nest subcomponents, you can use READLN to offer additional choices beneath
the first set of subcomponents.  Here's an example of a finished product where READLN is
used to offer additional choices to a subcomponent.  The relevant parts to this discussion
were taken from iiProjectileRetrievalMod.  I helped to create this portion of the mod.
It works.  I have however since learned of better methods that would eliminate some of the
READLN usage from this example.

\begin{verbatim}
BEGIN ~Easy TUTU~
SUBCOMPONENT ~Projectile Retrieval Mod~
INCLUDE ~iiprojectiler/E22.tph~  // Easy TUTU version of mod

BEGIN ~All other Infinity Engine Games~
SUBCOMPONENT ~Projectile Retrieval Mod~

PRINT ~Please tell me how you'd like to modify your files.

1. I want to modify ALL thrown/projectiles at once.
2. I want to modify each thrown/projectile one at a time.

PLEASE ENTER  1 OR 2  ~
ACTION_READLN how
OUTER_WHILE NOT(IS_AN_INT %how%) || (%how% > 2) || (%how% < 1) BEGIN
 PRINT ~Please tell me how you'd like to modify your files.

1. I want to modify ALL thrown/projectiles at once.
2. I want to modify each thrown/projectile one at a time.

PLEASE ENTER  1 OR 2  ~
 ACTION_READLN how
END

ACTION_IF (%how% = 1) THEN BEGIN
 PRINT ~Please choose how you'd like ALL your projectiles retrieved.

1. Plain projectile only -> Plain projectile only
2. All projectiles       -> Plain projectile only
3. Each projectile       -> Each projectile
4. Magical projectiles   -> Reduced Magical/Plain projectiles

PLEASE ENTER  1, 2, 3, OR 4  ~
 ACTION_READLN choice
 OUTER_WHILE NOT(IS_AN_INT %choice%) OR (%choice% > 4) OR (%choice% < 1) BEGIN
  PRINT ~Please choose how you'd like ALL your projectiles retrieved.

1. Plain projectile only -> Plain projectile only
2. All projectiles       -> Plain projectile only
3. Each projectile       -> Each projectile
4. Magical projectiles   -> Reduced Magical/Plain projectiles

PLEASE ENTER  1, 2, 3, OR 4  ~
  ACTION_READLN choice
 END
\end{verbatim}

The only drawback to using READLN when offering additional choices to the user is
that there is no record within the weidu.log file as to which choices were made.
Should a problem arise during game play it may be difficult to determine which choice
is causing the problem, especially if the player has forgotten which choices they made.
This could be solved by creating your own log file, but that is another tutorial...

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{\DEFINE{Functions} (Last update: V210)}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Macros can have unintended side effects because they change the global variable environment.
You have to be extremely careful when interacting with the ``outside''.

That's why functions were introduced in v209. Any changes to the variables are only visible
inside the function. You can also provide default arguments and return values.

As with macros these functions come in an ACTION and a PATCH variant. So the corresponding
commands are: DEFINE!ACTION!FUNCTION / DEFINE!PATCH!FUNCTION (both actions) and
LAUNCH!ACTION!FUNCTION (action) / LAUNCH!PATCH!FUNCTION (patch).

Before you can use a function you have to DEFINE it:
\begin{verbatim}
DEFINE_PATCH_FUNCTION count_spells INT_VAR level = 1 STR_VAR type = "WI" RET num BEGIN
    SET num = 0
    PATCH_IF (~%SOURCE_EXT%~ STRING_EQUAL_CASE ~CRE~) THEN BEGIN
        // do some magic here that actually counts the number of spells and sets
        // the variable num to that number.
    END
END
\end{verbatim}

After that you can LAUNCH it:
\begin{verbatim}
COPY_EXISTING ~my.cre~ ~override~
    // count number of level 1 wizard spells (default arguments of the function)
    LAUNCH_PATCH_FUNCTION count_spells RET lvl1_wizard = num END
    // and now the level 5 priest spells
    SET level = 5
    SPRINT type = "PR"
    LAUNCH_PATCH_FUNCTION count_spells RET lvl5_priest = num END

    PATCH_PRINT ~This CRE has %lvl1_wizard% level 1 wizard spells and %lvl5_priest% level 5 priest spells~
\end{verbatim}

Notice that arguments are passed indirectly to the function.
It inherits the variable environment from the caller. So when you launch it,
all variables that are visible at that point are also visible from within the function.

You can provide default values for variables with INT!VAR (integers) and STR!VAR (strings).
If the variable was not defined in the caller's environment the default value is used.

Any variables you change inside the function will revert back to their old value
after the function finishes.
That's why you have to specify what values should be return values.
You can do this in the RET part of the function definition (\verb+RET num+).
When you launch the function you can use these variables to import the value
into your current variable environment (\verb+RET lvl1_wizard = num+).
Separate the variables with a space character if you have multiple return values.

If you don't need certain features simply omit them:
\begin{verbatim}
DEFINE_ACTION_FUNCTION xyz INT_VAR x = 1 y = 2 z = 3 BEGIN
    PRINT ~x: %x%, y: %y%, z: %z%~
END

LAUNCH_ACTION_FUNCTION xyz END
\end{verbatim}

Starting from V210, you can also specify a variable that will be local to the
function environment, without being passed back to the calling environment,
by adding either STR!VAR or INT!VAR to the LAUNCH bit:
\begin{verbatim}
DEFINE_ACTION_FUNCTION xyz INT_VAR x = 1 y = 2 z = 3 BEGIN
    PRINT ~x: %x%, y: %y%, z: %z%~
END

LAUNCH_ACTION_FUNCTION xyz INT_VAR x = 0 END
\end{verbatim}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{\DEFINE{Macros Listing}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
These macros are automatically shipped with WeiDU.

\verb+tb#factorial+: computes the factorial of a number. \\
This is a PATCH macro.
\begin{itemize}
\item SET \verb+tb#factorial_index+ to the factorial you'd like to compute.
\item SET \verb+tb#factorial_result+ to 1;
\item The result is \verb+tb#factorial_result+.
\end{itemize}

\verb+tb#fix_file_size+: overwrites all files matching a certain regexp with a
certain standard file, if they are under a certain size. \\
This is an ACTION macro.
\begin{itemize}
\item SET \verb+tb#fix_file_size_min+ to the maximum allowed size
(files whose size is exactly this value are NOT overwritten).
\item SPRINT \verb+tb#fix_file_size_target+ to the standard file used to replace file(s) that match the regexp.
\item SPRINT \verb+tb#fix_file_size_category+ to a descriptive name.
\item SPRINT \verb+tb#fix_file_size_regexp+ to the regexp for the file(s) to be checked for a match.
\end{itemize}

\\

The following macros were provided by Gort. Note that, differently from the standalone versions, you \emph{need}
to set all the needed values - they aren't initialized automatically.

\verb+DELETE_SPELL_EFFECT+: deletes all extended effects with specified opcode from a spell.
This is a PATCH macro.
\begin{itemize}
\item SET opcode_to_delete to the opcode of the effect you want to delete. Opcode of (-1) will match all effects.
\end{itemize}

\verb+DELETE_ITEM_EFFECT+: deletes all extended effects with specified opcode from an item.
This is a PATCH macro.
\begin{itemize}
\item SET opcode_to_delete to the opcode of the effect you want to delete. Opcode of (-1) will match all effects.
\end{itemize}

\verb+DELETE_ITEM_EQEFFECT+: deletes all equipping effects with specified opcode from an item.
This is a PATCH macro.
\begin{itemize}
\item SET opcode_to_delete to the opcode of the effect you want to delete. Opcode of (-1) will match all effects.
\end{itemize}

\verb+DELETE_CRE_EFFECT+: deletes all effects with specified opcode from a creature. (Warning: doesn't check EFF version)
This is a PATCH macro.
\begin{itemize}
\item SET opcode_to_delete to the opcode of the effect you want to delete. Opcode of (-1) will match all effects.
\end{itemize}

\verb+ITEM_EFFECT_TO_SPELL+: copies all extended effects from the current item to the first extended header of a spell.
This is a PATCH macro.
\begin{itemize}
\item SPRINT ~new_itm_spl~ to a spell you want to copy effects to.
\end{itemize}

\verb+ADD_SPELL_EFFECT+: adds an extended effect to a spell. All variables except probability1 are 0 by default.
This is a PATCH macro.
\begin{itemize}
\item SET opcode to opcode
\item SET target to target type
\item SET timing to timing type
\item SET parameter1 to first parameter
\item SET parameter2 to second parameter
\item SET power to power
\item SET resist_dispel to magic resistance/dispel type
\item SET duration to duration
\item SET probability1 to probability1 (default 100)
\item SET probability2 to probability2
\item SPRINT resource to resource (8 chars max)
\item SET dicenumber to number of dices to be thrown
\item SET dicesize to size of dices to be thrown
\item SET savingthrow to type of savingthrow to be allowed against the effect
\item SET savebonus to saving throw bonus
\item SET header to number of extended header (starting from 1) the effect should be added to (by default the effect is added to every header).
\end{itemize}

\verb+ADD_ITEM_EFFECT+: adds an extended effect to an item.
This is a PATCH macro.
\begin{list}{}{}
\item Syntax is the same as of ADD_SPELL_EFFECT
\end{list}

\verb+ADD_ITEM_EQEFFECT+: adds an equipping effect to an item.
This is a PATCH macro.
\begin{list}{}{}
\item Syntax is the same as of ADD_SPELL_EFFECT
\end{list}

\verb+ADD_CRE_EFFECT+: adds an effect to a creature. All variables except probability1 are 0 by default. (Warning: doesn't check EFF version)
This is a PATCH macro.
\begin{itemize}
\item SET opcode to opcode
\item SET timing to timing type
\item SET target to target type
\item SET parameter1 to first parameter
\item SET parameter2 to second parameter
\item SET parameter3 to third parameter
\item SET parameter4 to forth parameter
\item SET power to power
\item SET resist_dispel to magic resistance/dispel type
\item SET duration to duration
\item SET probability1 to probability1 (default 100)
\item SET probability2 to probability2
\item SPRINT resource to resource (8 chars max)
\item SPRINT resource2 to second resource (8 chars max)
\item SPRINT vvcresource to VVC resource (8 chars max)
\item SPRINT effsource to effect source
\item SPRINT effvar to effect variable
\item SET dicenumber to number of dices to be thrown
\item SET dicesize to size of dices to be thrown
\item SET savingthrow to type of savingthrow to be allowed against the effect
\item SET savebonus to saving throw bonus
\item SET school to magical school
\item SET lowestafflvl to lowest affected level
\item SET highestafflvl to highest affected level
\item SET casterx to caster X position
\item SET castery to caster Y position
\item SET targetx to target X position
\item SET targety to target Y position
\item SET casterlvl to caster level
\item SET sectype to secondary type
\end{itemize}

\verb+DELETE_CRE_ITEM+: deletes all matching items from a creature. Regexp alowed.
This is a PATCH macro.
\begin{itemize}
\item SPRINT item_to_delete to the item you want to delete.
\end{itemize}

\verb+DELETE_STORE_ITEM+: deletes all matching items from a store. Regexp alowed.
This is a PATCH macro.
\begin{itemize}
\item SPRINT item_to_delete to the item you want to delete.
\end{itemize}

\verb+DELETE_AREA_ITEM+: deletes all matching items from an area. Regexp alowed.
This is a PATCH macro.
\begin{itemize}
\item SPRINT item_to_delete to the item you want to delete.
\end{itemize}

\verb+REPLACE_STORE_ITEM+: replaces all matching items in a store with another item. Regexp alowed.
This is a PATCH macro.
\begin{itemize}
\item SPRINT old_item to the item you want to be replaced
\item SPRINT new_item to the new item
\item SET number_in_stock to number of new items in stock (default 0)
\item SPRINT flags to flags new item should have (usual weidu syntax: STOLEN, IDENTIFIED&STOLEN, etc). Default - no flags.
\item SET charges1 to number of charges of first magical ability (default 0)
\item SET charges2 to number of charges of second magical ability (default 0)
\item SET charges3 to number of charges of third magical ability (default 0)
\end{itemize}

\verb+REPLACE_AREA_ITEM+: replaces all matching items in an area with another item. Regexp alowed.
This is a PATCH macro.
\begin{itemize}
\item SPRINT old_item to the item you want to be replaced
\item SPRINT new_item to the new item
\item SPRINT flags to flags the new item should have (usual weidu syntax: STOLEN, IDENTIFIED&STOLEN, etc). Default - no flags.
\item SET charges1 to amount in stock/number of charges of first magical ability (default 0)
\item SET charges2 to number of charges of second magical ability (default 0)
\item SET charges3 to number of charges of third magical ability (default 0)
\end{itemize}

\verb+ADD_AREA_ITEM+: adds an item to a container of an area.
This is a PATCH macro.
\begin{itemize}
\item SET item_to_add to the item you want to add
\item SET container_to_add_to to number of container the item should be added to.
\item SPRINT flags to flags the item should have (usual weidu syntax: STOLEN, IDENTIFIED&STOLEN, etc). Default - no flags.
\item SET charges1 to amount in stock/number of charges of first magical ability (default 0)
\item SET charges2 to number of charges of second magical ability (default 0)
\item SET charges3 to number of charges of third magical ability (default 0)
\end{itemize}

\verb+ADD_CRE_ITEM_FLAGS+: adds flags to all matching items posessed by a creature. Regexp allowed.
This is a PATCH macro.
\begin{itemize}
\item SPRINT item_to_change to the item the flags should be added to
\item SPRINT flags to flags you need to add (usual weidu syntax: STOLEN, IDENTIFIED&STOLEN, etc).
\end{itemize}

\verb+REMOVE_CRE_ITEM_FLAGS+: removes flags from all matching items posessed by a creature. Regexp allowed.
This is a PATCH macro.
\begin{itemize}
\item SPRINT item_to_change to the item the flags should be removed from
\item SPRINT flags to flags you need to remove (usual weidu syntax: STOLEN, IDENTIFIED&STOLEN, etc).
\end{itemize}

\verb+SET_CRE_ITEM_FLAGS+: set flags to all matching items posessed by a creature. Regexp allowed.
This is a PATCH macro.
\begin{itemize}
\item SPRINT item_to_change to the item which flags should be set
\item SPRINT flags to flags you need to set (usual weidu syntax: STOLEN, IDENTIFIED&STOLEN, etc).
\end{itemize}

\verb+READ_SOUNDSET+: reads soundset of a creature and stores it as an array of string references %soundset%_%i% (i=0-99)
This is an ACTION macro.
\begin{itemize}
\item SPRINT npc to the target creature (with .cre extension)
\item SPRINT soundset to the name of soundset you want.
\end{itemize}

\verb+WRITE_SOUNDSET+: writes soundset to all matching creatures. Regexp allowed.
This is an ACTION macro.
\begin{itemize}
\item SPRINT npc to a creature in question (with .cre extension)
\item SPRINT soundset to name of soundset you have.
\item SET overwrite to 2 if you want new soundset to overwrite the old one completely. Set it to 1 if you want to overwrite old string references only with non-empty new references (may keep some old). Set it to 0 it you want to overwrite only empty old references with new ones.
\end{itemize}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{\DEFINE{Module Distribution}: \t{Setup-MyMod.exe}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

If you rename \t{WeiDU.EXE} to something of the form \t{Setup-MyMod.exe},
it will behave as if the following arguments were present:
\begin{itemize}
\item \t{--tlkout \t{DIALOG.}\ttref{TLK}}
\item \t{--ftlkout \t{DIALOGF.}\ttref{TLK}} (if \t{\t{DIALOGF.}\ttref{TLK}} is present)
\item \t{--log Setup-MyMod.DEBUG}
\item \t{Setup-MyMod.tp2}
\item \t{MyMod.tp2}
\item \t{Mymod/Setup-MyMod.tp2}
\item \t{Mymod/MyMod.tp2}
\end{itemize}

\subsection{Module Distribution Conventions}

To distribute your mod, rename \t{WeiDU.EXE} to \t{Setup-MyMod.EXE} (or
whatever), put \t{Setup-MyMod.TP2} file in the same directory and go!
Typically mods are distributed a ZIP files or self-extracting archives that
put the \t{EXE}, \ttref{TP2} and module data files in the main BGII
directory.

If your mod adds new resources to the game (e.g., via \ttref{COPY}) you
should be careful to pick a unique name so that you resource will not
conflict with one created by another mod. For example (and I speak from
personal experience here), naming a creature \t{BOO2.CRE} is just asking
for trouble. One common approach here is to pick a special prefix that uses
a character not found in normal game resources. For example, I might use
the prefix \t{W\#} and call a sword \t{W\#SWORD.ITM}
and a new spell \t{W\#SPELL.SPL}. However, it it still possible to run into
conflicts, so I recommend that you check out the
Community Mod Filename Prefix Reservations project at
\ahrefurl{http://forums.blackwyrmlair.net/index.php?showtopic=113} and
register your own unique prefix.

\subsection{WeiDU Return Values}

The \t{WeiDU.exe} (or \t{Setup-MyMod.exe}) process will terminate with
a ``return value'' (or ``exit code'' or ``status code'' or ``error level'')
based on the success or failure of certain operations. Depending on your
operating system you can use this value to guide shell scripts or batch
files that include WeiDU. In general, WeiDU returns 0 on success and
non-zero on failure. Here is a concrete list of return values.

\begin{itemize}
\item 0. General Success. No other error on this list was noticed.
\item 1. A \ttref{TP2} \ttref{Component} failed to install.
    A failed installation is one that displays a message like
    ``\t{Stopping installation because of error}'' or
    ``\t{ERROR Installing [Component], rolling back to previous state}'' or
    ``\t{PLEASE email the file SETUP-MYMOD.DEBUG to AUTHOR}'' or
    ``\t{ERROR Re-Installing [MyMod] component 1}''.
\item 2. Auto-Update Error.
\item 3. Auto-Update Retry. The \t{WeiDU.exe} auto-update succeeded, but
you must re-run \t{WeiDU.exe}.
\item 4. Invalid command-line argument.
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Regular Expressions}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

A regular expression or \DEFINE{regexp} is "somewhat" like a DOS wildcard
but not quite. The big difference is that if you would say * in DOS you say
.* in regexp-land.  Here's a definition:

The syntax for regular expressions is the same as in Gnu Emacs. The special
characters are:
\begin{verbatim}
$^.*+?[]\
\end{verbatim}

The following constructs are recognized:
\begin{verbatim}
   .      matches any character except newline
   *      (postfix) matches the previous expression zero, one or several times
   +      (postfix) matches the previous expression one or several times
   ?      (postfix) matches the previous expression once or not at all
   [..]   character set; ranges are denoted with -, as in [a-z];
          an initial ^, as in [^0-9], complements the set
   ^      matches at beginning of line
   $      matches at end of line
   \|     (infix) alternative between two expressions
   \(..\) grouping and naming of the enclosed expression
   \1     the text matched by the first \(...\) expression
          (\2 for the second expression, etc)
   \b     matches word boundaries
   \      quotes special characters.
\end{verbatim}

So spe.* matches "sper01.itm" and "sper.eff" and "special".

Hopefully this is understandable to most people.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{WeiDU \DEFINE{constant}s}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

The following keywords can be used in \t{value}s and evaluate to the given
integer (usually an offset in a \ttref{CRE} file).

\begin{verbatim}
// KEYWORD VALUE
AREA_CITY 0252
AREA_DAY 0260
AREA_DUNGEON 0256
AREA_FOREST 0248
AREA_NIGHT 0264
ATTACK1 0220
ATTACK2 0224
ATTACK3 0228
ATTACK4 0232
BATTLE_CRY1 0200
BATTLE_CRY2 0204
BATTLE_CRY3 0208
BATTLE_CRY4 0212
BATTLE_CRY5 0216
BIO  0x1cc
BORED 0196
COMPLIMENT1 0352
COMPLIMENT2 0356
COMPLIMENT3 0360
CRITICAL_HIT 0424
CRITICAL_MISS 0428
DAMAGE 0236
DESC  0x54
DIALOGUE_DEFAULT 0412
DIALOGUE_HOSTILE 0408
DYING 0240
EXISTANCE1 0444
EXISTANCE2 0448
EXISTANCE3 0452
EXISTANCE4 0456
EXISTANCE5 0460
HAPPY 0172
HURT 0244
IDENTIFIED_DESC  0x54
INITIAL_MEETING 0164
INSULT 0340
INTERACTION1 0320
INTERACTION2 0324
INTERACTION3 0328
INTERACTION4 0332
INTERACTION5 0336
INVENTORY_FULL 0436
LEADER 0188
MISCELLANEOUS 0384
MORALE 0168
NAME1 8
NAME2 12
PICKED_POCKET 0440
REACT_TO_DIE_GENERAL 0376
REACT_TO_DIE_SPECIFIC 0380
RESPONSE_TO_COMPLIMENT2 0388
RESPONSE_TO_COMPLIMENT3 0392
RESPONSE_TO_INSULT1 0396
RESPONSE_TO_INSULT2 0400
RESPONSE_TO_INSULT3 0404
SELECT_ACTION1 0292
SELECT_ACTION2 0296
SELECT_ACTION3 0300
SELECT_ACTION4 0304
SELECT_ACTION5 0308
SELECT_ACTION6 0312
SELECT_ACTION7 0316
SELECT_COMMON1 0268
SELECT_COMMON2 0272
SELECT_COMMON3 0276
SELECT_COMMON4 0280
SELECT_COMMON5 0284
SELECT_COMMON6 0288
SELECT_RARE1 0416
SELECT_RARE2 0420
SPECIAL1 0364
SPECIAL2 0368
SPECIAL3 0372
TARGET_IMMUNE 0432
TIRED 0192
UNHAPPY_ANNOYED 0176
UNHAPPY_BREAKING 0184
UNHAPPY_SERIOUS 0180
UNIDENTIFIED_DESC 0080
HIDDEN_IN_SHADOWS 0444
SPELL_DISRUPTED 0448
SET_A_TRAP 0452
STORE_NAME 12

SCRIPT_OVERRIDE 0x248
SCRIPT_CLASS 0x250
SCRIPT_RACE 0x258
SCRIPT_GENERAL 0x260
SCRIPT_DEFAULT 0x268
DEATHVAR 0x280
DIALOG 0x2cc
AREA_SCRIPT 0x94
\end{verbatim}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Common File Formats}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

This section briefly explains some common file formats. The definitive
reference is
\ahrefurl{\url{http://iesdp.gibberlings3.net/}}.

\begin{itemize}

\item \DEFINE{2DA}. A 2DA file is a text file that includes some game rules
or file information. Kits, music, weapon proficiencies and experience point
caps are all controlled by 2DA files.

\item \DEFINE{BIFF}. A BIFF file is like a big ZIP file that contains other
files. Basically every file used by an Infinity Engine game is either in a
BIFF somewhere or in the \t{override} folder.

\item \DEFINE{BCS}. An Infinity Engine script. These are used to controll
the actions of creatures and areas. They are basically big lists of
\t{IF}s. \ttref{D} files (and also \ttref{DLG} files) use the same
predicate and action syntax as BCS files.

\item \DEFINE{EFF}. An Infinity Engine effect file. These are somtimes used
by \ttref{ITM}s or \ttref{SPL}s to do one specific thing. You probably
won't use them.

\item \DEFINE{ITM}. An Infinity Engine item definition file. Notably,
\ttref{ITM} files have identified and unidentified names that are often set
using the \ttref{TP2 Action} \ttref{COPY}.

\item \DEFINE{KEY}. A KEY file is an index into \ttref{BIFF} files. Given a
resource (like \t{sw1h01.itm}) you can use the KEY file to find out where
it is in the \ttref{BIFF}s. The default KEY file is \t{CHITIN.KEY}.

\item \DEFINE{SPL}. An Infinity Engine spell definition file. Spells have
names that are often set using the \ttref{TP2 Action} \ttref{COPY}.

\item \DEFINE{TLK}. A TLK file is basically a big array of strings. Items
and spells and dialogues in the game have references into this big array
instead of having actual text in them. So a sword item doesn't have the
text "Longsword" anywhere in it. Instead if says "use strref \#1234 for my
name". The game looks up the \#1234th entry in the TLK file and prints that
on the screen. The default TLK file is called \t{\t{DIALOG.}\ttref{TLK}}.

\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{The Source Code}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

The source code to WeiDU is available under the GNU General Public License,
as detailed in the file \t{COPYING}. If for some reason you are unable to
obtain a copy of the GPL, merely announce that fact on some public forum
and your mailbox will be full of copies of it for life. It's a great way to
meet new people.

Since this is the world of Windows, I distribute a pre-compiled binary.
WeiDU is written in OCaml, a functional programming language that includes
automatic memory management, higher-order functions and efficient native
code generation. If these terms mean nothing to you, you probably won't be
able to modify the source code.

However, if you do want to modify the source and then recompile WeiDU, it's
quite easy. Make sure that you have OCaml 3.10 (or newer), sed (or Perl
5.6), make and either gcc or (optionally) cl (the Microsoft Visual C
Compiler).

Edit the \t{Configuration} file and pick your configuration. If you're not
x86/windows/cygwin or x86/linux, you'll have to do some tweaking. Then just
type \t{make clean} and then \t{make}. Presto, you've recompiled it.

WeiDU uses the GPL'd \t{zlib} and \t{xdiff} libraries, as well as portions from
the BSD'd \t{Elkhound} program.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Special Thanks}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
{\em Weimer's thank you}:
I would like to thank the fine folks at the Infinity Engine File Format
Hacking Project, without which this would not have been possible:
\ahrefurl{\url{http://iesdp.gibberlings3.net/}}.

In addition, I make heavy use of Near Infinity for general IE mods: \ahrefurl{\url{http://www.idi.ntnu.no/~joh/ni/}}.

The Infinity Engine Editor Pro was very good at changing \ttref{ITM}s and
\ttref{SPL}s, but DLTCEP is now a better choice:
\ahrefurl{\url{http://www.dragonlancetc.com/forums/index.php?board=9}}.

Kudos to my main out-of-house developer:
\begin{itemize}
\item Fred S. Richardson (he slices, he dices, he sends diffs!)
\item Japheth (also sends diffs!)
\end{itemize}

Special thanks to my main bug-finders *cough* I mean beta-testers:
\begin{itemize}
\item {\em Jason Compton } (and his witty wife)
\item Ghreyfain
\item Michael Lyashenko
\item Quitch
\item Dyara
\item M
\item Rene Heroux
\item Avenger TeamBG
\item Sim
\item devSin

\end{itemize}

Special thanks to Greg Henry for being the first person to mention WeiDU to
me in a face-to-face conversation. I was quite impressed. Jason Compton is
the first person to mention WeiDU to me in a telephone conversation. Scott
McPeak is the first person to discuss my modding hobby with me in a
face-to-face conversation (and he was quite well-informed).

The Bigg would additionally like to thank the following contributors:
\begin{itemize}
\item DevSin (also sends diffs and tests and compiles!)
\item cmorgan for his excellent throughtput while testing.
\item Taimon (also sends diffs and tests!)
\item Gort (sends tp2 macros!)
\item vit-mg (sends documentation!)
\item Mike1072 (sends documentation!)
\end{itemize}
and additionally
\begin{itemize}
\item {\em Weimer} for having written (and mantained) the excellent WeiDU,
and having offered it freely (both as free beer and freedom) to the gaming
community.
\item All the people I've been modding with, all the people who played my mods,
and all of the BG modding community, for having been a very friendly community
(and, in some cases, even very good friends) in these last four years (or more,
this part was written in Jun 2008). It's for you that I've learned OcaML and
started editing WeiDU.
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Informal Copyright Notice}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
WeiDU was originally made by Westley Weimer.
I (Valerio Bigiani, AKA The Bigg) decided to mantain the 'WeiDU' software
according to the GPL terms, under which WeiDU is distributed, starting from
version 186 (which was a closed beta, while the first public release was the
187 one).

What this means is that all praise and credits should go to Weimer, but all
bug reports and feature requests should go to Valerio Bigiani (AKA 'The Bigg').

Since WeiDU was released under GPL, with an added notice that you are also
allowed to distribute unmodified binaries, I assume the same holds true for
mods distributed with this version of WeiDU. However, if you feel like being
nice add a line in your readme stating that the current WeiDU may be downloaded
from <insert link>. Current authorized mirrors include (but may not be limited to)
all those from IEGMC, the Dragon's Hoard Download Centre, and the SHS Download Centre.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Undocumented Features}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Currently undocumented:
\begin{itemize}
\item We might want to mention somewhere that we compile BAF files.
\item {\tt IF!EVAL}.
\item {\tt REPLACE!BCS!BLOCK!REGEXP}.
\item Fred's BCS diff stuff.
\item {\tt --trbify}, \t{TRB} files.
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Index of Terms}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\printindex

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Changes}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
See the file
\ahrefurl{{README-WeiDU-Changes.txt}}
for a description of how WeiDU
has changed over time.
\end{document}
